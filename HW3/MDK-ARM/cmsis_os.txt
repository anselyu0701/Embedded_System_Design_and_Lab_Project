; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\cmsis_os.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\cmsis_os.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\cmsis_os.crf ..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c]
                          THUMB

                          AREA ||i.inHandlerMode||, CODE, READONLY, ALIGN=1

                  inHandlerMode PROC
;;;131    /* Determine whether we are in thread mode or handler mode. */
;;;132    static int inHandlerMode (void)
000000  f3ef8005          MRS      r0,IPSR
;;;133    {
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;134      return __get_IPSR() != 0;
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;135    }
00000a  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.makeCmsisPriority||, CODE, READONLY, ALIGN=1

                  makeCmsisPriority PROC
;;;117    /* Convert from FreeRTOS priority number to CMSIS type osPriority */
;;;118    static osPriority makeCmsisPriority (unsigned portBASE_TYPE fpriority)
000000  4601              MOV      r1,r0
;;;119    {
;;;120      osPriority priority = osPriorityError;
000002  2084              MOVS     r0,#0x84
;;;121      
;;;122      if ((fpriority - tskIDLE_PRIORITY) <= (osPriorityRealtime - osPriorityIdle)) {
000004  2906              CMP      r1,#6
000006  d801              BHI      |L2.12|
000008  1ec9              SUBS     r1,r1,#3              ;119
;;;123        priority = (osPriority)((int)osPriorityIdle + (int)(fpriority - tskIDLE_PRIORITY));
00000a  b208              SXTH     r0,r1
                  |L2.12|
;;;124      }
;;;125      
;;;126      return priority;
;;;127    }
00000c  4770              BX       lr
;;;128    #endif
                          ENDP


                          AREA ||i.makeFreeRtosPriority||, CODE, READONLY, ALIGN=1

                  makeFreeRtosPriority PROC
;;;104    /* Convert from CMSIS type osPriority to FreeRTOS priority number */
;;;105    static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
000000  4601              MOV      r1,r0
;;;106    {
;;;107      unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
000002  2000              MOVS     r0,#0
;;;108      
;;;109      if (priority != osPriorityError) {
000004  2984              CMP      r1,#0x84
000006  d000              BEQ      |L3.10|
;;;110        fpriority += (priority - osPriorityIdle);
000008  1cc8              ADDS     r0,r1,#3
                  |L3.10|
;;;111      }
;;;112      
;;;113      return fpriority;
;;;114    }
00000a  4770              BX       lr
;;;115    
                          ENDP


                          AREA ||i.osDelay||, CODE, READONLY, ALIGN=1

                  osDelay PROC
;;;304    */
;;;305    osStatus osDelay (uint32_t millisec)
000000  b510              PUSH     {r4,lr}
;;;306    {
000002  b900              CBNZ     r0,|L4.6|
;;;307    #if INCLUDE_vTaskDelay
;;;308      TickType_t ticks = millisec / portTICK_PERIOD_MS;
;;;309      
;;;310      vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
000004  2001              MOVS     r0,#1
                  |L4.6|
000006  f7fffffe          BL       vTaskDelay
;;;311      
;;;312      return osOK;
00000a  2000              MOVS     r0,#0
;;;313    #else
;;;314      (void) millisec;
;;;315      
;;;316      return osErrorResource;
;;;317    #endif
;;;318    }
00000c  bd10              POP      {r4,pc}
;;;319    
                          ENDP


                          AREA ||i.osDelayUntil||, CODE, READONLY, ALIGN=1

                  osDelayUntil PROC
;;;1376   */
;;;1377   osStatus osDelayUntil (uint32_t *PreviousWakeTime, uint32_t millisec)
000000  2081              MOVS     r0,#0x81
;;;1378   {
;;;1379   #if INCLUDE_vTaskDelayUntil
;;;1380     TickType_t ticks = (millisec / portTICK_PERIOD_MS);
;;;1381     vTaskDelayUntil((TickType_t *) PreviousWakeTime, ticks ? ticks : 1);
;;;1382     
;;;1383     return osOK;
;;;1384   #else
;;;1385     (void) millisec;
;;;1386     (void) PreviousWakeTime;
;;;1387     
;;;1388     return osErrorResource;
;;;1389   #endif
;;;1390   }
000002  4770              BX       lr
;;;1391   
                          ENDP


                          AREA ||i.osKernelRunning||, CODE, READONLY, ALIGN=1

                  osKernelRunning PROC
;;;166    */
;;;167    int32_t osKernelRunning(void)
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;170      if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L6.14|
;;;171        return 0;
;;;172      else
;;;173        return 1;
00000a  2001              MOVS     r0,#1
;;;174    #else
;;;175    	return (-1);
;;;176    #endif	
;;;177    }
00000c  bd10              POP      {r4,pc}
                  |L6.14|
00000e  2000              MOVS     r0,#0                 ;171
000010  bd10              POP      {r4,pc}
;;;178    
                          ENDP


                          AREA ||i.osKernelStart||, CODE, READONLY, ALIGN=1

                  osKernelStart PROC
;;;151    */
;;;152    osStatus osKernelStart (void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154      vTaskStartScheduler();
000002  f7fffffe          BL       vTaskStartScheduler
;;;155      
;;;156      return osOK;
000006  2000              MOVS     r0,#0
;;;157    }
000008  bd10              POP      {r4,pc}
;;;158    
                          ENDP


                          AREA ||i.osKernelSysTick||, CODE, READONLY, ALIGN=1

                  osKernelSysTick PROC
;;;185    */
;;;186    uint32_t osKernelSysTick(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188      if (inHandlerMode()) {
000002  f7fffffe          BL       inHandlerMode
000006  b118              CBZ      r0,|L8.16|
;;;189        return xTaskGetTickCountFromISR();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      xTaskGetTickCountFromISR
                  |L8.16|
;;;190      }
;;;191      else {
;;;192        return xTaskGetTickCount();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      xTaskGetTickCount
;;;193      }
;;;194    }
;;;195    #endif    // System Timer available
                          ENDP


                          AREA ||i.osMailAlloc||, CODE, READONLY, ALIGN=1

                  osMailAlloc PROC
;;;1090   */
;;;1091   void *osMailAlloc (osMailQId queue_id, uint32_t millisec)
000000  2800              CMP      r0,#0
;;;1092   {
000002  d002              BEQ      |L9.10|
;;;1093     (void) millisec;
;;;1094     void *p;
;;;1095     
;;;1096     
;;;1097     if (queue_id == NULL) {
;;;1098       return NULL;
;;;1099     }
;;;1100     
;;;1101     p = osPoolAlloc(queue_id->pool);
000004  6880              LDR      r0,[r0,#8]
000006  f7ffbffe          B.W      osPoolAlloc
                  |L9.10|
;;;1102     
;;;1103     return p;
;;;1104   }
00000a  4770              BX       lr
;;;1105   
                          ENDP


                          AREA ||i.osMailCAlloc||, CODE, READONLY, ALIGN=1

                  osMailCAlloc PROC
;;;1112   */
;;;1113   void *osMailCAlloc (osMailQId queue_id, uint32_t millisec)
000000  b510              PUSH     {r4,lr}
;;;1114   {
;;;1115     uint32_t i;
;;;1116     void *p = osMailAlloc(queue_id, millisec);
000002  f7fffffe          BL       osMailAlloc
;;;1117     
;;;1118     if (p) {
000006  2800              CMP      r0,#0
000008  d005              BEQ      |L10.22|
;;;1119       for (i = 0; i < sizeof(queue_id->queue_def->item_sz); i++) {
00000a  2100              MOVS     r1,#0
00000c  460a              MOV      r2,r1
                  |L10.14|
;;;1120         ((uint8_t *)p)[i] = 0;
00000e  5442              STRB     r2,[r0,r1]
000010  1c49              ADDS     r1,r1,#1
000012  2904              CMP      r1,#4                 ;1119
000014  d3fb              BCC      |L10.14|
                  |L10.22|
;;;1121       }
;;;1122     }
;;;1123     
;;;1124     return p;
;;;1125   }
000016  bd10              POP      {r4,pc}
;;;1126   
                          ENDP


                          AREA ||i.osMailCreate||, CODE, READONLY, ALIGN=2

                  osMailCreate PROC
;;;1051   */
;;;1052   osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id)
000000  b53e              PUSH     {r1-r5,lr}
;;;1053   {
000002  4604              MOV      r4,r0
;;;1054     (void) thread_id;
;;;1055     
;;;1056     osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  6820              LDR      r0,[r4,#0]
00000e  9000              STR      r0,[sp,#0]
000010  6860              LDR      r0,[r4,#4]
;;;1057     
;;;1058     
;;;1059     /* Create a mail queue control block */
;;;1060     *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
000012  9001              STR      r0,[sp,#4]
000014  200c              MOVS     r0,#0xc
000016  f7fffffe          BL       pvPortMalloc
00001a  68a1              LDR      r1,[r4,#8]
;;;1061     if (*(queue_def->cb) == NULL) {
00001c  2800              CMP      r0,#0
00001e  6008              STR      r0,[r1,#0]
000020  d019              BEQ      |L11.86|
;;;1062       return NULL;
;;;1063     }
;;;1064     (*(queue_def->cb))->queue_def = queue_def;
;;;1065     
;;;1066     /* Create a queue in FreeRTOS */
;;;1067     (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
000022  6004              STR      r4,[r0,#0]
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       xQueueGenericCreate
00002e  68a1              LDR      r1,[r4,#8]
000030  6809              LDR      r1,[r1,#0]
;;;1068     if ((*(queue_def->cb))->handle == NULL) {
000032  6048              STR      r0,[r1,#4]
000034  68a1              LDR      r1,[r4,#8]
000036  6809              LDR      r1,[r1,#0]
000038  b170              CBZ      r0,|L11.88|
;;;1069       vPortFree(*(queue_def->cb));
;;;1070       return NULL;
;;;1071     }
;;;1072     
;;;1073     /* Create a mail pool */
;;;1074     (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       osPoolCreate
000040  0001              MOVS     r1,r0
000042  68a0              LDR      r0,[r4,#8]
000044  6800              LDR      r0,[r0,#0]
;;;1075     if ((*(queue_def->cb))->pool == NULL) {
000046  6081              STR      r1,[r0,#8]
000048  68a0              LDR      r0,[r4,#8]
00004a  6800              LDR      r0,[r0,#0]
00004c  d103              BNE      |L11.86|
;;;1076       //TODO: Delete queue. How to do it in FreeRTOS?
;;;1077       vPortFree(*(queue_def->cb));
00004e  bf00              NOP      
                  |L11.80|
000050  f7fffffe          BL       vPortFree
;;;1078       return NULL;
000054  2000              MOVS     r0,#0
                  |L11.86|
;;;1079     }
;;;1080     
;;;1081     return *(queue_def->cb);
;;;1082   }
000056  bd3e              POP      {r1-r5,pc}
                  |L11.88|
000058  4608              MOV      r0,r1
00005a  e7f9              B        |L11.80|
;;;1083   
                          ENDP


                          AREA ||i.osMailFree||, CODE, READONLY, ALIGN=1

                  osMailFree PROC
;;;1222   */
;;;1223   osStatus osMailFree (osMailQId queue_id, void *mail)
000000  b110              CBZ      r0,|L12.8|
;;;1224   {
;;;1225     if (queue_id == NULL) {
;;;1226       return osErrorParameter;
;;;1227     }
;;;1228     
;;;1229     return osPoolFree(queue_id->pool, mail);
000002  6880              LDR      r0,[r0,#8]
000004  f7ffbffe          B.W      osPoolFree
                  |L12.8|
000008  2080              MOVS     r0,#0x80              ;1226
;;;1230   }
00000a  4770              BX       lr
;;;1231   #endif  /* Use Mail Queues */
                          ENDP


                          AREA ||i.osMailGet||, CODE, READONLY, ALIGN=2

                  osMailGet PROC
;;;1166   */
;;;1167   osEvent osMailGet (osMailQId queue_id, uint32_t millisec)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1168   {
000004  000d              MOVS     r5,r1
000006  4606              MOV      r6,r0
000008  9502              STR      r5,[sp,#8]
00000a  d01e              BEQ      |L13.74|
;;;1169     portBASE_TYPE taskWoken;
;;;1170     TickType_t ticks;
;;;1171     osEvent event;
;;;1172     
;;;1173     event.def.mail_id = queue_id;
;;;1174     
;;;1175     if (queue_id == NULL) {
;;;1176       event.status = osErrorParameter;
;;;1177       return event;
;;;1178     }
;;;1179     
;;;1180     taskWoken = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;1181     
;;;1182     ticks = 0;
000010  4644              MOV      r4,r8
;;;1183     if (millisec == osWaitForever) {
000012  f8cd800c          STR      r8,[sp,#0xc]
000016  1c50              ADDS     r0,r2,#1
000018  d01c              BEQ      |L13.84|
;;;1184       ticks = portMAX_DELAY;
;;;1185     }
;;;1186     else if (millisec != 0) {
00001a  b102              CBZ      r2,|L13.30|
;;;1187       ticks = millisec / portTICK_PERIOD_MS;
00001c  4614              MOV      r4,r2
                  |L13.30|
;;;1188       if (ticks == 0) {
;;;1189         ticks = 1;
;;;1190       }
;;;1191     }
;;;1192     
;;;1193     if (inHandlerMode()) {
00001e  f7fffffe          BL       inHandlerMode
;;;1194       if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {
;;;1195         /* We have mail */
;;;1196         event.status = osEventMail;
000022  2720              MOVS     r7,#0x20
000024  2800              CMP      r0,#0                 ;1193
000026  6868              LDR      r0,[r5,#4]            ;1193
000028  4669              MOV      r1,sp                 ;1171
00002a  d018              BEQ      |L13.94|
00002c  aa03              ADD      r2,sp,#0xc            ;1194
00002e  1d09              ADDS     r1,r1,#4              ;1194
000030  f7fffffe          BL       xQueueReceiveFromISR
000034  2801              CMP      r0,#1                 ;1194
000036  d010              BEQ      |L13.90|
;;;1197       }
;;;1198       else {
;;;1199         event.status = osOK;
000038  f8cd8000          STR      r8,[sp,#0]
                  |L13.60|
;;;1200       }
;;;1201       portEND_SWITCHING_ISR(taskWoken);
00003c  9803              LDR      r0,[sp,#0xc]
00003e  b1c0              CBZ      r0,|L13.114|
000040  4911              LDR      r1,|L13.136|
000042  f04f5080          MOV      r0,#0x10000000
000046  6008              STR      r0,[r1,#0]
000048  e013              B        |L13.114|
                  |L13.74|
00004a  2080              MOVS     r0,#0x80              ;1176
00004c  9000              STR      r0,[sp,#0]            ;1177
00004e  462a              MOV      r2,r5                 ;1177
000050  9901              LDR      r1,[sp,#4]            ;1177
000052  e010              B        |L13.118|
                  |L13.84|
000054  f04f34ff          MOV      r4,#0xffffffff        ;1184
000058  e7e1              B        |L13.30|
                  |L13.90|
00005a  9700              STR      r7,[sp,#0]            ;1196
00005c  e7ee              B        |L13.60|
                  |L13.94|
;;;1202     }
;;;1203     else {
;;;1204       if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {
00005e  2300              MOVS     r3,#0
000060  4622              MOV      r2,r4
000062  1d09              ADDS     r1,r1,#4
000064  f7fffffe          BL       xQueueGenericReceive
000068  2801              CMP      r0,#1
00006a  d008              BEQ      |L13.126|
;;;1205         /* We have mail */
;;;1206         event.status = osEventMail;
;;;1207       }
;;;1208       else {
;;;1209         event.status = (ticks == 0) ? osOK : osEventTimeout;
00006c  b14c              CBZ      r4,|L13.130|
00006e  2040              MOVS     r0,#0x40
                  |L13.112|
000070  9000              STR      r0,[sp,#0]
                  |L13.114|
000072  e89d0007          LDM      sp,{r0-r2}
                  |L13.118|
000076  e8860007          STM      r6,{r0-r2}
;;;1210       }
;;;1211     }
;;;1212     
;;;1213     return event;
;;;1214   }
00007a  e8bd81ff          POP      {r0-r8,pc}
                  |L13.126|
00007e  9700              STR      r7,[sp,#0]            ;1206
000080  e7f7              B        |L13.114|
                  |L13.130|
000082  2000              MOVS     r0,#0                 ;1209
000084  e7f4              B        |L13.112|
;;;1215   
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
                          DCD      0xe000ed04

                          AREA ||i.osMailPut||, CODE, READONLY, ALIGN=2

                  osMailPut PROC
;;;1133   */
;;;1134   osStatus osMailPut (osMailQId queue_id, void *mail)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;1135   {
000002  b082              SUB      sp,sp,#8
000004  0004              MOVS     r4,r0
000006  d00f              BEQ      |L14.40|
;;;1136     portBASE_TYPE taskWoken;
;;;1137     
;;;1138     
;;;1139     if (queue_id == NULL) {
;;;1140       return osErrorParameter;
;;;1141     }
;;;1142     
;;;1143     taskWoken = pdFALSE;
000008  2000              MOVS     r0,#0
;;;1144     
;;;1145     if (inHandlerMode()) {
00000a  9000              STR      r0,[sp,#0]
00000c  f7fffffe          BL       inHandlerMode
000010  2800              CMP      r0,#0
000012  6860              LDR      r0,[r4,#4]
;;;1146       if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
;;;1147         return osErrorOS;
;;;1148       }
;;;1149       portEND_SWITCHING_ISR(taskWoken);
;;;1150     }
;;;1151     else {
;;;1152       if (xQueueSend(queue_id->handle, &mail, 0) != pdTRUE) { 
000014  f04f0300          MOV      r3,#0
000018  d010              BEQ      |L14.60|
00001a  466a              MOV      r2,sp                 ;1146
00001c  a903              ADD      r1,sp,#0xc            ;1146
00001e  f7fffffe          BL       xQueueGenericSendFromISR
000022  2801              CMP      r0,#1                 ;1146
000024  d110              BNE      |L14.72|
000026  e002              B        |L14.46|
                  |L14.40|
000028  2080              MOVS     r0,#0x80              ;1140
                  |L14.42|
;;;1153         return osErrorOS;
;;;1154       }
;;;1155     }
;;;1156     
;;;1157     return osOK;
;;;1158   }
00002a  b004              ADD      sp,sp,#0x10
00002c  bd10              POP      {r4,pc}
                  |L14.46|
00002e  9800              LDR      r0,[sp,#0]            ;1149
000030  b160              CBZ      r0,|L14.76|
000032  4907              LDR      r1,|L14.80|
000034  f04f5080          MOV      r0,#0x10000000        ;1149
000038  6008              STR      r0,[r1,#0]            ;1149
00003a  e007              B        |L14.76|
                  |L14.60|
00003c  2200              MOVS     r2,#0                 ;1152
00003e  a903              ADD      r1,sp,#0xc            ;1152
000040  f7fffffe          BL       xQueueGenericSend
000044  2801              CMP      r0,#1                 ;1152
000046  d001              BEQ      |L14.76|
                  |L14.72|
000048  20ff              MOVS     r0,#0xff              ;1153
00004a  e7ee              B        |L14.42|
                  |L14.76|
00004c  2000              MOVS     r0,#0                 ;1157
00004e  e7ec              B        |L14.42|
;;;1159   
                          ENDP

                  |L14.80|
                          DCD      0xe000ed04

                          AREA ||i.osMessageCreate||, CODE, READONLY, ALIGN=1

                  osMessageCreate PROC
;;;935    */
;;;936    osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
000000  c803              LDM      r0,{r0,r1}
;;;937    {
;;;938      (void) thread_id;
;;;939      
;;;940      return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
000002  2200              MOVS     r2,#0
000004  f7ffbffe          B.W      xQueueGenericCreate
;;;941    }
;;;942    
                          ENDP


                          AREA ||i.osMessageGet||, CODE, READONLY, ALIGN=2

                  osMessageGet PROC
;;;982    */
;;;983    osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;984    {
000004  000d              MOVS     r5,r1
;;;985      portBASE_TYPE taskWoken;
;;;986      TickType_t ticks;
;;;987      osEvent event;
;;;988      
;;;989      event.def.message_id = queue_id;
;;;990      event.value.v = 0;
000006  f04f0600          MOV      r6,#0
00000a  e9cd6501          STRD     r6,r5,[sp,#4]
00000e  4607              MOV      r7,r0                 ;984
000010  d01a              BEQ      |L16.72|
;;;991      
;;;992      if (queue_id == NULL) {
;;;993        event.status = osErrorParameter;
;;;994        return event;
;;;995      }
;;;996      
;;;997      taskWoken = pdFALSE;
;;;998      
;;;999      ticks = 0;
000012  2400              MOVS     r4,#0
;;;1000     if (millisec == osWaitForever) {
000014  9603              STR      r6,[sp,#0xc]
000016  1c50              ADDS     r0,r2,#1
000018  d01b              BEQ      |L16.82|
;;;1001       ticks = portMAX_DELAY;
;;;1002     }
;;;1003     else if (millisec != 0) {
00001a  b102              CBZ      r2,|L16.30|
;;;1004       ticks = millisec / portTICK_PERIOD_MS;
00001c  4614              MOV      r4,r2
                  |L16.30|
;;;1005       if (ticks == 0) {
;;;1006         ticks = 1;
;;;1007       }
;;;1008     }
;;;1009     
;;;1010     if (inHandlerMode()) {
00001e  f7fffffe          BL       inHandlerMode
000022  4669              MOV      r1,sp                 ;987
;;;1011       if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
;;;1012         /* We have mail */
;;;1013         event.status = osEventMessage;
000024  f04f0810          MOV      r8,#0x10
000028  b1c8              CBZ      r0,|L16.94|
00002a  aa03              ADD      r2,sp,#0xc            ;1011
00002c  4628              MOV      r0,r5                 ;1011
00002e  1d09              ADDS     r1,r1,#4              ;1011
000030  f7fffffe          BL       xQueueReceiveFromISR
000034  2801              CMP      r0,#1                 ;1011
000036  d00f              BEQ      |L16.88|
;;;1014       }
;;;1015       else {
;;;1016         event.status = osOK;
000038  9600              STR      r6,[sp,#0]
                  |L16.58|
;;;1017       }
;;;1018       portEND_SWITCHING_ISR(taskWoken);
00003a  9803              LDR      r0,[sp,#0xc]
00003c  b1d0              CBZ      r0,|L16.116|
00003e  4913              LDR      r1,|L16.140|
000040  f04f5080          MOV      r0,#0x10000000
000044  6008              STR      r0,[r1,#0]
000046  e015              B        |L16.116|
                  |L16.72|
000048  2080              MOVS     r0,#0x80              ;993
00004a  4631              MOV      r1,r6                 ;994
00004c  462a              MOV      r2,r5                 ;994
00004e  9000              STR      r0,[sp,#0]            ;994
000050  e012              B        |L16.120|
                  |L16.82|
000052  f04f34ff          MOV      r4,#0xffffffff        ;1001
000056  e7e2              B        |L16.30|
                  |L16.88|
000058  f8cd8000          STR      r8,[sp,#0]            ;1013
00005c  e7ed              B        |L16.58|
                  |L16.94|
;;;1019     }
;;;1020     else {
;;;1021       if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
00005e  2300              MOVS     r3,#0
000060  4622              MOV      r2,r4
000062  4628              MOV      r0,r5
000064  1d09              ADDS     r1,r1,#4
000066  f7fffffe          BL       xQueueGenericReceive
00006a  2801              CMP      r0,#1
00006c  d008              BEQ      |L16.128|
;;;1022         /* We have mail */
;;;1023         event.status = osEventMessage;
;;;1024       }
;;;1025       else {
;;;1026         event.status = (ticks == 0) ? osOK : osEventTimeout;
00006e  b154              CBZ      r4,|L16.134|
000070  2040              MOVS     r0,#0x40
                  |L16.114|
000072  9000              STR      r0,[sp,#0]
                  |L16.116|
000074  e89d0007          LDM      sp,{r0-r2}
                  |L16.120|
000078  e8870007          STM      r7,{r0-r2}
;;;1027       }
;;;1028     }
;;;1029     
;;;1030     return event;
;;;1031   }
00007c  e8bd81ff          POP      {r0-r8,pc}
                  |L16.128|
000080  f8cd8000          STR      r8,[sp,#0]            ;1023
000084  e7f6              B        |L16.116|
                  |L16.134|
000086  2000              MOVS     r0,#0                 ;1026
000088  e7f3              B        |L16.114|
;;;1032   
                          ENDP

00008a  0000              DCW      0x0000
                  |L16.140|
                          DCD      0xe000ed04

                          AREA ||i.osMessagePeek||, CODE, READONLY, ALIGN=2

                  osMessagePeek PROC
;;;1412   */
;;;1413   osEvent osMessagePeek (osMessageQId queue_id, uint32_t millisec)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1414   {
000002  000d              MOVS     r5,r1
000004  4606              MOV      r6,r0
000006  9502              STR      r5,[sp,#8]
000008  d015              BEQ      |L17.54|
;;;1415     TickType_t ticks;
;;;1416     osEvent event;
;;;1417     
;;;1418     event.def.message_id = queue_id;
;;;1419     
;;;1420     if (queue_id == NULL) {
;;;1421       event.status = osErrorParameter;
;;;1422       return event;
;;;1423     }
;;;1424     
;;;1425     ticks = 0;
00000a  2400              MOVS     r4,#0
;;;1426     if (millisec == osWaitForever) {
00000c  1c50              ADDS     r0,r2,#1
00000e  d017              BEQ      |L17.64|
;;;1427       ticks = portMAX_DELAY;
;;;1428     }
;;;1429     else if (millisec != 0) {
000010  b102              CBZ      r2,|L17.20|
;;;1430       ticks = millisec / portTICK_PERIOD_MS;
000012  4614              MOV      r4,r2
                  |L17.20|
;;;1431       if (ticks == 0) {
;;;1432         ticks = 1;
;;;1433       }
;;;1434     }
;;;1435     
;;;1436     if (xQueuePeek(queue_id, &event.value.v, ticks) == pdTRUE) 
000014  2301              MOVS     r3,#1
000016  4622              MOV      r2,r4
000018  4628              MOV      r0,r5
00001a  a901              ADD      r1,sp,#4
00001c  f7fffffe          BL       xQueueGenericReceive
000020  2801              CMP      r0,#1
000022  d010              BEQ      |L17.70|
;;;1437     {
;;;1438       /* We have mail */
;;;1439       event.status = osEventMessage;
;;;1440     }
;;;1441     else 
;;;1442     {
;;;1443       event.status = (ticks == 0) ? osOK : osEventTimeout;
000024  b18c              CBZ      r4,|L17.74|
000026  2040              MOVS     r0,#0x40
                  |L17.40|
000028  9000              STR      r0,[sp,#0]
00002a  e9dd1201          LDRD     r1,r2,[sp,#4]
00002e  bf00              NOP      
                  |L17.48|
000030  e8860007          STM      r6,{r0-r2}
;;;1444     }
;;;1445     
;;;1446     return event;
;;;1447   }
000034  bdfe              POP      {r1-r7,pc}
                  |L17.54|
000036  2080              MOVS     r0,#0x80              ;1421
000038  9000              STR      r0,[sp,#0]            ;1422
00003a  462a              MOV      r2,r5                 ;1422
00003c  9901              LDR      r1,[sp,#4]            ;1422
00003e  e7f7              B        |L17.48|
                  |L17.64|
000040  f04f34ff          MOV      r4,#0xffffffff        ;1427
000044  e7e6              B        |L17.20|
                  |L17.70|
000046  2010              MOVS     r0,#0x10              ;1439
000048  e7ee              B        |L17.40|
                  |L17.74|
00004a  2000              MOVS     r0,#0                 ;1443
00004c  e7ec              B        |L17.40|
;;;1448   
                          ENDP


                          AREA ||i.osMessagePut||, CODE, READONLY, ALIGN=2

                  osMessagePut PROC
;;;950    */
;;;951    osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;952    {
000002  4605              MOV      r5,r0
000004  b082              SUB      sp,sp,#8
;;;953      portBASE_TYPE taskWoken = pdFALSE;
000006  2000              MOVS     r0,#0
;;;954      TickType_t ticks;
;;;955      
;;;956      ticks = millisec / portTICK_PERIOD_MS;
000008  9000              STR      r0,[sp,#0]
00000a  0014              MOVS     r4,r2
00000c  d100              BNE      |L18.16|
;;;957      if (ticks == 0) {
;;;958        ticks = 1;
00000e  2401              MOVS     r4,#1
                  |L18.16|
;;;959      }
;;;960      
;;;961      if (inHandlerMode()) {
000010  f7fffffe          BL       inHandlerMode
;;;962        if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
;;;963          return osErrorOS;
;;;964        }
;;;965        portEND_SWITCHING_ISR(taskWoken);
;;;966      }
;;;967      else {
;;;968        if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
000014  f04f0300          MOV      r3,#0
000018  b168              CBZ      r0,|L18.54|
00001a  466a              MOV      r2,sp                 ;962
00001c  a903              ADD      r1,sp,#0xc            ;962
00001e  4628              MOV      r0,r5                 ;962
000020  f7fffffe          BL       xQueueGenericSendFromISR
000024  2801              CMP      r0,#1                 ;962
000026  d10d              BNE      |L18.68|
000028  9800              LDR      r0,[sp,#0]            ;965
00002a  b170              CBZ      r0,|L18.74|
00002c  4908              LDR      r1,|L18.80|
00002e  f04f5080          MOV      r0,#0x10000000        ;965
000032  6008              STR      r0,[r1,#0]            ;965
000034  e009              B        |L18.74|
                  |L18.54|
000036  4622              MOV      r2,r4
000038  a903              ADD      r1,sp,#0xc
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       xQueueGenericSend
000040  2801              CMP      r0,#1
000042  d002              BEQ      |L18.74|
                  |L18.68|
;;;969          return osErrorOS;
000044  20ff              MOVS     r0,#0xff
                  |L18.70|
;;;970        }
;;;971      }
;;;972      
;;;973      return osOK;
;;;974    }
000046  b005              ADD      sp,sp,#0x14
000048  bd30              POP      {r4,r5,pc}
                  |L18.74|
00004a  2000              MOVS     r0,#0                 ;973
00004c  e7fb              B        |L18.70|
;;;975    
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
                          DCD      0xe000ed04

                          AREA ||i.osMutexCreate||, CODE, READONLY, ALIGN=1

                  osMutexCreate PROC
;;;553    */
;;;554    osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
000000  2001              MOVS     r0,#1
;;;555    {
;;;556    #if ( configUSE_MUTEXES == 1)
;;;557      return xSemaphoreCreateMutex(); 
000002  f7ffbffe          B.W      xQueueCreateMutex
;;;558    #else
;;;559    	return NULL;
;;;560    #endif
;;;561    }
;;;562    
                          ENDP


                          AREA ||i.osMutexDelete||, CODE, READONLY, ALIGN=1

                  osMutexDelete PROC
;;;633    */
;;;634    osStatus osMutexDelete (osMutexId mutex_id)
000000  b510              PUSH     {r4,lr}
;;;635    {
000002  4604              MOV      r4,r0
;;;636      if (inHandlerMode()) {
000004  f7fffffe          BL       inHandlerMode
000008  b108              CBZ      r0,|L20.14|
;;;637        return osErrorISR;
00000a  2082              MOVS     r0,#0x82
;;;638      }
;;;639    
;;;640      vQueueDelete(mutex_id);
;;;641    
;;;642      return osOK;
;;;643    }
00000c  bd10              POP      {r4,pc}
                  |L20.14|
00000e  4620              MOV      r0,r4                 ;640
000010  f7fffffe          BL       vQueueDelete
000014  2000              MOVS     r0,#0                 ;642
000016  bd10              POP      {r4,pc}
;;;644    
                          ENDP


                          AREA ||i.osMutexRelease||, CODE, READONLY, ALIGN=2

                  osMutexRelease PROC
;;;609    */
;;;610    osStatus osMutexRelease (osMutexId mutex_id)
000000  b538              PUSH     {r3-r5,lr}
;;;611    {
;;;612      osStatus result = osOK;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;611
;;;613      portBASE_TYPE taskWoken = pdFALSE;
;;;614      
;;;615      if (inHandlerMode()) {
000006  9400              STR      r4,[sp,#0]
000008  f7fffffe          BL       inHandlerMode
00000c  b170              CBZ      r0,|L21.44|
;;;616        if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       xQueueGiveFromISR
000016  2801              CMP      r0,#1
000018  d001              BEQ      |L21.30|
;;;617          return osErrorOS;
00001a  20ff              MOVS     r0,#0xff
;;;618        }
;;;619        portEND_SWITCHING_ISR(taskWoken);
;;;620      }
;;;621      else if (xSemaphoreGive(mutex_id) != pdTRUE) 
;;;622      {
;;;623        result = osErrorOS;
;;;624      }
;;;625      return result;
;;;626    }
00001c  bd38              POP      {r3-r5,pc}
                  |L21.30|
00001e  9800              LDR      r0,[sp,#0]            ;619
000020  b168              CBZ      r0,|L21.62|
000022  4908              LDR      r1,|L21.68|
000024  f04f5080          MOV      r0,#0x10000000        ;619
000028  6008              STR      r0,[r1,#0]            ;619
00002a  e008              B        |L21.62|
                  |L21.44|
00002c  2300              MOVS     r3,#0                 ;621
00002e  461a              MOV      r2,r3                 ;621
000030  4619              MOV      r1,r3                 ;621
000032  4628              MOV      r0,r5                 ;621
000034  f7fffffe          BL       xQueueGenericSend
000038  2801              CMP      r0,#1                 ;621
00003a  d000              BEQ      |L21.62|
00003c  24ff              MOVS     r4,#0xff              ;623
                  |L21.62|
00003e  4620              MOV      r0,r4                 ;625
000040  bd38              POP      {r3-r5,pc}
;;;627    
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
                          DCD      0xe000ed04

                          AREA ||i.osMutexWait||, CODE, READONLY, ALIGN=2

                  osMutexWait PROC
;;;569    */
;;;570    osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
000000  b538              PUSH     {r3-r5,lr}
;;;571    {
000002  0005              MOVS     r5,r0
;;;572      TickType_t ticks;
;;;573      portBASE_TYPE taskWoken = pdFALSE;  
000004  f04f0000          MOV      r0,#0
000008  9000              STR      r0,[sp,#0]            ;571
00000a  d00f              BEQ      |L22.44|
;;;574      
;;;575      
;;;576      if (mutex_id == NULL) {
;;;577        return osErrorParameter;
;;;578      }
;;;579      
;;;580      ticks = 0;
00000c  2400              MOVS     r4,#0
;;;581      if (millisec == osWaitForever) {
00000e  1c48              ADDS     r0,r1,#1
000010  d00e              BEQ      |L22.48|
;;;582        ticks = portMAX_DELAY;
;;;583      }
;;;584      else if (millisec != 0) {
000012  b101              CBZ      r1,|L22.22|
;;;585        ticks = millisec / portTICK_PERIOD_MS;
000014  460c              MOV      r4,r1
                  |L22.22|
;;;586        if (ticks == 0) {
;;;587          ticks = 1;
;;;588        }
;;;589      }
;;;590      
;;;591      if (inHandlerMode()) {
000016  f7fffffe          BL       inHandlerMode
00001a  b198              CBZ      r0,|L22.68|
;;;592        if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
00001c  466a              MOV      r2,sp
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       xQueueReceiveFromISR
000026  2801              CMP      r0,#1
000028  d114              BNE      |L22.84|
00002a  e004              B        |L22.54|
                  |L22.44|
00002c  2080              MOVS     r0,#0x80              ;577
;;;593          return osErrorOS;
;;;594        }
;;;595    	portEND_SWITCHING_ISR(taskWoken);
;;;596      } 
;;;597      else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
;;;598        return osErrorOS;
;;;599      }
;;;600      
;;;601      return osOK;
;;;602    }
00002e  bd38              POP      {r3-r5,pc}
                  |L22.48|
000030  f04f34ff          MOV      r4,#0xffffffff        ;582
000034  e7ef              B        |L22.22|
                  |L22.54|
000036  9800              LDR      r0,[sp,#0]            ;595
000038  b170              CBZ      r0,|L22.88|
00003a  4908              LDR      r1,|L22.92|
00003c  f04f5080          MOV      r0,#0x10000000        ;595
000040  6008              STR      r0,[r1,#0]            ;595
000042  e009              B        |L22.88|
                  |L22.68|
000044  2300              MOVS     r3,#0                 ;597
000046  4622              MOV      r2,r4                 ;597
000048  4619              MOV      r1,r3                 ;597
00004a  4628              MOV      r0,r5                 ;597
00004c  f7fffffe          BL       xQueueGenericReceive
000050  2801              CMP      r0,#1                 ;597
000052  d001              BEQ      |L22.88|
                  |L22.84|
000054  20ff              MOVS     r0,#0xff              ;598
000056  bd38              POP      {r3-r5,pc}
                  |L22.88|
000058  2000              MOVS     r0,#0                 ;601
00005a  bd38              POP      {r3-r5,pc}
;;;603    
                          ENDP

                  |L22.92|
                          DCD      0xe000ed04

                          AREA ||i.osPoolAlloc||, CODE, READONLY, ALIGN=2

                  osPoolAlloc PROC
;;;828    */
;;;829    void *osPoolAlloc (osPoolId pool_id)
000000  b570              PUSH     {r4-r6,lr}
;;;830    {
;;;831      int dummy = 0;
000002  2600              MOVS     r6,#0
000004  4604              MOV      r4,r0                 ;830
;;;832      void *p = NULL;
000006  4635              MOV      r5,r6
;;;833      uint32_t i;
;;;834      uint32_t index;
;;;835      
;;;836      if (inHandlerMode()) {
000008  f7fffffe          BL       inHandlerMode
00000c  b118              CBZ      r0,|L23.22|
;;;837        dummy = portSET_INTERRUPT_MASK_FROM_ISR();
00000e  f7fffffe          BL       ulPortSetInterruptMask
000012  4606              MOV      r6,r0
000014  e001              B        |L23.26|
                  |L23.22|
;;;838      }
;;;839      else {
;;;840        vPortEnterCritical();
000016  f7fffffe          BL       vPortEnterCritical
                  |L23.26|
;;;841      }
;;;842      
;;;843      for (i = 0; i < pool_id->pool_sz; i++) {
00001a  2100              MOVS     r1,#0
00001c  68a2              LDR      r2,[r4,#8]
00001e  e008              B        |L23.50|
                  |L23.32|
;;;844        index = pool_id->currentIndex + i;
000020  6920              LDR      r0,[r4,#0x10]
000022  4408              ADD      r0,r0,r1
;;;845        if (index >= pool_id->pool_sz) {
000024  4282              CMP      r2,r0
000026  d800              BHI      |L23.42|
;;;846          index = 0;
000028  2000              MOVS     r0,#0
                  |L23.42|
;;;847        }
;;;848        
;;;849        if (pool_id->markers[index] == 0) {
00002a  6863              LDR      r3,[r4,#4]
00002c  5c1b              LDRB     r3,[r3,r0]
00002e  b153              CBZ      r3,|L23.70|
000030  1c49              ADDS     r1,r1,#1
                  |L23.50|
000032  428a              CMP      r2,r1                 ;843
000034  d8f4              BHI      |L23.32|
;;;850          pool_id->markers[index] = 1;
;;;851          p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
;;;852          pool_id->currentIndex = index;
;;;853          break;
;;;854        }
;;;855      }
;;;856      
;;;857      if (inHandlerMode()) {
000036  bf00              NOP      
                  |L23.56|
000038  f7fffffe          BL       inHandlerMode
00003c  b160              CBZ      r0,|L23.88|
;;;858        portCLEAR_INTERRUPT_MASK_FROM_ISR(dummy);
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       vPortClearInterruptMask
000044  e00a              B        |L23.92|
                  |L23.70|
000046  6862              LDR      r2,[r4,#4]            ;850
000048  2101              MOVS     r1,#1                 ;850
00004a  5411              STRB     r1,[r2,r0]            ;850
00004c  68e2              LDR      r2,[r4,#0xc]          ;851
00004e  6821              LDR      r1,[r4,#0]            ;851
000050  6120              STR      r0,[r4,#0x10]         ;853
000052  fb001502          MLA      r5,r0,r2,r1           ;851
000056  e7ef              B        |L23.56|
                  |L23.88|
;;;859      }
;;;860      else {
;;;861        vPortExitCritical();
000058  f7fffffe          BL       vPortExitCritical
                  |L23.92|
;;;862      }
;;;863      
;;;864      return p;
00005c  4628              MOV      r0,r5
;;;865    }
00005e  bd70              POP      {r4-r6,pc}
;;;866    
                          ENDP


                          AREA ||i.osPoolCAlloc||, CODE, READONLY, ALIGN=1

                  osPoolCAlloc PROC
;;;872    */
;;;873    void *osPoolCAlloc (osPoolId pool_id)
000000  b510              PUSH     {r4,lr}
;;;874    {
;;;875      void *p = osPoolAlloc(pool_id);
000002  f7fffffe          BL       osPoolAlloc
;;;876      
;;;877      if (p != NULL)
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L24.14|
;;;878      {
;;;879        memset(p, 0, sizeof(pool_id->pool_sz));
00000a  2100              MOVS     r1,#0
00000c  6001              STR      r1,[r0,#0]
                  |L24.14|
;;;880      }
;;;881      
;;;882      return p;
;;;883    }
00000e  bd10              POP      {r4,pc}
;;;884    
                          ENDP


                          AREA ||i.osPoolCreate||, CODE, READONLY, ALIGN=1

                  osPoolCreate PROC
;;;783    */
;;;784    osPoolId osPoolCreate (const osPoolDef_t *pool_def)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;785    {
000004  4605              MOV      r5,r0
;;;786      osPoolId thePool;
;;;787      int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
000006  6840              LDR      r0,[r0,#4]
000008  1cc0              ADDS     r0,r0,#3
00000a  f0200703          BIC      r7,r0,#3
;;;788      uint32_t i;
;;;789      
;;;790      /* First have to allocate memory for the pool control block. */
;;;791      thePool = pvPortMalloc(sizeof(os_pool_cb_t));
00000e  2014              MOVS     r0,#0x14
000010  f7fffffe          BL       pvPortMalloc
000014  0004              MOVS     r4,r0
;;;792      if (thePool) {
000016  d01f              BEQ      |L25.88|
;;;793        thePool->pool_sz = pool_def->pool_sz;
;;;794        thePool->item_sz = itemSize;
;;;795        thePool->currentIndex = 0;
000018  2600              MOVS     r6,#0
00001a  6828              LDR      r0,[r5,#0]
00001c  6126              STR      r6,[r4,#0x10]
00001e  e9c40702          STRD     r0,r7,[r4,#8]
;;;796        
;;;797        /* Memory for markers */
;;;798        thePool->markers = pvPortMalloc(pool_def->pool_sz);
000022  6828              LDR      r0,[r5,#0]
000024  f7fffffe          BL       pvPortMalloc
;;;799        if (thePool->markers) {
000028  6060              STR      r0,[r4,#4]
00002a  b188              CBZ      r0,|L25.80|
;;;800          /* Now allocate the pool itself. */
;;;801          thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
00002c  6828              LDR      r0,[r5,#0]
00002e  4378              MULS     r0,r7,r0
000030  f7fffffe          BL       pvPortMalloc
;;;802          
;;;803          if (thePool->pool) {
000034  6020              STR      r0,[r4,#0]
000036  b140              CBZ      r0,|L25.74|
;;;804            for (i = 0; i < pool_def->pool_sz; i++) {
000038  2000              MOVS     r0,#0
00003a  e002              B        |L25.66|
                  |L25.60|
;;;805              thePool->markers[i] = 0;
00003c  6861              LDR      r1,[r4,#4]
00003e  540e              STRB     r6,[r1,r0]
000040  1c40              ADDS     r0,r0,#1
                  |L25.66|
000042  6829              LDR      r1,[r5,#0]            ;804
000044  4281              CMP      r1,r0                 ;804
000046  d8f9              BHI      |L25.60|
000048  e006              B        |L25.88|
                  |L25.74|
;;;806            }
;;;807          }
;;;808          else {
;;;809            vPortFree(thePool->markers);
00004a  6860              LDR      r0,[r4,#4]
00004c  f7fffffe          BL       vPortFree
                  |L25.80|
;;;810            vPortFree(thePool);
;;;811            thePool = NULL;
;;;812          }
;;;813        }
;;;814        else {
;;;815          vPortFree(thePool);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       vPortFree
;;;816          thePool = NULL;
000056  2400              MOVS     r4,#0
                  |L25.88|
;;;817        }
;;;818      }
;;;819      
;;;820      return thePool;
000058  4620              MOV      r0,r4
;;;821    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;822    
                          ENDP


                          AREA ||i.osPoolFree||, CODE, READONLY, ALIGN=1

                  osPoolFree PROC
;;;891    */
;;;892    osStatus osPoolFree (osPoolId pool_id, void *block)
000000  b178              CBZ      r0,|L26.34|
;;;893    {
;;;894      uint32_t index;
;;;895      
;;;896      if (pool_id == NULL) {
;;;897        return osErrorParameter;
;;;898      }
;;;899      
;;;900      if (block == NULL) {
000002  b171              CBZ      r1,|L26.34|
;;;901        return osErrorParameter;
;;;902      }
;;;903      
;;;904      if (block < pool_id->pool) {
000004  6802              LDR      r2,[r0,#0]
000006  428a              CMP      r2,r1
000008  d80b              BHI      |L26.34|
;;;905        return osErrorParameter;
;;;906      }
;;;907      
;;;908      index = (uint32_t)block - (uint32_t)(pool_id->pool);
00000a  1a89              SUBS     r1,r1,r2
;;;909      if (index % pool_id->item_sz) {
00000c  68c2              LDR      r2,[r0,#0xc]
00000e  fbb1f3f2          UDIV     r3,r1,r2
000012  fb021313          MLS      r3,r2,r3,r1
000016  b923              CBNZ     r3,|L26.34|
;;;910        return osErrorParameter;
;;;911      }
;;;912      index = index / pool_id->item_sz;
000018  fbb1f1f2          UDIV     r1,r1,r2
;;;913      if (index >= pool_id->pool_sz) {
00001c  6882              LDR      r2,[r0,#8]
00001e  428a              CMP      r2,r1
000020  d801              BHI      |L26.38|
                  |L26.34|
;;;914        return osErrorParameter;
000022  2080              MOVS     r0,#0x80
;;;915      }
;;;916      
;;;917      pool_id->markers[index] = 0;
;;;918      
;;;919      return osOK;
;;;920    }
000024  4770              BX       lr
                  |L26.38|
000026  6840              LDR      r0,[r0,#4]            ;917
000028  2200              MOVS     r2,#0                 ;917
00002a  5442              STRB     r2,[r0,r1]            ;917
00002c  4610              MOV      r0,r2                 ;919
00002e  4770              BX       lr
;;;921    
                          ENDP


                          AREA ||i.osRecursiveMutexCreate||, CODE, READONLY, ALIGN=1

                  osRecursiveMutexCreate PROC
;;;1453   */
;;;1454   osMutexId osRecursiveMutexCreate (const osMutexDef_t *mutex_def)
000000  2000              MOVS     r0,#0
;;;1455   {
;;;1456     (void) mutex_def;
;;;1457   #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1458     return xSemaphoreCreateRecursiveMutex();
;;;1459   #else
;;;1460     return NULL;
;;;1461   #endif	
;;;1462   }
000002  4770              BX       lr
;;;1463   
                          ENDP


                          AREA ||i.osRecursiveMutexRelease||, CODE, READONLY, ALIGN=1

                  osRecursiveMutexRelease PROC
;;;1468   */
;;;1469   osStatus osRecursiveMutexRelease (osMutexId mutex_id)
000000  2081              MOVS     r0,#0x81
;;;1470   {
;;;1471   #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1472     osStatus result = osOK;
;;;1473    
;;;1474     if (xSemaphoreGiveRecursive(mutex_id) != pdTRUE) 
;;;1475     {
;;;1476       result = osErrorOS;
;;;1477     }
;;;1478     return result;
;;;1479   #else
;;;1480   	return osErrorResource;
;;;1481   #endif
;;;1482   }
000002  4770              BX       lr
;;;1483   
                          ENDP


                          AREA ||i.osRecursiveMutexWait||, CODE, READONLY, ALIGN=1

                  osRecursiveMutexWait PROC
;;;1489   */
;;;1490   osStatus osRecursiveMutexWait (osMutexId mutex_id, uint32_t millisec)
000000  2081              MOVS     r0,#0x81
;;;1491   {
;;;1492   #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1493     TickType_t ticks;
;;;1494     
;;;1495     if (mutex_id == NULL)
;;;1496     {
;;;1497       return osErrorParameter;
;;;1498     }
;;;1499     
;;;1500     ticks = 0;
;;;1501     if (millisec == osWaitForever) 
;;;1502     {
;;;1503       ticks = portMAX_DELAY;
;;;1504     }
;;;1505     else if (millisec != 0) 
;;;1506     {
;;;1507       ticks = millisec / portTICK_PERIOD_MS;
;;;1508       if (ticks == 0) 
;;;1509       {
;;;1510         ticks = 1;
;;;1511       }
;;;1512     }
;;;1513     
;;;1514     if (xSemaphoreTakeRecursive(mutex_id, ticks) != pdTRUE) 
;;;1515     {
;;;1516       return osErrorOS;
;;;1517     }
;;;1518     return osOK;
;;;1519   #else
;;;1520   	return osErrorResource;
;;;1521   #endif
;;;1522   }
000002  4770              BX       lr
                          ENDP


                          AREA ||i.osSemaphoreCreate||, CODE, READONLY, ALIGN=1

                  osSemaphoreCreate PROC
;;;655    */
;;;656    osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
000000  b510              PUSH     {r4,lr}
;;;657    {
;;;658      (void) semaphore_def;
;;;659      osSemaphoreId sema;
;;;660      
;;;661      if (count == 1) {
000002  2901              CMP      r1,#1
000004  d001              BEQ      |L30.10|
;;;662        vSemaphoreCreateBinary(sema);
;;;663        return sema;
;;;664      }
;;;665    
;;;666    #if (configUSE_COUNTING_SEMAPHORES == 1 )	
;;;667      return xSemaphoreCreateCounting(count, 0);
;;;668    #else
;;;669      return NULL;
000006  2000              MOVS     r0,#0
;;;670    #endif
;;;671    }
000008  bd10              POP      {r4,pc}
                  |L30.10|
00000a  2203              MOVS     r2,#3                 ;662
00000c  2100              MOVS     r1,#0                 ;662
00000e  2001              MOVS     r0,#1                 ;662
000010  f7fffffe          BL       xQueueGenericCreate
000014  0004              MOVS     r4,r0                 ;662
000016  d004              BEQ      |L30.34|
000018  2300              MOVS     r3,#0                 ;662
00001a  461a              MOV      r2,r3                 ;662
00001c  4619              MOV      r1,r3                 ;662
00001e  f7fffffe          BL       xQueueGenericSend
                  |L30.34|
000022  4620              MOV      r0,r4                 ;663
000024  bd10              POP      {r4,pc}
;;;672    
                          ENDP


                          AREA ||i.osSemaphoreDelete||, CODE, READONLY, ALIGN=1

                  osSemaphoreDelete PROC
;;;746    */
;;;747    osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
000000  b510              PUSH     {r4,lr}
;;;748    {
000002  4604              MOV      r4,r0
;;;749      if (inHandlerMode()) {
000004  f7fffffe          BL       inHandlerMode
000008  b108              CBZ      r0,|L31.14|
;;;750        return osErrorISR;
00000a  2082              MOVS     r0,#0x82
;;;751      }
;;;752    
;;;753      vSemaphoreDelete(semaphore_id);
;;;754    
;;;755      return osOK; 
;;;756    }
00000c  bd10              POP      {r4,pc}
                  |L31.14|
00000e  4620              MOV      r0,r4                 ;753
000010  f7fffffe          BL       vQueueDelete
000014  2000              MOVS     r0,#0                 ;755
000016  bd10              POP      {r4,pc}
;;;757    
                          ENDP


                          AREA ||i.osSemaphoreRelease||, CODE, READONLY, ALIGN=2

                  osSemaphoreRelease PROC
;;;719    */
;;;720    osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
000000  b538              PUSH     {r3-r5,lr}
;;;721    {
;;;722      osStatus result = osOK;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;721
;;;723      portBASE_TYPE taskWoken = pdFALSE;
;;;724      
;;;725      
;;;726      if (inHandlerMode()) {
000006  9400              STR      r4,[sp,#0]
000008  f7fffffe          BL       inHandlerMode
00000c  b170              CBZ      r0,|L32.44|
;;;727        if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       xQueueGiveFromISR
000016  2801              CMP      r0,#1
000018  d001              BEQ      |L32.30|
;;;728          return osErrorOS;
00001a  20ff              MOVS     r0,#0xff
;;;729        }
;;;730        portEND_SWITCHING_ISR(taskWoken);
;;;731      }
;;;732      else {
;;;733        if (xSemaphoreGive(semaphore_id) != pdTRUE) {
;;;734          result = osErrorOS;
;;;735        }
;;;736      }
;;;737      
;;;738      return result;
;;;739    }
00001c  bd38              POP      {r3-r5,pc}
                  |L32.30|
00001e  9800              LDR      r0,[sp,#0]            ;730
000020  b168              CBZ      r0,|L32.62|
000022  4908              LDR      r1,|L32.68|
000024  f04f5080          MOV      r0,#0x10000000        ;730
000028  6008              STR      r0,[r1,#0]            ;730
00002a  e008              B        |L32.62|
                  |L32.44|
00002c  2300              MOVS     r3,#0                 ;733
00002e  461a              MOV      r2,r3                 ;733
000030  4619              MOV      r1,r3                 ;733
000032  4628              MOV      r0,r5                 ;733
000034  f7fffffe          BL       xQueueGenericSend
000038  2801              CMP      r0,#1                 ;733
00003a  d000              BEQ      |L32.62|
00003c  24ff              MOVS     r4,#0xff              ;734
                  |L32.62|
00003e  4620              MOV      r0,r4                 ;738
000040  bd38              POP      {r3-r5,pc}
;;;740    
                          ENDP

000042  0000              DCW      0x0000
                  |L32.68|
                          DCD      0xe000ed04

                          AREA ||i.osSemaphoreWait||, CODE, READONLY, ALIGN=2

                  osSemaphoreWait PROC
;;;679    */
;;;680    int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
000000  b538              PUSH     {r3-r5,lr}
;;;681    {
000002  0005              MOVS     r5,r0
;;;682      TickType_t ticks;
;;;683      portBASE_TYPE taskWoken = pdFALSE;  
000004  f04f0000          MOV      r0,#0
000008  9000              STR      r0,[sp,#0]            ;681
00000a  d00f              BEQ      |L33.44|
;;;684      
;;;685      
;;;686      if (semaphore_id == NULL) {
;;;687        return osErrorParameter;
;;;688      }
;;;689      
;;;690      ticks = 0;
00000c  2400              MOVS     r4,#0
;;;691      if (millisec == osWaitForever) {
00000e  1c48              ADDS     r0,r1,#1
000010  d00e              BEQ      |L33.48|
;;;692        ticks = portMAX_DELAY;
;;;693      }
;;;694      else if (millisec != 0) {
000012  b101              CBZ      r1,|L33.22|
;;;695        ticks = millisec / portTICK_PERIOD_MS;
000014  460c              MOV      r4,r1
                  |L33.22|
;;;696        if (ticks == 0) {
;;;697          ticks = 1;
;;;698        }
;;;699      }
;;;700      
;;;701      if (inHandlerMode()) {
000016  f7fffffe          BL       inHandlerMode
00001a  b198              CBZ      r0,|L33.68|
;;;702        if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
00001c  466a              MOV      r2,sp
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       xQueueReceiveFromISR
000026  2801              CMP      r0,#1
000028  d114              BNE      |L33.84|
00002a  e004              B        |L33.54|
                  |L33.44|
00002c  2080              MOVS     r0,#0x80              ;687
;;;703          return osErrorOS;
;;;704        }
;;;705    	portEND_SWITCHING_ISR(taskWoken);
;;;706      }  
;;;707      else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
;;;708        return osErrorOS;
;;;709      }
;;;710      
;;;711      return osOK;
;;;712    }
00002e  bd38              POP      {r3-r5,pc}
                  |L33.48|
000030  f04f34ff          MOV      r4,#0xffffffff        ;692
000034  e7ef              B        |L33.22|
                  |L33.54|
000036  9800              LDR      r0,[sp,#0]            ;705
000038  b170              CBZ      r0,|L33.88|
00003a  4908              LDR      r1,|L33.92|
00003c  f04f5080          MOV      r0,#0x10000000        ;705
000040  6008              STR      r0,[r1,#0]            ;705
000042  e009              B        |L33.88|
                  |L33.68|
000044  2300              MOVS     r3,#0                 ;707
000046  4622              MOV      r2,r4                 ;707
000048  4619              MOV      r1,r3                 ;707
00004a  4628              MOV      r0,r5                 ;707
00004c  f7fffffe          BL       xQueueGenericReceive
000050  2801              CMP      r0,#1                 ;707
000052  d001              BEQ      |L33.88|
                  |L33.84|
000054  20ff              MOVS     r0,#0xff              ;708
000056  bd38              POP      {r3-r5,pc}
                  |L33.88|
000058  2000              MOVS     r0,#0                 ;711
00005a  bd38              POP      {r3-r5,pc}
;;;713    
                          ENDP

                  |L33.92|
                          DCD      0xe000ed04

                          AREA ||i.osSignalSet||, CODE, READONLY, ALIGN=2

                  osSignalSet PROC
;;;457    */
;;;458    int32_t osSignalSet (osThreadId thread_id, int32_t signal)
000000  b57c              PUSH     {r2-r6,lr}
;;;459    {
000002  4605              MOV      r5,r0
;;;460    #if( configUSE_TASK_NOTIFICATIONS == 1 )	
;;;461      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
000004  2000              MOVS     r0,#0
000006  460c              MOV      r4,r1                 ;459
;;;462      
;;;463      if (inHandlerMode())
000008  9001              STR      r0,[sp,#4]
00000a  f7fffffe          BL       inHandlerMode
00000e  b180              CBZ      r0,|L34.50|
;;;464      {
;;;465        if(xTaskNotifyFromISR( thread_id, (uint32_t)signal, eSetBits, &xHigherPriorityTaskWoken ) != pdPASS )
000010  a801              ADD      r0,sp,#4
000012  9000              STR      r0,[sp,#0]
000014  2300              MOVS     r3,#0
000016  2201              MOVS     r2,#1
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       xTaskGenericNotifyFromISR
000020  2801              CMP      r0,#1
000022  d10e              BNE      |L34.66|
;;;466          return osErrorOS;
;;;467    
;;;468        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
000024  9801              LDR      r0,[sp,#4]
000026  b170              CBZ      r0,|L34.70|
000028  4908              LDR      r1,|L34.76|
00002a  f04f5080          MOV      r0,#0x10000000
00002e  6008              STR      r0,[r1,#0]
000030  e009              B        |L34.70|
                  |L34.50|
;;;469      }  
;;;470      else if(xTaskNotify( thread_id, (uint32_t)signal, eSetBits) != pdPASS )
000032  2300              MOVS     r3,#0
000034  2201              MOVS     r2,#1
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       xTaskGenericNotify
00003e  2801              CMP      r0,#1
000040  d001              BEQ      |L34.70|
                  |L34.66|
;;;471      {
;;;472        return osErrorOS;
000042  20ff              MOVS     r0,#0xff
;;;473      }
;;;474      
;;;475      return osOK;
;;;476    #else
;;;477      (void) thread_id;
;;;478      (void) signal;
;;;479    
;;;480      return osErrorOS; /* Task Notification not supported */ 	
;;;481    #endif
;;;482    }
000044  bd7c              POP      {r2-r6,pc}
                  |L34.70|
000046  2000              MOVS     r0,#0                 ;475
000048  bd7c              POP      {r2-r6,pc}
;;;483    
                          ENDP

00004a  0000              DCW      0x0000
                  |L34.76|
                          DCD      0xe000ed04

                          AREA ||i.osSignalWait||, CODE, READONLY, ALIGN=1

                  osSignalWait PROC
;;;499    */
;;;500    osEvent osSignalWait (int32_t signals, uint32_t millisec)
000000  b5fe              PUSH     {r1-r7,lr}
;;;501    {
;;;502      osEvent ret;
;;;503    
;;;504    #if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;505    	
;;;506      TickType_t ticks;
;;;507    
;;;508      ret.value.signals = 0;  
000002  2500              MOVS     r5,#0
000004  4606              MOV      r6,r0                 ;501
000006  460f              MOV      r7,r1                 ;501
;;;509      ticks = 0;
000008  462c              MOV      r4,r5
;;;510      if (millisec == osWaitForever) {
00000a  9501              STR      r5,[sp,#4]
00000c  1c50              ADDS     r0,r2,#1
00000e  d006              BEQ      |L35.30|
;;;511        ticks = portMAX_DELAY;
;;;512      }
;;;513      else if (millisec != 0) {
000010  b102              CBZ      r2,|L35.20|
;;;514        ticks = millisec / portTICK_PERIOD_MS;
000012  4614              MOV      r4,r2
                  |L35.20|
;;;515        if (ticks == 0) {
;;;516          ticks = 1;
;;;517        }
;;;518      }  
;;;519      
;;;520      if (inHandlerMode())
000014  f7fffffe          BL       inHandlerMode
000018  b120              CBZ      r0,|L35.36|
;;;521      {
;;;522        ret.status = osErrorISR;  /*Not allowed in ISR*/
00001a  2082              MOVS     r0,#0x82
00001c  e015              B        |L35.74|
                  |L35.30|
00001e  f04f34ff          MOV      r4,#0xffffffff        ;511
000022  e7f7              B        |L35.20|
                  |L35.36|
;;;523      }
;;;524      else
;;;525      {
;;;526        if(xTaskNotifyWait( 0,(uint32_t) signals, (uint32_t *)&ret.value.signals, ticks) != pdTRUE)
000024  4623              MOV      r3,r4
000026  4639              MOV      r1,r7
000028  2000              MOVS     r0,#0
00002a  aa01              ADD      r2,sp,#4
00002c  f7fffffe          BL       xTaskNotifyWait
000030  2801              CMP      r0,#1
000032  d004              BEQ      |L35.62|
;;;527        {
;;;528          if(ticks == 0)  ret.status = osOK;
000034  b10c              CBZ      r4,|L35.58|
;;;529          else  ret.status = osEventTimeout;
000036  2040              MOVS     r0,#0x40
000038  e007              B        |L35.74|
                  |L35.58|
00003a  9500              STR      r5,[sp,#0]            ;528
00003c  e006              B        |L35.76|
                  |L35.62|
;;;530        }
;;;531        else if(ret.value.signals < 0)
00003e  9801              LDR      r0,[sp,#4]
000040  2800              CMP      r0,#0
000042  da01              BGE      |L35.72|
;;;532        {
;;;533          ret.status =  osErrorValue;     
000044  2086              MOVS     r0,#0x86
000046  e000              B        |L35.74|
                  |L35.72|
;;;534        }
;;;535        else  ret.status =  osEventSignal;
000048  2008              MOVS     r0,#8
                  |L35.74|
00004a  9000              STR      r0,[sp,#0]            ;533
                  |L35.76|
00004c  e89d0007          LDM      sp,{r0-r2}            ;533
000050  e8860007          STM      r6,{r0-r2}            ;533
;;;536      }
;;;537    #else
;;;538      (void) signals;
;;;539      (void) millisec;
;;;540    	
;;;541      ret.status =  osErrorOS;	/* Task Notification not supported */
;;;542    #endif
;;;543      
;;;544      return ret;
;;;545    }
000054  bdfe              POP      {r1-r7,pc}
;;;546    
                          ENDP


                          AREA ||i.osSystickHandler||, CODE, READONLY, ALIGN=1

                  osSystickHandler PROC
;;;1238   */
;;;1239   void osSystickHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1240   {
;;;1241   
;;;1242   #if (INCLUDE_xTaskGetSchedulerState  == 1 )
;;;1243     if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d003              BEQ      |L36.18|
;;;1244     {
;;;1245   #endif  /* INCLUDE_xTaskGetSchedulerState */  
;;;1246       xPortSysTickHandler();
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      xPortSysTickHandler
                  |L36.18|
;;;1247   #if (INCLUDE_xTaskGetSchedulerState  == 1 )
;;;1248     }
;;;1249   #endif  /* INCLUDE_xTaskGetSchedulerState */  
;;;1250   }
000012  bd10              POP      {r4,pc}
;;;1251   
                          ENDP


                          AREA ||i.osThreadCreate||, CODE, READONLY, ALIGN=1

                  osThreadCreate PROC
;;;203    */
;;;204    osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
000000  b530              PUSH     {r4,r5,lr}
;;;205    {
000002  4604              MOV      r4,r0
000004  b085              SUB      sp,sp,#0x14
000006  460d              MOV      r5,r1
;;;206      TaskHandle_t handle;
;;;207      
;;;208      
;;;209      if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
000008  f9b00008          LDRSH    r0,[r0,#8]
00000c  f7fffffe          BL       makeFreeRtosPriority
000010  2100              MOVS     r1,#0
000012  aa04              ADD      r2,sp,#0x10
000014  9000              STR      r0,[sp,#0]
000016  e9cd2101          STRD     r2,r1,[sp,#4]
00001a  9103              STR      r1,[sp,#0xc]
00001c  8a20              LDRH     r0,[r4,#0x10]
00001e  462b              MOV      r3,r5
000020  b282              UXTH     r2,r0
000022  e9d41000          LDRD     r1,r0,[r4,#0]
000026  f7fffffe          BL       xTaskGenericCreate
00002a  2801              CMP      r0,#1
00002c  d002              BEQ      |L37.52|
;;;210                  thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
;;;211                  &handle) != pdPASS)  {
;;;212        return NULL;
00002e  2000              MOVS     r0,#0
                  |L37.48|
;;;213      }
;;;214      
;;;215      return handle;
;;;216    }
000030  b005              ADD      sp,sp,#0x14
000032  bd30              POP      {r4,r5,pc}
                  |L37.52|
000034  9804              LDR      r0,[sp,#0x10]         ;215
000036  e7fb              B        |L37.48|
;;;217    
                          ENDP


                          AREA ||i.osThreadGetId||, CODE, READONLY, ALIGN=1

                  osThreadGetId PROC
;;;222    */
;;;223    osThreadId osThreadGetId (void)
000000  f7ffbffe          B.W      xTaskGetCurrentTaskHandle
;;;224    {
;;;225    #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
;;;226      return xTaskGetCurrentTaskHandle();
;;;227    #else
;;;228    	return NULL;
;;;229    #endif
;;;230    }
;;;231    
                          ENDP


                          AREA ||i.osThreadGetPriority||, CODE, READONLY, ALIGN=1

                  osThreadGetPriority PROC
;;;282    */
;;;283    osPriority osThreadGetPriority (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;284    {
000002  4604              MOV      r4,r0
;;;285    #if (INCLUDE_uxTaskPriorityGet == 1)
;;;286      if (inHandlerMode())
000004  f7fffffe          BL       inHandlerMode
000008  2800              CMP      r0,#0
;;;287      {
;;;288        return makeCmsisPriority(uxTaskPriorityGetFromISR(thread_id));  
;;;289      }
;;;290      else
;;;291      {  
;;;292        return makeCmsisPriority(uxTaskPriorityGet(thread_id));
00000a  4620              MOV      r0,r4
00000c  d002              BEQ      |L39.20|
00000e  f7fffffe          BL       uxTaskPriorityGetFromISR
000012  e001              B        |L39.24|
                  |L39.20|
000014  f7fffffe          BL       uxTaskPriorityGet
                  |L39.24|
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      makeCmsisPriority
;;;293      }
;;;294    #else
;;;295      return osPriorityError;
;;;296    #endif
;;;297    }
;;;298    
                          ENDP


                          AREA ||i.osThreadList||, CODE, READONLY, ALIGN=1

                  osThreadList PROC
;;;1398   */
;;;1399   osStatus osThreadList (uint8_t *buffer)
000000  2000              MOVS     r0,#0
;;;1400   {
;;;1401   #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
;;;1402     vTaskList((char *)buffer);
;;;1403   #endif
;;;1404     return osOK;
;;;1405   }
000002  4770              BX       lr
;;;1406   
                          ENDP


                          AREA ||i.osThreadResume||, CODE, READONLY, ALIGN=2

                  osThreadResume PROC
;;;1324   */
;;;1325   osStatus osThreadResume (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;1326   {
000002  4604              MOV      r4,r0
;;;1327   #if (INCLUDE_vTaskSuspend == 1)  
;;;1328     if(inHandlerMode())
000004  f7fffffe          BL       inHandlerMode
000008  2800              CMP      r0,#0
;;;1329     {
;;;1330       if (xTaskResumeFromISR(thread_id) == pdTRUE)
;;;1331       {
;;;1332         portYIELD_FROM_ISR(pdTRUE);
;;;1333       }
;;;1334     }
;;;1335     else
;;;1336     {
;;;1337       vTaskResume(thread_id);
00000a  4620              MOV      r0,r4
00000c  d007              BEQ      |L41.30|
00000e  f7fffffe          BL       xTaskResumeFromISR
000012  2801              CMP      r0,#1                 ;1330
000014  d105              BNE      |L41.34|
000016  4904              LDR      r1,|L41.40|
000018  0700              LSLS     r0,r0,#28             ;1332
00001a  6008              STR      r0,[r1,#0]            ;1332
00001c  e001              B        |L41.34|
                  |L41.30|
00001e  f7fffffe          BL       vTaskResume
                  |L41.34|
;;;1338     }
;;;1339     return osOK;
000022  2000              MOVS     r0,#0
;;;1340   #else
;;;1341     return osErrorResource;
;;;1342   #endif
;;;1343   }
000024  bd10              POP      {r4,pc}
;;;1344   
                          ENDP

000026  0000              DCW      0x0000
                  |L41.40|
                          DCD      0xe000ed04

                          AREA ||i.osThreadResumeAll||, CODE, READONLY, ALIGN=1

                  osThreadResumeAll PROC
;;;1359   */
;;;1360   osStatus osThreadResumeAll (void)
000000  b510              PUSH     {r4,lr}
;;;1361   {
;;;1362     if (xTaskResumeAll() == pdTRUE)
000002  f7fffffe          BL       xTaskResumeAll
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L42.14|
;;;1363       return osOK;
;;;1364     else
;;;1365       return osErrorOS;
00000a  20ff              MOVS     r0,#0xff
;;;1366     
;;;1367   }
00000c  bd10              POP      {r4,pc}
                  |L42.14|
00000e  2000              MOVS     r0,#0                 ;1363
000010  bd10              POP      {r4,pc}
;;;1368   
                          ENDP


                          AREA ||i.osThreadSetPriority||, CODE, READONLY, ALIGN=1

                  osThreadSetPriority PROC
;;;266    */
;;;267    osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority)
000000  b510              PUSH     {r4,lr}
;;;268    {
000002  4604              MOV      r4,r0
;;;269    #if (INCLUDE_vTaskPrioritySet == 1)
;;;270      vTaskPrioritySet(thread_id, makeFreeRtosPriority(priority));
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       makeFreeRtosPriority
00000a  4601              MOV      r1,r0
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       vTaskPrioritySet
;;;271      return osOK;
000012  2000              MOVS     r0,#0
;;;272    #else
;;;273      return osErrorOS;
;;;274    #endif
;;;275    }
000014  bd10              POP      {r4,pc}
;;;276    
                          ENDP


                          AREA ||i.osThreadSuspend||, CODE, READONLY, ALIGN=1

                  osThreadSuspend PROC
;;;1308   */
;;;1309   osStatus osThreadSuspend (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;1310   {
;;;1311   #if (INCLUDE_vTaskSuspend == 1)
;;;1312       vTaskSuspend(thread_id);
000002  f7fffffe          BL       vTaskSuspend
;;;1313     
;;;1314     return osOK;
000006  2000              MOVS     r0,#0
;;;1315   #else
;;;1316     return osErrorResource;
;;;1317   #endif
;;;1318   }
000008  bd10              POP      {r4,pc}
;;;1319   
                          ENDP


                          AREA ||i.osThreadSuspendAll||, CODE, READONLY, ALIGN=1

                  osThreadSuspendAll PROC
;;;1348   */
;;;1349   osStatus osThreadSuspendAll (void)
000000  b510              PUSH     {r4,lr}
;;;1350   {
;;;1351     vTaskSuspendAll();
000002  f7fffffe          BL       vTaskSuspendAll
;;;1352     
;;;1353     return osOK;
000006  2000              MOVS     r0,#0
;;;1354   }
000008  bd10              POP      {r4,pc}
;;;1355   
                          ENDP


                          AREA ||i.osThreadTerminate||, CODE, READONLY, ALIGN=1

                  osThreadTerminate PROC
;;;237    */
;;;238    osStatus osThreadTerminate (osThreadId thread_id)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240    #if (INCLUDE_vTaskDelete == 1)
;;;241      vTaskDelete(thread_id);
000002  f7fffffe          BL       vTaskDelete
;;;242      return osOK;
000006  2000              MOVS     r0,#0
;;;243    #else
;;;244      return osErrorOS;
;;;245    #endif
;;;246    }
000008  bd10              POP      {r4,pc}
;;;247    
                          ENDP


                          AREA ||i.osThreadYield||, CODE, READONLY, ALIGN=1

                  osThreadYield PROC
;;;252    */
;;;253    osStatus osThreadYield (void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255      taskYIELD();
000002  f7fffffe          BL       vPortYield
;;;256      
;;;257      return osOK;
000006  2000              MOVS     r0,#0
;;;258    }
000008  bd10              POP      {r4,pc}
;;;259    
                          ENDP


                          AREA ||i.osTimerCreate||, CODE, READONLY, ALIGN=1

                  osTimerCreate PROC
;;;339    */
;;;340    osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
000000  2000              MOVS     r0,#0
;;;341    {
;;;342    #if (configUSE_TIMERS == 1)
;;;343      return xTimerCreate((const char *)"",
;;;344                          1, // period should be filled when starting the Timer using osTimerStart
;;;345                          (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
;;;346                          (void *) argument,
;;;347                          (TaskFunction_t)timer_def->ptimer);
;;;348    #else 
;;;349    	return NULL;
;;;350    #endif
;;;351    }
000002  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.osTimerDelete||, CODE, READONLY, ALIGN=1

                  osTimerDelete PROC
;;;427    */
;;;428    osStatus osTimerDelete (osTimerId timer_id)
000000  20ff              MOVS     r0,#0xff
;;;429    {
;;;430    osStatus result = osOK;
;;;431    
;;;432    #if (configUSE_TIMERS == 1)
;;;433    
;;;434       if (inHandlerMode()) {
;;;435         return osErrorISR;
;;;436      }
;;;437      else { 
;;;438        if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {
;;;439          result = osErrorOS;
;;;440        }
;;;441      } 
;;;442        
;;;443    #else 
;;;444      result = osErrorOS;
;;;445    #endif 
;;;446     
;;;447      return result;
;;;448    }
000002  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.osTimerStart||, CODE, READONLY, ALIGN=1

                  osTimerStart PROC
;;;359    */
;;;360    osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
000000  20ff              MOVS     r0,#0xff
;;;361    {
;;;362      osStatus result = osOK;
;;;363    #if (configUSE_TIMERS == 1)  
;;;364      portBASE_TYPE taskWoken = pdFALSE;
;;;365      TickType_t ticks = millisec / portTICK_PERIOD_MS;
;;;366    
;;;367      if (ticks == 0)
;;;368        ticks = 1;
;;;369        
;;;370      if (inHandlerMode()) 
;;;371      {
;;;372        if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
;;;373        {
;;;374          result = osErrorOS;
;;;375        }
;;;376        else
;;;377        {
;;;378          portEND_SWITCHING_ISR(taskWoken);     
;;;379        }
;;;380      }
;;;381      else 
;;;382      {
;;;383        if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
;;;384          result = osErrorOS;
;;;385      }
;;;386    
;;;387    #else 
;;;388      result = osErrorOS;
;;;389    #endif
;;;390      return result;
;;;391    }
000002  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.osTimerStop||, CODE, READONLY, ALIGN=1

                  osTimerStop PROC
;;;398    */
;;;399    osStatus osTimerStop (osTimerId timer_id)
000000  20ff              MOVS     r0,#0xff
;;;400    {
;;;401      osStatus result = osOK;
;;;402    #if (configUSE_TIMERS == 1)  
;;;403      portBASE_TYPE taskWoken = pdFALSE;
;;;404    
;;;405      if (inHandlerMode()) {
;;;406        if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
;;;407          return osErrorOS;
;;;408        }
;;;409        portEND_SWITCHING_ISR(taskWoken);
;;;410      }
;;;411      else {
;;;412        if (xTimerStop(timer_id, 0) != pdPASS) {
;;;413          result = osErrorOS;
;;;414        }
;;;415      }
;;;416    #else 
;;;417      result = osErrorOS;
;;;418    #endif 
;;;419      return result;
;;;420    }
000002  4770              BX       lr
;;;421    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_cmsis_os_c_9292335d____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___10_cmsis_os_c_9292335d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_cmsis_os_c_9292335d____REVSH|
#line 402
|__asm___10_cmsis_os_c_9292335d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
