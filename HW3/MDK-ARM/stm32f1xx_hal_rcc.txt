; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\stm32f1xx_hal_rcc.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\stm32f1xx_hal_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\stm32f1xx_hal_rcc.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1245     */
;;;1246   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1247   {
;;;1248     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1249       the HAL_RCC_CSSCallback could be implemented in the user file
;;;1250       */ 
;;;1251   }
;;;1252   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;694      */
;;;695    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;696    {
;;;697      uint32_t tickstart = 0;
;;;698      
;;;699      /* Check the parameters */
;;;700      assert_param(RCC_ClkInitStruct != NULL);
;;;701      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;702      assert_param(IS_FLASH_LATENCY(FLatency));
;;;703    
;;;704      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;705      must be correctly programmed according to the frequency of the CPU clock 
;;;706        (HCLK) of the device. */
;;;707    
;;;708    #if defined(FLASH_ACR_LATENCY)
;;;709      /* Increasing the number of wait states because of higher CPU frequency */
;;;710      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  f8df8170          LDR      r8,|L2.376|
000008  4605              MOV      r5,r0                 ;696
00000a  460e              MOV      r6,r1                 ;696
00000c  f8d80000          LDR      r0,[r8,#0]
000010  f0000007          AND      r0,r0,#7
000014  42b0              CMP      r0,r6
000016  d20c              BCS      |L2.50|
;;;711      {    
;;;712        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;713        __HAL_FLASH_SET_LATENCY(FLatency);
000018  f8d81000          LDR      r1,[r8,#0]
00001c  f0210107          BIC      r1,r1,#7
000020  4331              ORRS     r1,r1,r6
000022  f8c81000          STR      r1,[r8,#0]
;;;714        
;;;715        /* Check that the new number of wait states is taken into account to access the Flash
;;;716        memory by reading the FLASH_ACR register */
;;;717        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
000026  f8d80000          LDR      r0,[r8,#0]
00002a  f0000007          AND      r0,r0,#7
00002e  42b0              CMP      r0,r6
000030  d177              BNE      |L2.290|
                  |L2.50|
;;;718        {
;;;719          return HAL_ERROR;
;;;720        }
;;;721      }
;;;722    
;;;723    #endif /* FLASH_ACR_LATENCY */
;;;724      /*-------------------------- HCLK Configuration --------------------------*/
;;;725      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
000032  7828              LDRB     r0,[r5,#0]
;;;726      {
;;;727        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;728        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
000034  4c51              LDR      r4,|L2.380|
000036  0780              LSLS     r0,r0,#30             ;725
000038  d505              BPL      |L2.70|
00003a  6860              LDR      r0,[r4,#4]
00003c  68a9              LDR      r1,[r5,#8]
00003e  f02000f0          BIC      r0,r0,#0xf0
000042  4308              ORRS     r0,r0,r1
000044  6060              STR      r0,[r4,#4]
                  |L2.70|
;;;729      }
;;;730    
;;;731      /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;732      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000046  7828              LDRB     r0,[r5,#0]
000048  07c0              LSLS     r0,r0,#31
00004a  d059              BEQ      |L2.256|
;;;733      {    
;;;734        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;735        
;;;736        /* HSE is selected as System Clock Source */
;;;737        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
00004c  6869              LDR      r1,[r5,#4]
00004e  2001              MOVS     r0,#1                 ;719
000050  2901              CMP      r1,#1
000052  d00d              BEQ      |L2.112|
;;;738        {
;;;739          /* Check the HSE ready flag */  
;;;740          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;741          {
;;;742            return HAL_ERROR;
;;;743          }
;;;744        }
;;;745        /* PLL is selected as System Clock Source */
;;;746        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
000054  2902              CMP      r1,#2
000056  d029              BEQ      |L2.172|
;;;747        {
;;;748          /* Check the PLL ready flag */  
;;;749          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;750          {
;;;751            return HAL_ERROR;
;;;752          }
;;;753        }
;;;754        /* HSI is selected as System Clock Source */
;;;755        else
;;;756        {
;;;757          /* Check the HSI ready flag */  
;;;758          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
000058  f05f0302          MOVS.W   r3,#2
                  |L2.92|
00005c  fa93f2a3          RBIT     r2,r3
000060  fab2f282          CLZ      r2,r2
000064  f0420220          ORR      r2,r2,#0x20
000068  0952              LSRS     r2,r2,#5
00006a  d004              BEQ      |L2.118|
00006c  6822              LDR      r2,[r4,#0]            ;740
00006e  e003              B        |L2.120|
                  |L2.112|
000070  f44f3300          MOV      r3,#0x20000           ;740
000074  e7f2              B        |L2.92|
                  |L2.118|
000076  6a62              LDR      r2,[r4,#0x24]         ;740
                  |L2.120|
000078  fa93f3a3          RBIT     r3,r3
00007c  fab3f383          CLZ      r3,r3
000080  f003031f          AND      r3,r3,#0x1f
000084  4098              LSLS     r0,r0,r3
000086  4202              TST      r2,r0
000088  d04b              BEQ      |L2.290|
;;;759          {
;;;760            return HAL_ERROR;
;;;761          }
;;;762        }
;;;763        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
00008a  6860              LDR      r0,[r4,#4]
00008c  f0200003          BIC      r0,r0,#3
000090  4308              ORRS     r0,r0,r1
000092  6060              STR      r0,[r4,#4]
;;;764    
;;;765        /* Get Start Tick */
;;;766        tickstart = HAL_GetTick();
000094  f7fffffe          BL       HAL_GetTick
;;;767        
;;;768        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000098  6869              LDR      r1,[r5,#4]
00009a  4607              MOV      r7,r0                 ;766
;;;769        {
;;;770          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;771          {
;;;772            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00009c  f2413088          MOV      r0,#0x1388
0000a0  2901              CMP      r1,#1                 ;768
0000a2  d00d              BEQ      |L2.192|
;;;773            {
;;;774              return HAL_TIMEOUT;
;;;775            }
;;;776          }
;;;777        }
;;;778        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
0000a4  2902              CMP      r1,#2
0000a6  4681              MOV      r9,r0                 ;772
0000a8  d017              BEQ      |L2.218|
0000aa  e025              B        |L2.248|
                  |L2.172|
0000ac  f04f7300          MOV      r3,#0x2000000         ;749
0000b0  e7d4              B        |L2.92|
0000b2  bf00              NOP                            ;772
                  |L2.180|
0000b4  f7fffffe          BL       HAL_GetTick
0000b8  1bc1              SUBS     r1,r0,r7              ;772
0000ba  4549              CMP      r1,r9                 ;772
0000bc  d901              BLS      |L2.194|
0000be  e018              B        |L2.242|
                  |L2.192|
0000c0  4681              MOV      r9,r0                 ;772
                  |L2.194|
0000c2  6860              LDR      r0,[r4,#4]            ;770
0000c4  f3c00081          UBFX     r0,r0,#2,#2           ;770
0000c8  2801              CMP      r0,#1                 ;770
0000ca  d1f3              BNE      |L2.180|
0000cc  e018              B        |L2.256|
;;;779        {
;;;780          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;781          {
;;;782            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
0000ce  bf00              NOP      
                  |L2.208|
0000d0  f7fffffe          BL       HAL_GetTick
0000d4  1bc1              SUBS     r1,r0,r7
0000d6  4549              CMP      r1,r9
0000d8  d80b              BHI      |L2.242|
                  |L2.218|
0000da  6860              LDR      r0,[r4,#4]            ;780
0000dc  f3c00081          UBFX     r0,r0,#2,#2           ;780
0000e0  2802              CMP      r0,#2                 ;780
0000e2  d1f5              BNE      |L2.208|
0000e4  e00c              B        |L2.256|
;;;783            {
;;;784              return HAL_TIMEOUT;
;;;785            }
;;;786          }
;;;787        }
;;;788        else
;;;789        {
;;;790          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
;;;791          {
;;;792            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
0000e6  bf00              NOP      
                  |L2.232|
0000e8  f7fffffe          BL       HAL_GetTick
0000ec  1bc1              SUBS     r1,r0,r7
0000ee  4549              CMP      r1,r9
0000f0  d902              BLS      |L2.248|
                  |L2.242|
;;;793            {
;;;794              return HAL_TIMEOUT;
0000f2  2003              MOVS     r0,#3
                  |L2.244|
;;;795            }
;;;796          }
;;;797        }      
;;;798      }    
;;;799    #if defined(FLASH_ACR_LATENCY)
;;;800      /* Decreasing the number of wait states because of lower CPU frequency */
;;;801      if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
;;;802      {    
;;;803        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;804        __HAL_FLASH_SET_LATENCY(FLatency);
;;;805        
;;;806        /* Check that the new number of wait states is taken into account to access the Flash
;;;807        memory by reading the FLASH_ACR register */
;;;808        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;809        {
;;;810          return HAL_ERROR;
;;;811        }
;;;812      }    
;;;813    #endif /* FLASH_ACR_LATENCY */
;;;814    
;;;815      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;816      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;817      {
;;;818        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;819        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;820      }
;;;821      
;;;822      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;823      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;824      {
;;;825        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;826        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;827      }
;;;828     
;;;829      /* Update the SystemCoreClock global variable */
;;;830      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
;;;831    
;;;832      /* Configure the source of time base considering new system clocks settings*/
;;;833      HAL_InitTick (TICK_INT_PRIORITY);
;;;834      
;;;835      return HAL_OK;
;;;836    }
0000f4  e8bd87f0          POP      {r4-r10,pc}
                  |L2.248|
0000f8  6860              LDR      r0,[r4,#4]            ;790
0000fa  f0100f0c          TST      r0,#0xc               ;790
0000fe  d1f3              BNE      |L2.232|
                  |L2.256|
000100  f8d81000          LDR      r1,[r8,#0]            ;801
000104  4640              MOV      r0,r8                 ;801
000106  f0010107          AND      r1,r1,#7              ;801
00010a  42b1              CMP      r1,r6                 ;801
00010c  d90b              BLS      |L2.294|
00010e  6801              LDR      r1,[r0,#0]            ;804
000110  f0210107          BIC      r1,r1,#7              ;804
000114  4331              ORRS     r1,r1,r6              ;804
000116  6001              STR      r1,[r0,#0]            ;804
000118  6800              LDR      r0,[r0,#0]            ;808
00011a  f0000007          AND      r0,r0,#7              ;808
00011e  42b0              CMP      r0,r6                 ;808
000120  d001              BEQ      |L2.294|
                  |L2.290|
000122  2001              MOVS     r0,#1                 ;810
000124  e7e6              B        |L2.244|
                  |L2.294|
000126  7828              LDRB     r0,[r5,#0]            ;816
000128  0740              LSLS     r0,r0,#29             ;816
00012a  d505              BPL      |L2.312|
00012c  6860              LDR      r0,[r4,#4]            ;819
00012e  68e9              LDR      r1,[r5,#0xc]          ;819
000130  f42060e0          BIC      r0,r0,#0x700          ;819
000134  4308              ORRS     r0,r0,r1              ;819
000136  6060              STR      r0,[r4,#4]            ;819
                  |L2.312|
000138  7828              LDRB     r0,[r5,#0]            ;823
00013a  0700              LSLS     r0,r0,#28             ;823
00013c  d506              BPL      |L2.332|
00013e  6860              LDR      r0,[r4,#4]            ;826
000140  6929              LDR      r1,[r5,#0x10]         ;826
000142  f4205060          BIC      r0,r0,#0x3800         ;826
000146  ea4000c1          ORR      r0,r0,r1,LSL #3       ;826
00014a  6060              STR      r0,[r4,#4]            ;826
                  |L2.332|
00014c  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000150  6861              LDR      r1,[r4,#4]            ;830
000152  22f0              MOVS     r2,#0xf0              ;830
000154  fa92f2a2          RBIT     r2,r2                 ;830
000158  f00101f0          AND      r1,r1,#0xf0           ;830
00015c  fab2f282          CLZ      r2,r2                 ;830
000160  40d1              LSRS     r1,r1,r2              ;830
000162  4a07              LDR      r2,|L2.384|
000164  5c51              LDRB     r1,[r2,r1]            ;830
000166  40c8              LSRS     r0,r0,r1              ;830
000168  4906              LDR      r1,|L2.388|
00016a  6008              STR      r0,[r1,#0]            ;833  ; SystemCoreClock
00016c  2000              MOVS     r0,#0                 ;833
00016e  f7fffffe          BL       HAL_InitTick
000172  2000              MOVS     r0,#0                 ;835
000174  e7be              B        |L2.244|
;;;837    
                          ENDP

000176  0000              DCW      0x0000
                  |L2.376|
                          DCD      0x40022000
                  |L2.380|
                          DCD      0x40021000
                  |L2.384|
                          DCD      AHBPrescTable
                  |L2.388|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;220      */
;;;221    void HAL_RCC_DeInit(void)
000000  4810              LDR      r0,|L3.68|
;;;222    {
000002  b510              PUSH     {r4,lr}
;;;223      /* Switch SYSCLK to HSI */
;;;224      CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
000004  6841              LDR      r1,[r0,#4]
000006  f0210103          BIC      r1,r1,#3
00000a  6041              STR      r1,[r0,#4]
;;;225    
;;;226      /* Reset HSEON, CSSON, & PLLON bits */
;;;227      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
00000c  6801              LDR      r1,[r0,#0]
00000e  4a0e              LDR      r2,|L3.72|
000010  4011              ANDS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;228      
;;;229      /* Reset HSEBYP bit */
;;;230      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
000014  6801              LDR      r1,[r0,#0]
000016  f4212180          BIC      r1,r1,#0x40000
00001a  6001              STR      r1,[r0,#0]
;;;231      
;;;232      /* Reset CFGR register */
;;;233      CLEAR_REG(RCC->CFGR);
00001c  2100              MOVS     r1,#0
00001e  6041              STR      r1,[r0,#4]
;;;234      
;;;235      /* Set HSITRIM bits to the reset value */
;;;236      MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_CR_HSITRIM)));
000020  6802              LDR      r2,[r0,#0]
000022  24f8              MOVS     r4,#0xf8
000024  fa94f4a4          RBIT     r4,r4
000028  2310              MOVS     r3,#0x10
00002a  fab4f484          CLZ      r4,r4
00002e  f02202f8          BIC      r2,r2,#0xf8
000032  40a3              LSLS     r3,r3,r4
000034  431a              ORRS     r2,r2,r3
000036  6002              STR      r2,[r0,#0]
;;;237      
;;;238    #if (defined(STM32F105xC) || defined(STM32F107xC) || defined (STM32F100xB) || defined (STM32F100xE))
;;;239      /* Reset CFGR2 register */
;;;240      CLEAR_REG(RCC->CFGR2);
;;;241    
;;;242    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;243      /* Disable all interrupts */
;;;244      CLEAR_REG(RCC->CIR);
000038  6081              STR      r1,[r0,#8]
;;;245    
;;;246      /* Update the SystemCoreClock global variable */
;;;247      SystemCoreClock = HSI_VALUE;
00003a  4905              LDR      r1,|L3.80|
00003c  4803              LDR      r0,|L3.76|
00003e  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;248    }
000040  bd10              POP      {r4,pc}
;;;249    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      0x40021000
                  |L3.72|
                          DCD      0xfef6ffff
                  |L3.76|
                          DCD      0x007a1200
                  |L3.80|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;929      */
;;;930    void HAL_RCC_DisableCSS(void)
000000  f44f2100          MOV      r1,#0x80000
;;;931    {
;;;932      *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
000004  fa91f1a1          RBIT     r1,r1
000008  4a03              LDR      r2,|L4.24|
00000a  fab1f181          CLZ      r1,r1
00000e  2000              MOVS     r0,#0
000010  f8420021          STR      r0,[r2,r1,LSL #2]
;;;933    }
000014  4770              BX       lr
;;;934    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;920      */
;;;921    void HAL_RCC_EnableCSS(void)
000000  2001              MOVS     r0,#1
;;;922    {
;;;923      *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
000002  04c1              LSLS     r1,r0,#19
000004  fa91f1a1          RBIT     r1,r1
000008  4a02              LDR      r2,|L5.20|
00000a  fab1f181          CLZ      r1,r1
00000e  f8420021          STR      r0,[r2,r1,LSL #2]
;;;924    }
000012  4770              BX       lr
;;;925    
                          ENDP

                  |L5.20|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1193     */
;;;1194   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1195   {
;;;1196     /* Check the parameters */
;;;1197     assert_param(RCC_ClkInitStruct != NULL);
;;;1198     assert_param(pFLatency != NULL);
;;;1199   
;;;1200     /* Set all possible values for the Clock type parameter --------------------*/
;;;1201     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1202     
;;;1203     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1204     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L6.56|
000006  6853              LDR      r3,[r2,#4]
000008  f0030303          AND      r3,r3,#3
;;;1205     
;;;1206     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1207     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000c  6043              STR      r3,[r0,#4]
00000e  6853              LDR      r3,[r2,#4]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1208     
;;;1209     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1210     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
000014  6083              STR      r3,[r0,#8]
000016  6853              LDR      r3,[r2,#4]
000018  f40363e0          AND      r3,r3,#0x700
;;;1211     
;;;1212     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1213     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6852              LDR      r2,[r2,#4]
;;;1214     
;;;1215   #if   defined(FLASH_ACR_LATENCY)
;;;1216     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1217     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
;;;1218   #else
;;;1219     /* For VALUE lines devices, only LATENCY_0 can be set*/
;;;1220     *pFLatency = (uint32_t)FLASH_LATENCY_0; 
;;;1221   #endif
;;;1222   }
000020  f44f63e0          MOV      r3,#0x700
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1217
00002a  4804              LDR      r0,|L6.60|
00002c  6800              LDR      r0,[r0,#0]            ;1217
00002e  f0000007          AND      r0,r0,#7              ;1217
000032  6008              STR      r0,[r1,#0]            ;1217
000034  4770              BX       lr
;;;1223   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40021000
                  |L6.60|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1057     */
;;;1058   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1059   {
;;;1060     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1061   }
000004  4770              BX       lr
;;;1062   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1093     */
;;;1094   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;1095   {
;;;1096     /* Check the parameters */
;;;1097     assert_param(RCC_OscInitStruct != NULL);
;;;1098   
;;;1099     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1100     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
000002  210f              MOVS     r1,#0xf
;;;1101                     | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1102   
;;;1103   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1104     /* Get the Prediv1 source --------------------------------------------------*/
;;;1105     RCC_OscInitStruct->Prediv1Source = READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC);
;;;1106   #endif /* RCC_CFGR2_PREDIV1SRC */
;;;1107   
;;;1108     /* Get the HSE configuration -----------------------------------------------*/
;;;1109     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000004  6001              STR      r1,[r0,#0]
000006  4924              LDR      r1,|L8.152|
000008  680a              LDR      r2,[r1,#0]
00000a  0353              LSLS     r3,r2,#13
00000c  f04f0200          MOV      r2,#0
000010  d502              BPL      |L8.24|
;;;1110     {
;;;1111       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  f44f23a0          MOV      r3,#0x50000
000016  e004              B        |L8.34|
                  |L8.24|
;;;1112     }
;;;1113     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
000018  680b              LDR      r3,[r1,#0]
00001a  03db              LSLS     r3,r3,#15
00001c  d503              BPL      |L8.38|
;;;1114     {
;;;1115       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001e  f44f3380          MOV      r3,#0x10000
                  |L8.34|
000022  6043              STR      r3,[r0,#4]
000024  e000              B        |L8.40|
                  |L8.38|
;;;1116     }
;;;1117     else
;;;1118     {
;;;1119       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000026  6042              STR      r2,[r0,#4]
                  |L8.40|
;;;1120     }
;;;1121     RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
000028  684b              LDR      r3,[r1,#4]
00002a  f4033300          AND      r3,r3,#0x20000
;;;1122   
;;;1123     /* Get the HSI configuration -----------------------------------------------*/
;;;1124     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
00002e  6083              STR      r3,[r0,#8]
000030  680b              LDR      r3,[r1,#0]
000032  07dc              LSLS     r4,r3,#31
;;;1125     {
;;;1126       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000034  f04f0301          MOV      r3,#1
000038  d001              BEQ      |L8.62|
00003a  6103              STR      r3,[r0,#0x10]
00003c  e000              B        |L8.64|
                  |L8.62|
;;;1127     }
;;;1128     else
;;;1129     {
;;;1130       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
00003e  6102              STR      r2,[r0,#0x10]
                  |L8.64|
;;;1131     }
;;;1132     
;;;1133     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
000040  680c              LDR      r4,[r1,#0]
000042  25f8              MOVS     r5,#0xf8
000044  fa95f5a5          RBIT     r5,r5
000048  f00404f8          AND      r4,r4,#0xf8
00004c  fab5f585          CLZ      r5,r5
000050  40ec              LSRS     r4,r4,r5
;;;1134     
;;;1135     /* Get the LSE configuration -----------------------------------------------*/
;;;1136     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000052  6144              STR      r4,[r0,#0x14]
000054  6a0c              LDR      r4,[r1,#0x20]
000056  0764              LSLS     r4,r4,#29
000058  d502              BPL      |L8.96|
;;;1137     {
;;;1138       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
00005a  2405              MOVS     r4,#5
00005c  60c4              STR      r4,[r0,#0xc]
00005e  e005              B        |L8.108|
                  |L8.96|
;;;1139     }
;;;1140     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000060  6a0c              LDR      r4,[r1,#0x20]
000062  07e4              LSLS     r4,r4,#31
000064  d001              BEQ      |L8.106|
;;;1141     {
;;;1142       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
000066  60c3              STR      r3,[r0,#0xc]
000068  e000              B        |L8.108|
                  |L8.106|
;;;1143     }
;;;1144     else
;;;1145     {
;;;1146       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00006a  60c2              STR      r2,[r0,#0xc]
                  |L8.108|
;;;1147     }
;;;1148     
;;;1149     /* Get the LSI configuration -----------------------------------------------*/
;;;1150     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
00006c  6a4c              LDR      r4,[r1,#0x24]
00006e  07e4              LSLS     r4,r4,#31
000070  d001              BEQ      |L8.118|
;;;1151     {
;;;1152       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000072  6183              STR      r3,[r0,#0x18]
000074  e000              B        |L8.120|
                  |L8.118|
;;;1153     }
;;;1154     else
;;;1155     {
;;;1156       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000076  6182              STR      r2,[r0,#0x18]
                  |L8.120|
;;;1157     }
;;;1158     
;;;1159   
;;;1160     /* Get the PLL configuration -----------------------------------------------*/
;;;1161     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000078  680a              LDR      r2,[r1,#0]
00007a  01d2              LSLS     r2,r2,#7
00007c  d502              BPL      |L8.132|
;;;1162     {
;;;1163       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
00007e  2202              MOVS     r2,#2
000080  61c2              STR      r2,[r0,#0x1c]
000082  e000              B        |L8.134|
                  |L8.132|
;;;1164     }
;;;1165     else
;;;1166     {
;;;1167       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000084  61c3              STR      r3,[r0,#0x1c]
                  |L8.134|
;;;1168     }
;;;1169     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
000086  684a              LDR      r2,[r1,#4]
000088  f4023280          AND      r2,r2,#0x10000
;;;1170     RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
00008c  6202              STR      r2,[r0,#0x20]
00008e  6849              LDR      r1,[r1,#4]
000090  f4011170          AND      r1,r1,#0x3c0000
000094  6241              STR      r1,[r0,#0x24]
;;;1171   #if defined(RCC_CR_PLL2ON)
;;;1172     /* Get the PLL2 configuration -----------------------------------------------*/
;;;1173     if((RCC->CR &RCC_CR_PLL2ON) == RCC_CR_PLL2ON)
;;;1174     {
;;;1175       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_ON;
;;;1176     }
;;;1177     else
;;;1178     {
;;;1179       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_OFF;
;;;1180     }
;;;1181     RCC_OscInitStruct->PLL2.HSEPrediv2Value = __HAL_RCC_HSE_GET_PREDIV2();
;;;1182     RCC_OscInitStruct->PLL2.PLL2MUL = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PLL2MUL);
;;;1183   #endif /* RCC_CR_PLL2ON */
;;;1184   }
000096  bd30              POP      {r4,r5,pc}
;;;1185   
                          ENDP

                  |L8.152|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1068     */
;;;1069   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4808              LDR      r0,|L9.36|
;;;1070   {
;;;1071     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1072     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
000002  4909              LDR      r1,|L9.40|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  f44f62e0          MOV      r2,#0x700
00000c  fa92f2a2          RBIT     r2,r2
000010  f40161e0          AND      r1,r1,#0x700
000014  fab2f282          CLZ      r2,r2
000018  40d1              LSRS     r1,r1,r2
00001a  4a04              LDR      r2,|L9.44|
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
;;;1073   }    
000020  4770              BX       lr
;;;1074   
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      SystemCoreClock
                  |L9.40|
                          DCD      0x40021000
                  |L9.44|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1080     */
;;;1081   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4808              LDR      r0,|L10.36|
;;;1082   {
;;;1083     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1084     return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
000002  4909              LDR      r1,|L10.40|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  f44f5260          MOV      r2,#0x3800
00000c  fa92f2a2          RBIT     r2,r2
000010  f4015160          AND      r1,r1,#0x3800
000014  fab2f282          CLZ      r2,r2
000018  40d1              LSRS     r1,r1,r2
00001a  4a04              LDR      r2,|L10.44|
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
;;;1085   } 
000020  4770              BX       lr
;;;1086   
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      SystemCoreClock
                  |L10.40|
                          DCD      0x40021000
                  |L10.44|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;963      */
;;;964    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;965    {
;;;966    #if   defined(RCC_CFGR2_PREDIV1SRC)
;;;967      const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
;;;968      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;969    #else
;;;970      const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
000002  a319              ADR      r3,|L11.104|
000004  b085              SUB      sp,sp,#0x14           ;965
000006  cb0f              LDM      r3,{r0-r3}
000008  e88d000f          STM      sp,{r0-r3}
;;;971    #if defined(RCC_CFGR2_PREDIV1)
;;;972      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;973    #else
;;;974      const uint8_t aPredivFactorTable[2] = { 1, 2};
00000c  a01a              ADR      r0,|L11.120|
;;;975    #endif /*RCC_CFGR2_PREDIV1*/
;;;976    
;;;977    #endif
;;;978      uint32_t tmpreg = 0, prediv = 0, pllclk = 0, pllmul = 0;
;;;979      uint32_t sysclockfreq = 0;
;;;980    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;981      uint32_t prediv2 = 0, pll2mul = 0;
;;;982    #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;983      
;;;984      tmpreg = RCC->CFGR;
00000e  4b1b              LDR      r3,|L11.124|
000010  6800              LDR      r0,[r0,#0]            ;974
000012  9004              STR      r0,[sp,#0x10]
000014  685a              LDR      r2,[r3,#4]
;;;985      
;;;986      /* Get SYSCLK source -------------------------------------------------------*/
;;;987      switch (tmpreg & RCC_CFGR_SWS)
;;;988      {
;;;989        case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
;;;990        {
;;;991          sysclockfreq = HSE_VALUE;
000016  481a              LDR      r0,|L11.128|
000018  f002010c          AND      r1,r2,#0xc            ;987
00001c  2904              CMP      r1,#4                 ;987
00001e  d01d              BEQ      |L11.92|
000020  2908              CMP      r1,#8                 ;987
000022  d11b              BNE      |L11.92|
;;;992          break;
;;;993        }
;;;994        case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
;;;995        {
;;;996          pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
000024  f44f1470          MOV      r4,#0x3c0000
000028  fa94f4a4          RBIT     r4,r4
00002c  f4021170          AND      r1,r2,#0x3c0000
000030  fab4f484          CLZ      r4,r4
000034  40e1              LSRS     r1,r1,r4
;;;997          if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000036  03d2              LSLS     r2,r2,#15
000038  f81d1001          LDRB     r1,[sp,r1]            ;996
00003c  d510              BPL      |L11.96|
;;;998          {
;;;999    #if defined(RCC_CFGR2_PREDIV1)
;;;1000           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
;;;1001   #else
;;;1002           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
00003e  685a              LDR      r2,[r3,#4]
000040  f44f3300          MOV      r3,#0x20000
000044  fa93f3a3          RBIT     r3,r3
000048  f4023200          AND      r2,r2,#0x20000
00004c  fab3f383          CLZ      r3,r3
000050  40da              LSRS     r2,r2,r3
000052  ab04              ADD      r3,sp,#0x10
000054  5c9a              LDRB     r2,[r3,r2]
;;;1003   #endif /*RCC_CFGR2_PREDIV1*/
;;;1004   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1005   
;;;1006           if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;1007           {
;;;1008             /* PLL2 selected as Prediv1 source */
;;;1009             /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;1010             prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;1011             pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
;;;1012             pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv) * pllmul);
;;;1013           }
;;;1014           else
;;;1015           {
;;;1016             /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1017             pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
;;;1018           }
;;;1019           
;;;1020           /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;1021           /* In this case need to divide pllclk by 2 */
;;;1022           if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
;;;1023           {
;;;1024               pllclk = pllclk / 2;
;;;1025           }
;;;1026   #else
;;;1027           /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1028           pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
000056  fbb0f0f2          UDIV     r0,r0,r2
00005a  4348              MULS     r0,r1,r0
                  |L11.92|
;;;1029   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1030         }
;;;1031         else
;;;1032         {
;;;1033           /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;1034           pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
;;;1035         }
;;;1036         sysclockfreq = pllclk;
;;;1037         break;
;;;1038       }
;;;1039       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1040       default: /* HSI used as system clock */
;;;1041       {
;;;1042         sysclockfreq = HSI_VALUE;
;;;1043         break;
;;;1044       }
;;;1045     }
;;;1046     return sysclockfreq;
;;;1047   }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd10              POP      {r4,pc}
                  |L11.96|
000060  4808              LDR      r0,|L11.132|
000062  4348              MULS     r0,r1,r0              ;1034
000064  e7fa              B        |L11.92|
;;;1048   
                          ENDP

000066  0000              DCW      0x0000
                  |L11.104|
000068  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
00006c  06070809
000070  0a0b0c0d
000074  0e0f1010
                  |L11.120|
000078  010200            DCB      1,2,0
00007b  00                DCB      0
                  |L11.124|
                          DCD      0x40021000
                  |L11.128|
                          DCD      0x007a1200
                  |L11.132|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;887      */
;;;888    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b530              PUSH     {r4,r5,lr}
;;;889    {
000002  b085              SUB      sp,sp,#0x14
;;;890      GPIO_InitTypeDef gpio = {0};
000004  2000              MOVS     r0,#0
;;;891    
;;;892      /* Check the parameters */
;;;893      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;894      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;895      assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;896      
;;;897      /* Configure the MCO1 pin in alternate function mode */
;;;898      gpio.Mode      = GPIO_MODE_AF_PP;
000006  9002              STR      r0,[sp,#8]
000008  2002              MOVS     r0,#2
;;;899      gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
00000a  9001              STR      r0,[sp,#4]
00000c  2003              MOVS     r0,#3
;;;900      gpio.Pull      = GPIO_NOPULL;
;;;901      gpio.Pin       = MCO1_PIN;
00000e  9003              STR      r0,[sp,#0xc]
;;;902    
;;;903      /* MCO1 Clock Enable */
;;;904      MCO1_CLK_ENABLE();
000010  4c0b              LDR      r4,|L12.64|
000012  f44f7080          MOV      r0,#0x100             ;901
000016  9000              STR      r0,[sp,#0]
000018  69a0              LDR      r0,[r4,#0x18]
00001a  460d              MOV      r5,r1                 ;889
00001c  f0400004          ORR      r0,r0,#4
000020  61a0              STR      r0,[r4,#0x18]
000022  69a0              LDR      r0,[r4,#0x18]
;;;905      
;;;906      HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
000024  4669              MOV      r1,sp
000026  f0000004          AND      r0,r0,#4              ;904
00002a  9004              STR      r0,[sp,#0x10]
00002c  4805              LDR      r0,|L12.68|
00002e  f7fffffe          BL       HAL_GPIO_Init
;;;907      
;;;908      /* Configure the MCO clock source */
;;;909      __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
000032  6860              LDR      r0,[r4,#4]
000034  f02060e0          BIC      r0,r0,#0x7000000
000038  4328              ORRS     r0,r0,r5
00003a  6060              STR      r0,[r4,#4]
;;;910    }
00003c  b005              ADD      sp,sp,#0x14
00003e  bd30              POP      {r4,r5,pc}
;;;911    
                          ENDP

                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0x40010800

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1228     */
;;;1229   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1230   {
;;;1231     /* Check RCC CSSF flag  */
;;;1232     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L13.20|
000004  68a0              LDR      r0,[r4,#8]
000006  0600              LSLS     r0,r0,#24
000008  d503              BPL      |L13.18|
;;;1233     {
;;;1234       /* RCC Clock Security System interrupt user callback */
;;;1235       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1236       
;;;1237       /* Clear RCC CSS pending bit */
;;;1238       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  2080              MOVS     r0,#0x80
000010  72a0              STRB     r0,[r4,#0xa]
                  |L13.18|
;;;1239     }
;;;1240   }
000012  bd10              POP      {r4,pc}
;;;1241   
                          ENDP

                  |L13.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;264      */
;;;265    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;266    {
000004  4604              MOV      r4,r0
;;;267       uint32_t tickstart = 0;
;;;268      
;;;269      /* Check the parameters */
;;;270      assert_param(RCC_OscInitStruct != NULL);
;;;271      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;272      
;;;273      /*------------------------------- HSE Configuration ------------------------*/ 
;;;274      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000006  7800              LDRB     r0,[r0,#0]
;;;275      {
;;;276        /* Check the parameters */
;;;277        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;278            
;;;279        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;280        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000008  4df7              LDR      r5,|L14.1000|
00000a  07c0              LSLS     r0,r0,#31             ;274
;;;281           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
;;;282        {
;;;283          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
00000c  f04f0601          MOV      r6,#1
000010  d025              BEQ      |L14.94|
000012  6868              LDR      r0,[r5,#4]            ;280
000014  0477              LSLS     r7,r6,#17
000016  f3c00081          UBFX     r0,r0,#2,#2           ;280
00001a  2801              CMP      r0,#1                 ;280
00001c  d007              BEQ      |L14.46|
00001e  6868              LDR      r0,[r5,#4]            ;281
000020  f3c00081          UBFX     r0,r0,#2,#2           ;281
000024  2802              CMP      r0,#2                 ;281
000026  d11b              BNE      |L14.96|
000028  6868              LDR      r0,[r5,#4]            ;281
00002a  03c0              LSLS     r0,r0,#15             ;281
00002c  d518              BPL      |L14.96|
                  |L14.46|
00002e  fa97f0a7          RBIT     r0,r7
000032  fab0f080          CLZ      r0,r0
000036  f0400020          ORR      r0,r0,#0x20
00003a  0940              LSRS     r0,r0,#5
00003c  d001              BEQ      |L14.66|
00003e  6828              LDR      r0,[r5,#0]
000040  e000              B        |L14.68|
                  |L14.66|
000042  6a68              LDR      r0,[r5,#0x24]
                  |L14.68|
000044  fa97f1a7          RBIT     r1,r7
000048  fab1f181          CLZ      r1,r1
00004c  f001011f          AND      r1,r1,#0x1f
000050  fa06f101          LSL      r1,r6,r1
000054  4208              TST      r0,r1
000056  d05e              BEQ      |L14.278|
000058  6860              LDR      r0,[r4,#4]
00005a  2800              CMP      r0,#0
00005c  d07c              BEQ      |L14.344|
                  |L14.94|
00005e  e05a              B        |L14.278|
                  |L14.96|
;;;284          {
;;;285            return HAL_ERROR;
;;;286          }
;;;287        }
;;;288        else
;;;289        {
;;;290          /* Set the new HSE configuration ---------------------------------------*/
;;;291          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
000060  6860              LDR      r0,[r4,#4]
000062  f5b03f80          CMP      r0,#0x10000
000066  d00b              BEQ      |L14.128|
000068  b110              CBZ      r0,|L14.112|
00006a  f5b02fa0          CMP      r0,#0x50000
00006e  d011              BEQ      |L14.148|
                  |L14.112|
000070  6828              LDR      r0,[r5,#0]
000072  f4203080          BIC      r0,r0,#0x10000
000076  6028              STR      r0,[r5,#0]
000078  6828              LDR      r0,[r5,#0]
00007a  f4202080          BIC      r0,r0,#0x40000
00007e  e002              B        |L14.134|
                  |L14.128|
000080  6828              LDR      r0,[r5,#0]
000082  f4403080          ORR      r0,r0,#0x10000
                  |L14.134|
000086  6028              STR      r0,[r5,#0]
;;;292          
;;;293    
;;;294           /* Check the HSE State */
;;;295          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
000088  6860              LDR      r0,[r4,#4]
00008a  b328              CBZ      r0,|L14.216|
;;;296          {
;;;297            /* Get Start Tick */
;;;298            tickstart = HAL_GetTick();
00008c  f7fffffe          BL       HAL_GetTick
000090  4680              MOV      r8,r0
;;;299            
;;;300            /* Wait till HSE is ready */
;;;301            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000092  e00b              B        |L14.172|
                  |L14.148|
000094  6828              LDR      r0,[r5,#0]            ;291
000096  f4402080          ORR      r0,r0,#0x40000        ;291
00009a  6028              STR      r0,[r5,#0]            ;291
00009c  e7f0              B        |L14.128|
;;;302            {
;;;303              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
00009e  bf00              NOP      
                  |L14.160|
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  eba00008          SUB      r0,r0,r8
0000a8  2864              CMP      r0,#0x64
                  |L14.170|
0000aa  d871              BHI      |L14.400|
                  |L14.172|
0000ac  fa97f0a7          RBIT     r0,r7                 ;301
0000b0  fab0f080          CLZ      r0,r0                 ;301
0000b4  f0400020          ORR      r0,r0,#0x20           ;301
0000b8  0940              LSRS     r0,r0,#5              ;301
0000ba  d001              BEQ      |L14.192|
0000bc  6828              LDR      r0,[r5,#0]            ;301
0000be  e000              B        |L14.194|
                  |L14.192|
0000c0  6a68              LDR      r0,[r5,#0x24]         ;301
                  |L14.194|
0000c2  fa97f1a7          RBIT     r1,r7                 ;301
0000c6  fab1f181          CLZ      r1,r1                 ;301
0000ca  f001011f          AND      r1,r1,#0x1f           ;301
0000ce  fa06f101          LSL      r1,r6,r1              ;301
0000d2  4208              TST      r0,r1                 ;301
0000d4  d0e4              BEQ      |L14.160|
0000d6  e01e              B        |L14.278|
                  |L14.216|
;;;304              {
;;;305                return HAL_TIMEOUT;
;;;306              }
;;;307            }
;;;308          }
;;;309          else
;;;310          {
;;;311            /* Get Start Tick */
;;;312            tickstart = HAL_GetTick();
0000d8  f7fffffe          BL       HAL_GetTick
0000dc  4680              MOV      r8,r0
;;;313            
;;;314            /* Wait till HSE is disabled */
;;;315            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
0000de  e005              B        |L14.236|
                  |L14.224|
;;;316            {
;;;317               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000e0  f7fffffe          BL       HAL_GetTick
0000e4  eba00008          SUB      r0,r0,r8
0000e8  2864              CMP      r0,#0x64
0000ea  d8de              BHI      |L14.170|
                  |L14.236|
0000ec  fa97f0a7          RBIT     r0,r7                 ;315
0000f0  fab0f080          CLZ      r0,r0                 ;315
0000f4  f0400020          ORR      r0,r0,#0x20           ;315
0000f8  0940              LSRS     r0,r0,#5              ;315
0000fa  d001              BEQ      |L14.256|
0000fc  6828              LDR      r0,[r5,#0]            ;315
0000fe  e000              B        |L14.258|
                  |L14.256|
000100  6a68              LDR      r0,[r5,#0x24]         ;315
                  |L14.258|
000102  fa97f1a7          RBIT     r1,r7                 ;315
000106  fab1f181          CLZ      r1,r1                 ;315
00010a  f001011f          AND      r1,r1,#0x1f           ;315
00010e  fa06f101          LSL      r1,r6,r1              ;315
000112  4208              TST      r0,r1                 ;315
000114  d1e4              BNE      |L14.224|
                  |L14.278|
;;;318              {
;;;319                return HAL_TIMEOUT;
;;;320              }
;;;321            }
;;;322          }
;;;323        }
;;;324      }
;;;325      /*----------------------------- HSI Configuration --------------------------*/ 
;;;326      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
000116  7820              LDRB     r0,[r4,#0]
;;;327      {
;;;328        /* Check the parameters */
;;;329        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;330        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;331        
;;;332        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;333        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
;;;334           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
;;;335        {
;;;336          /* When HSI is used as system clock it will not disabled */
;;;337          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;338          {
;;;339            return HAL_ERROR;
;;;340          }
;;;341          /* Otherwise, just the calibration is allowed */
;;;342          else
;;;343          {
;;;344            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;345            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;346          }
;;;347        }
;;;348        else
;;;349        {
;;;350          /* Check the HSI State */
;;;351          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;352          {
;;;353           /* Enable the Internal High Speed oscillator (HSI). */
;;;354            __HAL_RCC_HSI_ENABLE();
000118  f8df82d0          LDR      r8,|L14.1004|
00011c  0780              LSLS     r0,r0,#30             ;326
00011e  f04f0900          MOV      r9,#0                 ;326
000122  f04f0702          MOV      r7,#2                 ;337
000126  d55b              BPL      |L14.480|
000128  6868              LDR      r0,[r5,#4]            ;333
00012a  f04f0bf8          MOV      r11,#0xf8             ;345
00012e  f0100f0c          TST      r0,#0xc               ;333
000132  d007              BEQ      |L14.324|
000134  6868              LDR      r0,[r5,#4]            ;334
000136  f3c00081          UBFX     r0,r0,#2,#2           ;334
00013a  2802              CMP      r0,#2                 ;334
00013c  d11c              BNE      |L14.376|
00013e  6868              LDR      r0,[r5,#4]            ;334
000140  03c0              LSLS     r0,r0,#15             ;334
000142  d419              BMI      |L14.376|
                  |L14.324|
000144  fa97f0a7          RBIT     r0,r7                 ;337
000148  fab0f080          CLZ      r0,r0                 ;337
00014c  f0400020          ORR      r0,r0,#0x20           ;337
000150  0940              LSRS     r0,r0,#5              ;337
000152  d002              BEQ      |L14.346|
000154  6828              LDR      r0,[r5,#0]            ;337
000156  e001              B        |L14.348|
                  |L14.344|
000158  e08b              B        |L14.626|
                  |L14.346|
00015a  6a68              LDR      r0,[r5,#0x24]         ;337
                  |L14.348|
00015c  fa97f1a7          RBIT     r1,r7                 ;337
000160  fab1f181          CLZ      r1,r1                 ;337
000164  f001011f          AND      r1,r1,#0x1f           ;337
000168  fa06f101          LSL      r1,r6,r1              ;337
00016c  4208              TST      r0,r1                 ;337
00016e  d02c              BEQ      |L14.458|
000170  6920              LDR      r0,[r4,#0x10]         ;337
000172  2801              CMP      r0,#1                 ;337
000174  d17d              BNE      |L14.626|
000176  e028              B        |L14.458|
                  |L14.376|
000178  6920              LDR      r0,[r4,#0x10]         ;351
00017a  b390              CBZ      r0,|L14.482|
00017c  fa96f0a6          RBIT     r0,r6
000180  fab0f080          CLZ      r0,r0
000184  f8486020          STR      r6,[r8,r0,LSL #2]
;;;355            
;;;356            /* Get Start Tick */
;;;357            tickstart = HAL_GetTick();
000188  f7fffffe          BL       HAL_GetTick
00018c  4682              MOV      r10,r0
;;;358            
;;;359            /* Wait till HSI is ready */
;;;360            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
00018e  e007              B        |L14.416|
                  |L14.400|
000190  e111              B        |L14.950|
;;;361            {
;;;362              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
000192  bf00              NOP      
                  |L14.404|
000194  f7fffffe          BL       HAL_GetTick
000198  eba0000a          SUB      r0,r0,r10
00019c  2802              CMP      r0,#2
                  |L14.414|
00019e  d884              BHI      |L14.170|
                  |L14.416|
0001a0  fa97f0a7          RBIT     r0,r7                 ;360
0001a4  fab0f080          CLZ      r0,r0                 ;360
0001a8  f0400020          ORR      r0,r0,#0x20           ;360
0001ac  0940              LSRS     r0,r0,#5              ;360
0001ae  d001              BEQ      |L14.436|
0001b0  6828              LDR      r0,[r5,#0]            ;360
0001b2  e000              B        |L14.438|
                  |L14.436|
0001b4  6a68              LDR      r0,[r5,#0x24]         ;360
                  |L14.438|
0001b6  fa97f1a7          RBIT     r1,r7                 ;360
0001ba  fab1f181          CLZ      r1,r1                 ;360
0001be  f001011f          AND      r1,r1,#0x1f           ;360
0001c2  fa06f101          LSL      r1,r6,r1              ;360
0001c6  4208              TST      r0,r1                 ;360
0001c8  d0e4              BEQ      |L14.404|
                  |L14.458|
;;;363              {
;;;364                return HAL_TIMEOUT;
;;;365              }
;;;366            }
;;;367                    
;;;368            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;369            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
0001ca  6828              LDR      r0,[r5,#0]
0001cc  fa9bf2ab          RBIT     r2,r11
0001d0  6961              LDR      r1,[r4,#0x14]
0001d2  fab2f282          CLZ      r2,r2
0001d6  f02000f8          BIC      r0,r0,#0xf8
0001da  4091              LSLS     r1,r1,r2
0001dc  4308              ORRS     r0,r0,r1
0001de  6028              STR      r0,[r5,#0]
                  |L14.480|
0001e0  e025              B        |L14.558|
                  |L14.482|
0001e2  e7ff              B        |L14.484|
                  |L14.484|
;;;370          }
;;;371          else
;;;372          {
;;;373            /* Disable the Internal High Speed oscillator (HSI). */
;;;374            __HAL_RCC_HSI_DISABLE();
0001e4  fa96f1a6          RBIT     r1,r6
0001e8  fab1f181          CLZ      r1,r1
0001ec  f8489021          STR      r9,[r8,r1,LSL #2]
;;;375            
;;;376            /* Get Start Tick */
;;;377            tickstart = HAL_GetTick();
0001f0  f7fffffe          BL       HAL_GetTick
0001f4  4682              MOV      r10,r0
;;;378            
;;;379            /* Wait till HSI is disabled */
;;;380            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
0001f6  e005              B        |L14.516|
                  |L14.504|
;;;381            {
;;;382              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
0001f8  f7fffffe          BL       HAL_GetTick
0001fc  eba0000a          SUB      r0,r0,r10
000200  2802              CMP      r0,#2
000202  d8cc              BHI      |L14.414|
                  |L14.516|
000204  fa97f0a7          RBIT     r0,r7                 ;380
000208  fab0f080          CLZ      r0,r0                 ;380
00020c  f0400020          ORR      r0,r0,#0x20           ;380
000210  0940              LSRS     r0,r0,#5              ;380
000212  d001              BEQ      |L14.536|
000214  6828              LDR      r0,[r5,#0]            ;380
000216  e000              B        |L14.538|
                  |L14.536|
000218  6a68              LDR      r0,[r5,#0x24]         ;380
                  |L14.538|
00021a  fa97f1a7          RBIT     r1,r7                 ;380
00021e  fab1f181          CLZ      r1,r1                 ;380
000222  f001011f          AND      r1,r1,#0x1f           ;380
000226  fa06f101          LSL      r1,r6,r1              ;380
00022a  4208              TST      r0,r1                 ;380
00022c  d1e4              BNE      |L14.504|
                  |L14.558|
;;;383              {
;;;384                return HAL_TIMEOUT;
;;;385              }
;;;386            }
;;;387          }
;;;388        }
;;;389      }
;;;390      /*------------------------------ LSI Configuration -------------------------*/ 
;;;391      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
00022e  7820              LDRB     r0,[r4,#0]
000230  0700              LSLS     r0,r0,#28
000232  d56e              BPL      |L14.786|
;;;392      {
;;;393        /* Check the parameters */
;;;394        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;395        
;;;396        /* Check the LSI State */
;;;397        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
000234  69a0              LDR      r0,[r4,#0x18]
000236  b3b8              CBZ      r0,|L14.680|
;;;398        {
;;;399          /* Enable the Internal Low Speed oscillator (LSI). */
;;;400          __HAL_RCC_LSI_ENABLE();
000238  fa96f0a6          RBIT     r0,r6
00023c  fab0f080          CLZ      r0,r0
000240  eb080080          ADD      r0,r8,r0,LSL #2
000244  f8c06480          STR      r6,[r0,#0x480]
;;;401          
;;;402          /* Get Start Tick */
;;;403          tickstart = HAL_GetTick();
000248  f7fffffe          BL       HAL_GetTick
00024c  4682              MOV      r10,r0
;;;404          
;;;405          /* Wait till LSI is ready */  
;;;406          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
00024e  e005              B        |L14.604|
                  |L14.592|
;;;407          {
;;;408            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
000250  f7fffffe          BL       HAL_GetTick
000254  eba0000a          SUB      r0,r0,r10
000258  2802              CMP      r0,#2
00025a  d8a0              BHI      |L14.414|
                  |L14.604|
00025c  fa97f0a7          RBIT     r0,r7                 ;406
000260  fab0f080          CLZ      r0,r0                 ;406
000264  f0400060          ORR      r0,r0,#0x60           ;406
000268  ebb61f50          CMP      r6,r0,LSR #5          ;406
00026c  d102              BNE      |L14.628|
00026e  6828              LDR      r0,[r5,#0]            ;406
000270  e00c              B        |L14.652|
                  |L14.626|
000272  e162              B        |L14.1338|
                  |L14.628|
000274  fa97f0a7          RBIT     r0,r7                 ;406
000278  fab0f080          CLZ      r0,r0                 ;406
00027c  f0400060          ORR      r0,r0,#0x60           ;406
000280  ebb71f50          CMP      r7,r0,LSR #5          ;406
000284  d101              BNE      |L14.650|
000286  6a28              LDR      r0,[r5,#0x20]         ;406
000288  e000              B        |L14.652|
                  |L14.650|
00028a  6a68              LDR      r0,[r5,#0x24]         ;406
                  |L14.652|
00028c  fa97f1a7          RBIT     r1,r7                 ;406
000290  fab1f181          CLZ      r1,r1                 ;406
000294  f001011f          AND      r1,r1,#0x1f           ;406
000298  fa06f201          LSL      r2,r6,r1              ;406
00029c  4210              TST      r0,r2                 ;406
00029e  d0d7              BEQ      |L14.592|
;;;409            {
;;;410              return HAL_TIMEOUT;
;;;411            }
;;;412          }
;;;413          /*  To have a fully stabilized clock in the specified range, a software delay of 1ms 
;;;414              should be added.*/
;;;415          HAL_Delay(1);
0002a0  2001              MOVS     r0,#1
0002a2  f7fffffe          BL       HAL_Delay
0002a6  e034              B        |L14.786|
                  |L14.680|
0002a8  e7ff              B        |L14.682|
                  |L14.682|
;;;416        }
;;;417        else
;;;418        {
;;;419          /* Disable the Internal Low Speed oscillator (LSI). */
;;;420          __HAL_RCC_LSI_DISABLE();
0002aa  fa96f1a6          RBIT     r1,r6
0002ae  fab1f181          CLZ      r1,r1
0002b2  eb080181          ADD      r1,r8,r1,LSL #2
0002b6  f8c19480          STR      r9,[r1,#0x480]
;;;421          
;;;422          /* Get Start Tick */
;;;423          tickstart = HAL_GetTick();
0002ba  f7fffffe          BL       HAL_GetTick
0002be  4682              MOV      r10,r0
;;;424          
;;;425          /* Wait till LSI is disabled */  
;;;426          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
0002c0  e006              B        |L14.720|
;;;427          {
;;;428            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
0002c2  bf00              NOP      
                  |L14.708|
0002c4  f7fffffe          BL       HAL_GetTick
0002c8  eba0000a          SUB      r0,r0,r10
0002cc  2802              CMP      r0,#2
0002ce  d872              BHI      |L14.950|
                  |L14.720|
0002d0  fa97f0a7          RBIT     r0,r7                 ;426
0002d4  fab0f080          CLZ      r0,r0                 ;426
0002d8  f0400060          ORR      r0,r0,#0x60           ;426
0002dc  ebb61f50          CMP      r6,r0,LSR #5          ;426
0002e0  d101              BNE      |L14.742|
0002e2  6828              LDR      r0,[r5,#0]            ;426
0002e4  e00b              B        |L14.766|
                  |L14.742|
0002e6  fa97f0a7          RBIT     r0,r7                 ;426
0002ea  fab0f080          CLZ      r0,r0                 ;426
0002ee  f0400060          ORR      r0,r0,#0x60           ;426
0002f2  ebb71f50          CMP      r7,r0,LSR #5          ;426
0002f6  d101              BNE      |L14.764|
0002f8  6a28              LDR      r0,[r5,#0x20]         ;426
0002fa  e000              B        |L14.766|
                  |L14.764|
0002fc  6a68              LDR      r0,[r5,#0x24]         ;426
                  |L14.766|
0002fe  fa97f1a7          RBIT     r1,r7                 ;426
000302  fab1f181          CLZ      r1,r1                 ;426
000306  f001011f          AND      r1,r1,#0x1f           ;426
00030a  fa06f201          LSL      r2,r6,r1              ;426
00030e  4210              TST      r0,r2                 ;426
000310  d1d8              BNE      |L14.708|
                  |L14.786|
;;;429            {
;;;430              return HAL_TIMEOUT;
;;;431            }
;;;432          }
;;;433        }
;;;434      }
;;;435      /*------------------------------ LSE Configuration -------------------------*/ 
;;;436      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
000312  7820              LDRB     r0,[r4,#0]
000314  0740              LSLS     r0,r0,#29
000316  d565              BPL      |L14.996|
;;;437      {
;;;438        /* Check the parameters */
;;;439        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;440    
;;;441        /* Enable Power Clock*/
;;;442          __HAL_RCC_PWR_CLK_ENABLE();
000318  69e8              LDR      r0,[r5,#0x1c]
00031a  f0405080          ORR      r0,r0,#0x10000000
00031e  61e8              STR      r0,[r5,#0x1c]
000320  69e8              LDR      r0,[r5,#0x1c]
;;;443        
;;;444          /* Enable write access to Backup domain */
;;;445          SET_BIT(PWR->CR, PWR_CR_DBP);
000322  f8dfb0cc          LDR      r11,|L14.1008|
000326  f0005080          AND      r0,r0,#0x10000000     ;442
00032a  9000              STR      r0,[sp,#0]
00032c  f8db1000          LDR      r1,[r11,#0]
000330  f4417180          ORR      r1,r1,#0x100
000334  f8cb1000          STR      r1,[r11,#0]
;;;446          
;;;447          /* Wait for Backup domain Write protection disable */
;;;448          tickstart = HAL_GetTick();
000338  f7fffffe          BL       HAL_GetTick
00033c  4682              MOV      r10,r0
;;;449    
;;;450        while((PWR->CR & PWR_CR_DBP) == RESET)
00033e  e005              B        |L14.844|
                  |L14.832|
;;;451          {
;;;452            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000340  f7fffffe          BL       HAL_GetTick
000344  eba0000a          SUB      r0,r0,r10
000348  2864              CMP      r0,#0x64
00034a  d834              BHI      |L14.950|
                  |L14.844|
00034c  f8db0000          LDR      r0,[r11,#0]           ;450
000350  05c0              LSLS     r0,r0,#23             ;450
000352  d5f5              BPL      |L14.832|
;;;453            {
;;;454              return HAL_TIMEOUT;
;;;455            }
;;;456          }
;;;457    
;;;458        /* Set the new LSE configuration -----------------------------------------*/
;;;459        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
000354  68e0              LDR      r0,[r4,#0xc]
000356  2801              CMP      r0,#1
000358  d00a              BEQ      |L14.880|
00035a  b108              CBZ      r0,|L14.864|
00035c  2805              CMP      r0,#5
00035e  d013              BEQ      |L14.904|
                  |L14.864|
000360  6a28              LDR      r0,[r5,#0x20]
000362  f0200001          BIC      r0,r0,#1
000366  6228              STR      r0,[r5,#0x20]
000368  6a28              LDR      r0,[r5,#0x20]
00036a  f0200004          BIC      r0,r0,#4
00036e  e002              B        |L14.886|
                  |L14.880|
000370  6a28              LDR      r0,[r5,#0x20]
000372  f0400001          ORR      r0,r0,#1
                  |L14.886|
000376  6228              STR      r0,[r5,#0x20]
;;;460        /* Check the LSE State */
;;;461        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
;;;462        {
;;;463          /* Get Start Tick */
;;;464          tickstart = HAL_GetTick();
;;;465          
;;;466          /* Wait till LSE is ready */  
;;;467          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;468          {
;;;469            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000378  68e0              LDR      r0,[r4,#0xc]
00037a  f2413b88          MOV      r11,#0x1388
00037e  b390              CBZ      r0,|L14.998|
000380  f7fffffe          BL       HAL_GetTick
000384  4682              MOV      r10,r0                ;464
000386  e00b              B        |L14.928|
                  |L14.904|
000388  6a28              LDR      r0,[r5,#0x20]         ;459
00038a  f0400004          ORR      r0,r0,#4              ;459
00038e  6228              STR      r0,[r5,#0x20]         ;459
000390  e7ee              B        |L14.880|
000392  bf00              NOP      
                  |L14.916|
000394  f7fffffe          BL       HAL_GetTick
000398  eba0010a          SUB      r1,r0,r10
00039c  4559              CMP      r1,r11
00039e  d80a              BHI      |L14.950|
                  |L14.928|
0003a0  fa97f0a7          RBIT     r0,r7                 ;467
0003a4  fab0f080          CLZ      r0,r0                 ;467
0003a8  f0400040          ORR      r0,r0,#0x40           ;467
0003ac  ebb61f50          CMP      r6,r0,LSR #5          ;467
0003b0  d102              BNE      |L14.952|
0003b2  6828              LDR      r0,[r5,#0]            ;467
0003b4  e00c              B        |L14.976|
                  |L14.950|
0003b6  e0a3              B        |L14.1280|
                  |L14.952|
0003b8  fa97f0a7          RBIT     r0,r7                 ;467
0003bc  fab0f080          CLZ      r0,r0                 ;467
0003c0  f0400040          ORR      r0,r0,#0x40           ;467
0003c4  ebb71f50          CMP      r7,r0,LSR #5          ;467
0003c8  d101              BNE      |L14.974|
0003ca  6a28              LDR      r0,[r5,#0x20]         ;467
0003cc  e000              B        |L14.976|
                  |L14.974|
0003ce  6a68              LDR      r0,[r5,#0x24]         ;467
                  |L14.976|
0003d0  fa97f1a7          RBIT     r1,r7                 ;467
0003d4  fab1f181          CLZ      r1,r1                 ;467
0003d8  f001021f          AND      r2,r1,#0x1f           ;467
0003dc  fa06f102          LSL      r1,r6,r2              ;467
0003e0  4208              TST      r0,r1                 ;467
0003e2  d0d7              BEQ      |L14.916|
                  |L14.996|
0003e4  e031              B        |L14.1098|
                  |L14.998|
0003e6  e005              B        |L14.1012|
                  |L14.1000|
                          DCD      0x40021000
                  |L14.1004|
                          DCD      0x42420000
                  |L14.1008|
                          DCD      0x40007000
                  |L14.1012|
;;;470            {
;;;471              return HAL_TIMEOUT;
;;;472            }
;;;473          }
;;;474        }
;;;475        else
;;;476        {
;;;477          /* Get Start Tick */
;;;478          tickstart = HAL_GetTick();
0003f4  f7fffffe          BL       HAL_GetTick
0003f8  4682              MOV      r10,r0
;;;479          
;;;480          /* Wait till LSE is disabled */  
;;;481          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0003fa  e005              B        |L14.1032|
                  |L14.1020|
;;;482          {
;;;483            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0003fc  f7fffffe          BL       HAL_GetTick
000400  eba0010a          SUB      r1,r0,r10
000404  4559              CMP      r1,r11
000406  d87b              BHI      |L14.1280|
                  |L14.1032|
000408  fa97f0a7          RBIT     r0,r7                 ;481
00040c  fab0f080          CLZ      r0,r0                 ;481
000410  f0400040          ORR      r0,r0,#0x40           ;481
000414  ebb61f50          CMP      r6,r0,LSR #5          ;481
000418  d101              BNE      |L14.1054|
00041a  6828              LDR      r0,[r5,#0]            ;481
00041c  e00b              B        |L14.1078|
                  |L14.1054|
00041e  fa97f0a7          RBIT     r0,r7                 ;481
000422  fab0f080          CLZ      r0,r0                 ;481
000426  f0400040          ORR      r0,r0,#0x40           ;481
00042a  ebb71f50          CMP      r7,r0,LSR #5          ;481
00042e  d101              BNE      |L14.1076|
000430  6a28              LDR      r0,[r5,#0x20]         ;481
000432  e000              B        |L14.1078|
                  |L14.1076|
000434  6a68              LDR      r0,[r5,#0x24]         ;481
                  |L14.1078|
000436  fa97f1a7          RBIT     r1,r7                 ;481
00043a  fab1f181          CLZ      r1,r1                 ;481
00043e  f001021f          AND      r2,r1,#0x1f           ;481
000442  fa06f102          LSL      r1,r6,r2              ;481
000446  4208              TST      r0,r1                 ;481
000448  d1d8              BNE      |L14.1020|
                  |L14.1098|
;;;484            {
;;;485              return HAL_TIMEOUT;
;;;486            }
;;;487          }
;;;488        }
;;;489      }
;;;490    
;;;491    #if defined(RCC_CR_PLL2ON)
;;;492      /*-------------------------------- PLL2 Configuration -----------------------*/
;;;493      /* Check the parameters */
;;;494      assert_param(IS_RCC_PLL2(RCC_OscInitStruct->PLL2.PLL2State));
;;;495      if ((RCC_OscInitStruct->PLL2.PLL2State) != RCC_PLL2_NONE)
;;;496      {
;;;497        /* This bit can not be cleared if the PLL2 clock is used indirectly as system 
;;;498          clock (i.e. it is used as PLL clock entry that is used as system clock). */
;;;499        if((__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE) && \
;;;500            (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && \
;;;501            ((READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC)) == RCC_CFGR2_PREDIV1SRC_PLL2))
;;;502        {
;;;503          return HAL_ERROR;
;;;504        }
;;;505        else
;;;506        {
;;;507          if((RCC_OscInitStruct->PLL2.PLL2State) == RCC_PLL2_ON)
;;;508          {
;;;509            /* Check the parameters */
;;;510            assert_param(IS_RCC_PLL2_MUL(RCC_OscInitStruct->PLL2.PLL2MUL));
;;;511            assert_param(IS_RCC_HSE_PREDIV2(RCC_OscInitStruct->PLL2.HSEPrediv2Value));
;;;512    
;;;513            /* Prediv2 can be written only when the PLLI2S is disabled. */
;;;514            /* Return an error only if new value is different from the programmed value */
;;;515            if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL3ON) && \
;;;516              (__HAL_RCC_HSE_GET_PREDIV2() != RCC_OscInitStruct->PLL2.HSEPrediv2Value))
;;;517            {
;;;518              return HAL_ERROR;
;;;519            }
;;;520            
;;;521            /* Disable the main PLL2. */
;;;522            __HAL_RCC_PLL2_DISABLE();
;;;523            
;;;524            /* Get Start Tick */
;;;525            tickstart = HAL_GetTick();
;;;526            
;;;527            /* Wait till PLL2 is disabled */
;;;528            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
;;;529            {
;;;530              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;531              {
;;;532                return HAL_TIMEOUT;
;;;533              }
;;;534            }
;;;535            
;;;536            /* Configure the HSE prediv2 factor --------------------------------*/
;;;537            __HAL_RCC_HSE_PREDIV2_CONFIG(RCC_OscInitStruct->PLL2.HSEPrediv2Value);
;;;538    
;;;539            /* Configure the main PLL2 multiplication factors. */
;;;540            __HAL_RCC_PLL2_CONFIG(RCC_OscInitStruct->PLL2.PLL2MUL);
;;;541            
;;;542            /* Enable the main PLL2. */
;;;543            __HAL_RCC_PLL2_ENABLE();
;;;544            
;;;545            /* Get Start Tick */
;;;546            tickstart = HAL_GetTick();
;;;547            
;;;548            /* Wait till PLL2 is ready */
;;;549            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  == RESET)
;;;550            {
;;;551              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;552              {
;;;553                return HAL_TIMEOUT;
;;;554              }
;;;555            }
;;;556          }
;;;557          else
;;;558          {
;;;559           /* Set PREDIV1 source to HSE */
;;;560            CLEAR_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC);
;;;561    
;;;562            /* Disable the main PLL2. */
;;;563            __HAL_RCC_PLL2_DISABLE();
;;;564     
;;;565            /* Get Start Tick */
;;;566            tickstart = HAL_GetTick();
;;;567            
;;;568            /* Wait till PLL2 is disabled */  
;;;569            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  != RESET)
;;;570            {
;;;571              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;572              {
;;;573                return HAL_TIMEOUT;
;;;574              }
;;;575            }
;;;576          }
;;;577        }
;;;578      }
;;;579    
;;;580    #endif /* RCC_CR_PLL2ON */
;;;581      /*-------------------------------- PLL Configuration -----------------------*/
;;;582      /* Check the parameters */
;;;583      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;584      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
00044a  69e0              LDR      r0,[r4,#0x1c]
00044c  b380              CBZ      r0,|L14.1200|
;;;585      {
;;;586        /* Check if the PLL is used as system clock or not */
;;;587        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
00044e  6869              LDR      r1,[r5,#4]
000450  f3c10181          UBFX     r1,r1,#2,#2
000454  2902              CMP      r1,#2
000456  d070              BEQ      |L14.1338|
;;;588        { 
;;;589          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
;;;590          {
;;;591            /* Check the parameters */
;;;592            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;593            assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
;;;594      
;;;595            /* Disable the main PLL. */
;;;596            __HAL_RCC_PLL_DISABLE();
000458  f04f7180          MOV      r1,#0x1000000
;;;597            
;;;598            /* Get Start Tick */
;;;599            tickstart = HAL_GetTick();
;;;600            
;;;601            /* Wait till PLL is disabled */
;;;602            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
00045c  004f              LSLS     r7,r1,#1
00045e  2802              CMP      r0,#2                 ;589
;;;603            {
;;;604              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;605              {
;;;606                return HAL_TIMEOUT;
;;;607              }
;;;608            }
;;;609    
;;;610            /* Configure the HSE prediv factor --------------------------------*/
;;;611            /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
;;;612            if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
;;;613            {
;;;614              /* Check the parameter */
;;;615              assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
;;;616    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;617              assert_param(IS_RCC_PREDIV1_SOURCE(RCC_OscInitStruct->Prediv1Source));
;;;618              
;;;619              /* Set PREDIV1 source */
;;;620              SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
;;;621    #endif /* RCC_CFGR2_PREDIV1SRC */
;;;622    
;;;623              /* Set PREDIV1 Value */
;;;624              __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
;;;625            }
;;;626    
;;;627            /* Configure the main PLL clock source and multiplication factors. */
;;;628            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;629                                 RCC_OscInitStruct->PLL.PLLMUL);
;;;630            /* Enable the main PLL. */
;;;631            __HAL_RCC_PLL_ENABLE();
;;;632            
;;;633            /* Get Start Tick */
;;;634            tickstart = HAL_GetTick();
;;;635            
;;;636            /* Wait till PLL is ready */
;;;637            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
;;;638            {
;;;639              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;640              {
;;;641                return HAL_TIMEOUT;
;;;642              }
;;;643            }
;;;644          }
;;;645          else
;;;646          {
;;;647            /* Disable the main PLL. */
;;;648            __HAL_RCC_PLL_DISABLE();
000460  4648              MOV      r0,r9
000462  d009              BEQ      |L14.1144|
000464  fa91f1a1          RBIT     r1,r1
000468  fab1f181          CLZ      r1,r1
00046c  f8480021          STR      r0,[r8,r1,LSL #2]
;;;649     
;;;650            /* Get Start Tick */
;;;651            tickstart = HAL_GetTick();
000470  f7fffffe          BL       HAL_GetTick
000474  4604              MOV      r4,r0
;;;652            
;;;653            /* Wait till PLL is disabled */  
;;;654            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
000476  e069              B        |L14.1356|
                  |L14.1144|
000478  468a              MOV      r10,r1                ;596
00047a  fa91f1a1          RBIT     r1,r1                 ;596
00047e  fab1f181          CLZ      r1,r1                 ;596
000482  46c1              MOV      r9,r8                 ;596
000484  f8480021          STR      r0,[r8,r1,LSL #2]     ;596
000488  f7fffffe          BL       HAL_GetTick
00048c  4680              MOV      r8,r0                 ;599
00048e  e005              B        |L14.1180|
                  |L14.1168|
000490  f7fffffe          BL       HAL_GetTick
000494  eba00008          SUB      r0,r0,r8              ;604
000498  2802              CMP      r0,#2                 ;604
00049a  d854              BHI      |L14.1350|
                  |L14.1180|
00049c  fa97f0a7          RBIT     r0,r7                 ;602
0004a0  fab0f080          CLZ      r0,r0                 ;602
0004a4  f0400020          ORR      r0,r0,#0x20           ;602
0004a8  0940              LSRS     r0,r0,#5              ;602
0004aa  d002              BEQ      |L14.1202|
0004ac  6828              LDR      r0,[r5,#0]            ;602
0004ae  e001              B        |L14.1204|
                  |L14.1200|
0004b0  e061              B        |L14.1398|
                  |L14.1202|
0004b2  6a68              LDR      r0,[r5,#0x24]         ;602
                  |L14.1204|
0004b4  fa97f1a7          RBIT     r1,r7                 ;602
0004b8  fab1f181          CLZ      r1,r1                 ;602
0004bc  f001011f          AND      r1,r1,#0x1f           ;602
0004c0  fa06f101          LSL      r1,r6,r1              ;602
0004c4  4208              TST      r0,r1                 ;602
0004c6  d1e3              BNE      |L14.1168|
0004c8  6a20              LDR      r0,[r4,#0x20]         ;612
0004ca  f5b03f80          CMP      r0,#0x10000           ;612
0004ce  d105              BNE      |L14.1244|
0004d0  6868              LDR      r0,[r5,#4]            ;624
0004d2  68a1              LDR      r1,[r4,#8]            ;624
0004d4  f4203000          BIC      r0,r0,#0x20000        ;624
0004d8  4308              ORRS     r0,r0,r1              ;624
0004da  6068              STR      r0,[r5,#4]            ;624
                  |L14.1244|
0004dc  e9d40108          LDRD     r0,r1,[r4,#0x20]      ;624
0004e0  4308              ORRS     r0,r0,r1              ;628
0004e2  6869              LDR      r1,[r5,#4]            ;628
0004e4  f4211174          BIC      r1,r1,#0x3d0000       ;628
0004e8  4308              ORRS     r0,r0,r1              ;628
0004ea  6068              STR      r0,[r5,#4]            ;628
0004ec  fa9af0aa          RBIT     r0,r10                ;631
0004f0  fab0f080          CLZ      r0,r0                 ;631
0004f4  f8496020          STR      r6,[r9,r0,LSL #2]     ;631
0004f8  f7fffffe          BL       HAL_GetTick
0004fc  4604              MOV      r4,r0                 ;634
0004fe  e006              B        |L14.1294|
                  |L14.1280|
000500  e021              B        |L14.1350|
000502  bf00              NOP                            ;639
                  |L14.1284|
000504  f7fffffe          BL       HAL_GetTick
000508  1b00              SUBS     r0,r0,r4              ;639
00050a  2802              CMP      r0,#2                 ;639
00050c  d81b              BHI      |L14.1350|
                  |L14.1294|
00050e  fa97f0a7          RBIT     r0,r7                 ;637
000512  fab0f080          CLZ      r0,r0                 ;637
000516  f0400020          ORR      r0,r0,#0x20           ;637
00051a  0940              LSRS     r0,r0,#5              ;637
00051c  d001              BEQ      |L14.1314|
00051e  6828              LDR      r0,[r5,#0]            ;637
000520  e000              B        |L14.1316|
                  |L14.1314|
000522  6a68              LDR      r0,[r5,#0x24]         ;637
                  |L14.1316|
000524  fa97f1a7          RBIT     r1,r7                 ;637
000528  fab1f181          CLZ      r1,r1                 ;637
00052c  f001011f          AND      r1,r1,#0x1f           ;637
000530  fa06f101          LSL      r1,r6,r1              ;637
000534  4208              TST      r0,r1                 ;637
000536  d0e5              BEQ      |L14.1284|
000538  e01d              B        |L14.1398|
                  |L14.1338|
00053a  e01e              B        |L14.1402|
                  |L14.1340|
;;;655            {
;;;656              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
00053c  f7fffffe          BL       HAL_GetTick
000540  1b00              SUBS     r0,r0,r4
000542  2802              CMP      r0,#2
000544  d902              BLS      |L14.1356|
                  |L14.1350|
;;;657              {
;;;658                return HAL_TIMEOUT;
000546  2003              MOVS     r0,#3
                  |L14.1352|
;;;659              }
;;;660            }
;;;661          }
;;;662        }
;;;663        else
;;;664        {
;;;665          return HAL_ERROR;
;;;666        }
;;;667      }
;;;668      
;;;669      return HAL_OK;
;;;670    }
000548  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.1356|
00054c  fa97f0a7          RBIT     r0,r7                 ;654
000550  fab0f080          CLZ      r0,r0                 ;654
000554  f0400020          ORR      r0,r0,#0x20           ;654
000558  0940              LSRS     r0,r0,#5              ;654
00055a  d001              BEQ      |L14.1376|
00055c  6828              LDR      r0,[r5,#0]            ;654
00055e  e000              B        |L14.1378|
                  |L14.1376|
000560  6a68              LDR      r0,[r5,#0x24]         ;654
                  |L14.1378|
000562  fa97f1a7          RBIT     r1,r7                 ;654
000566  fab1f181          CLZ      r1,r1                 ;654
00056a  f001011f          AND      r1,r1,#0x1f           ;654
00056e  fa06f101          LSL      r1,r6,r1              ;654
000572  4208              TST      r0,r1                 ;654
000574  d1e2              BNE      |L14.1340|
                  |L14.1398|
000576  2000              MOVS     r0,#0                 ;669
000578  e7e6              B        |L14.1352|
                  |L14.1402|
00057a  2001              MOVS     r0,#1                 ;665
00057c  e7e4              B        |L14.1352|
;;;671    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX|
#line 587
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
