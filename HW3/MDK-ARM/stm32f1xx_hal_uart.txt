; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\stm32f1xx_hal_uart.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\stm32f1xx_hal_uart.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1469     */
;;;1470   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1471   {
;;;1472     /* Process Locked */
;;;1473     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L1.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1474     
;;;1475     huart->State = HAL_UART_STATE_BUSY;
00000e  2202              MOVS     r2,#2
000010  7042              STRB     r2,[r0,#1]
;;;1476   
;;;1477     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1478     /* Clear TE and RE bits */
;;;1479     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1480     MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
000012  f8502c38          LDR      r2,[r0,#-0x38]
000016  68d3              LDR      r3,[r2,#0xc]
000018  f023030c          BIC      r3,r3,#0xc
00001c  1d1b              ADDS     r3,r3,#4
00001e  60d3              STR      r3,[r2,#0xc]
;;;1481     
;;;1482     huart->State = HAL_UART_STATE_READY;
000020  7041              STRB     r1,[r0,#1]
;;;1483     
;;;1484     /* Process Unlocked */
;;;1485     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1486     
;;;1487     return HAL_OK; 
000026  4608              MOV      r0,r1
;;;1488   }
000028  4770              BX       lr
                  |L1.42|
00002a  2002              MOVS     r0,#2                 ;1473
00002c  4770              BX       lr
;;;1489   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1443     */
;;;1444   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1445   {
;;;1446     /* Process Locked */
;;;1447     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d011              BEQ      |L2.44|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1448     
;;;1449     huart->State = HAL_UART_STATE_BUSY;
00000e  2202              MOVS     r2,#2
000010  7042              STRB     r2,[r0,#1]
;;;1450   
;;;1451     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1452     /* Clear TE and RE bits */
;;;1453     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1454     MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
000012  f8502c38          LDR      r2,[r0,#-0x38]
000016  68d3              LDR      r3,[r2,#0xc]
000018  f023030c          BIC      r3,r3,#0xc
00001c  f0430308          ORR      r3,r3,#8
000020  60d3              STR      r3,[r2,#0xc]
;;;1455    
;;;1456     huart->State = HAL_UART_STATE_READY;
000022  7041              STRB     r1,[r0,#1]
;;;1457     
;;;1458     /* Process Unlocked */
;;;1459     __HAL_UNLOCK(huart);
000024  2100              MOVS     r1,#0
000026  7001              STRB     r1,[r0,#0]
;;;1460     
;;;1461     return HAL_OK; 
000028  4608              MOV      r0,r1
;;;1462   }
00002a  4770              BX       lr
                  |L2.44|
00002c  2002              MOVS     r0,#2                 ;1447
00002e  4770              BX       lr
;;;1463   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;312      */
;;;313    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;314    {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L3.16|
;;;315      /* Check the UART handle allocation */
;;;316      if(huart == NULL)
;;;317      {
;;;318        return HAL_ERROR;
;;;319      }
;;;320      
;;;321      /* Check UART instance */
;;;322      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;323      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;324      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;325    
;;;326      if(huart->State == HAL_UART_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  2500              MOVS     r5,#0
00000c  b110              CBZ      r0,|L3.20|
00000e  e006              B        |L3.30|
                  |L3.16|
000010  2001              MOVS     r0,#1                 ;318
;;;327      {   
;;;328        /* Allocate lock resource and initialize it */
;;;329        huart->Lock = HAL_UNLOCKED;
;;;330    
;;;331        /* Init the low level hardware */
;;;332        HAL_UART_MspInit(huart);
;;;333      }
;;;334    
;;;335      huart->State = HAL_UART_STATE_BUSY;
;;;336    
;;;337      /* Disable the peripheral */
;;;338      __HAL_UART_DISABLE(huart);
;;;339      
;;;340      /* Set the UART Communication parameters */
;;;341      UART_SetConfig(huart);
;;;342      
;;;343      /* In half-duplex mode, the following bits must be kept cleared: 
;;;344         - LINEN and CLKEN bits in the USART_CR2 register,
;;;345         - SCEN and IREN bits in the USART_CR3 register.*/
;;;346      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;347      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;348      
;;;349      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;350      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;351     
;;;352      /* Enable the peripheral */
;;;353      __HAL_UART_ENABLE(huart);
;;;354      
;;;355      /* Initialize the UART state*/
;;;356      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;357      huart->State= HAL_UART_STATE_READY;
;;;358      
;;;359      return HAL_OK;
;;;360    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  f8845038          STRB     r5,[r4,#0x38]         ;329
000018  4620              MOV      r0,r4                 ;332
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L3.30|
00001e  2002              MOVS     r0,#2                 ;335
000020  f8840039          STRB     r0,[r4,#0x39]         ;335
000024  6820              LDR      r0,[r4,#0]            ;338
000026  68c1              LDR      r1,[r0,#0xc]          ;338
000028  f4215100          BIC      r1,r1,#0x2000         ;338
00002c  60c1              STR      r1,[r0,#0xc]          ;338
00002e  4620              MOV      r0,r4                 ;341
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;346
000036  6901              LDR      r1,[r0,#0x10]         ;346
000038  f4214190          BIC      r1,r1,#0x4800         ;346
00003c  6101              STR      r1,[r0,#0x10]         ;346
00003e  6820              LDR      r0,[r4,#0]            ;347
000040  6941              LDR      r1,[r0,#0x14]         ;347
000042  f0210122          BIC      r1,r1,#0x22           ;347
000046  6141              STR      r1,[r0,#0x14]         ;347
000048  6820              LDR      r0,[r4,#0]            ;350
00004a  6941              LDR      r1,[r0,#0x14]         ;350
00004c  f0410108          ORR      r1,r1,#8              ;350
000050  6141              STR      r1,[r0,#0x14]         ;350
000052  6820              LDR      r0,[r4,#0]            ;353
000054  68c1              LDR      r1,[r0,#0xc]          ;353
000056  f4415100          ORR      r1,r1,#0x2000         ;353
00005a  60c1              STR      r1,[r0,#0xc]          ;353
00005c  63e5              STR      r5,[r4,#0x3c]         ;356
00005e  2001              MOVS     r0,#1                 ;357
000060  f8840039          STRB     r0,[r4,#0x39]         ;357
000064  2000              MOVS     r0,#0                 ;359
000066  bd70              POP      {r4-r6,pc}
;;;361    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;372      */
;;;373    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  d004              BEQ      |L4.18|
;;;375      /* Check the UART handle allocation */
;;;376      if(huart == NULL)
;;;377      {
;;;378        return HAL_ERROR;
;;;379      }
;;;380      
;;;381      /* Check the LIN UART instance */  
;;;382      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;383      /* Check the Break detection length parameter */
;;;384      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;385      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;386      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;387      
;;;388      if(huart->State == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L4.22|
000010  e006              B        |L4.32|
                  |L4.18|
000012  2001              MOVS     r0,#1                 ;378
;;;389      {   
;;;390        /* Allocate lock resource and initialize it */
;;;391        huart->Lock = HAL_UNLOCKED;  
;;;392    
;;;393        /* Init the low level hardware */
;;;394        HAL_UART_MspInit(huart);
;;;395      }
;;;396    
;;;397      huart->State = HAL_UART_STATE_BUSY;
;;;398    
;;;399      /* Disable the peripheral */
;;;400      __HAL_UART_DISABLE(huart);
;;;401      
;;;402      /* Set the UART Communication parameters */
;;;403      UART_SetConfig(huart);
;;;404      
;;;405      /* In LIN mode, the following bits must be kept cleared: 
;;;406         - CLKEN bits in the USART_CR2 register,
;;;407         - SCEN and IREN bits in the USART_CR3 register.*/
;;;408      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;409      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;410      
;;;411      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;412      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;413      
;;;414      /* Set the USART LIN Break detection length. */
;;;415      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;416      
;;;417      /* Enable the peripheral */
;;;418      __HAL_UART_ENABLE(huart);
;;;419      
;;;420      /* Initialize the UART state*/
;;;421      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;422      huart->State= HAL_UART_STATE_READY;
;;;423      
;;;424      return HAL_OK;
;;;425    }
000014  bd70              POP      {r4-r6,pc}
                  |L4.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;391
00001a  4620              MOV      r0,r4                 ;394
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L4.32|
000020  2002              MOVS     r0,#2                 ;397
000022  f8840039          STRB     r0,[r4,#0x39]         ;397
000026  6820              LDR      r0,[r4,#0]            ;400
000028  68c1              LDR      r1,[r0,#0xc]          ;400
00002a  f4215100          BIC      r1,r1,#0x2000         ;400
00002e  60c1              STR      r1,[r0,#0xc]          ;400
000030  4620              MOV      r0,r4                 ;403
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;408
000038  6901              LDR      r1,[r0,#0x10]         ;408
00003a  f4216100          BIC      r1,r1,#0x800          ;408
00003e  6101              STR      r1,[r0,#0x10]         ;408
000040  6820              LDR      r0,[r4,#0]            ;409
000042  6941              LDR      r1,[r0,#0x14]         ;409
000044  f021012a          BIC      r1,r1,#0x2a           ;409
000048  6141              STR      r1,[r0,#0x14]         ;409
00004a  6820              LDR      r0,[r4,#0]            ;412
00004c  6901              LDR      r1,[r0,#0x10]         ;412
00004e  f4414180          ORR      r1,r1,#0x4000         ;412
000052  6101              STR      r1,[r0,#0x10]         ;412
000054  6820              LDR      r0,[r4,#0]            ;415
000056  6901              LDR      r1,[r0,#0x10]         ;415
000058  f0210120          BIC      r1,r1,#0x20           ;415
00005c  4331              ORRS     r1,r1,r6              ;415
00005e  6101              STR      r1,[r0,#0x10]         ;415
000060  6820              LDR      r0,[r4,#0]            ;418
000062  68c1              LDR      r1,[r0,#0xc]          ;418
000064  f4415100          ORR      r1,r1,#0x2000         ;418
000068  60c1              STR      r1,[r0,#0xc]          ;418
00006a  63e5              STR      r5,[r4,#0x3c]         ;421
00006c  2001              MOVS     r0,#1                 ;422
00006e  f8840039          STRB     r0,[r4,#0x39]         ;422
000072  2000              MOVS     r0,#0                 ;424
000074  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1362     */
;;;1363   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1364   {
;;;1365     /* Check the parameters */
;;;1366     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1367     
;;;1368     /* Process Locked */
;;;1369     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00f              BEQ      |L5.40|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1370     
;;;1371     huart->State = HAL_UART_STATE_BUSY;
00000e  2202              MOVS     r2,#2
000010  7042              STRB     r2,[r0,#1]
;;;1372     
;;;1373     /* Send break characters */
;;;1374     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
000012  f8502c38          LDR      r2,[r0,#-0x38]
000016  68d3              LDR      r3,[r2,#0xc]
000018  f0430301          ORR      r3,r3,#1
00001c  60d3              STR      r3,[r2,#0xc]
;;;1375    
;;;1376     huart->State = HAL_UART_STATE_READY;
00001e  7041              STRB     r1,[r0,#1]
;;;1377     
;;;1378     /* Process Unlocked */
;;;1379     __HAL_UNLOCK(huart);
000020  2100              MOVS     r1,#0
000022  7001              STRB     r1,[r0,#0]
;;;1380     
;;;1381     return HAL_OK; 
000024  4608              MOV      r0,r1
;;;1382   }
000026  4770              BX       lr
                  |L5.40|
000028  2002              MOVS     r0,#2                 ;1369
00002a  4770              BX       lr
;;;1383   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1389     */
;;;1390   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1391   {
;;;1392     /* Check the parameters */
;;;1393     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1394     
;;;1395     /* Process Locked */
;;;1396     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00f              BEQ      |L6.40|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1397     
;;;1398     huart->State = HAL_UART_STATE_BUSY;
00000e  2202              MOVS     r2,#2
000010  7042              STRB     r2,[r0,#1]
;;;1399     
;;;1400     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1401     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8502c38          LDR      r2,[r0,#-0x38]
000016  68d3              LDR      r3,[r2,#0xc]
000018  f0430302          ORR      r3,r3,#2
00001c  60d3              STR      r3,[r2,#0xc]
;;;1402     
;;;1403     huart->State = HAL_UART_STATE_READY;
00001e  7041              STRB     r1,[r0,#1]
;;;1404     
;;;1405     /* Process Unlocked */
;;;1406     __HAL_UNLOCK(huart);
000020  2100              MOVS     r1,#0
000022  7001              STRB     r1,[r0,#0]
;;;1407     
;;;1408     return HAL_OK; 
000024  4608              MOV      r0,r1
;;;1409   }
000026  4770              BX       lr
                  |L6.40|
000028  2002              MOVS     r0,#2                 ;1396
00002a  4770              BX       lr
;;;1410   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1416     */
;;;1417   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1418   {
;;;1419     /* Check the parameters */
;;;1420     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1421     
;;;1422     /* Process Locked */
;;;1423     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00f              BEQ      |L7.40|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1424     
;;;1425     huart->State = HAL_UART_STATE_BUSY;
00000e  2202              MOVS     r2,#2
000010  7042              STRB     r2,[r0,#1]
;;;1426     
;;;1427     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1428     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8502c38          LDR      r2,[r0,#-0x38]
000016  68d3              LDR      r3,[r2,#0xc]
000018  f0230302          BIC      r3,r3,#2
00001c  60d3              STR      r3,[r2,#0xc]
;;;1429     
;;;1430     huart->State = HAL_UART_STATE_READY;
00001e  7041              STRB     r1,[r0,#1]
;;;1431     
;;;1432     /* Process Unlocked */
;;;1433     __HAL_UNLOCK(huart);
000020  2100              MOVS     r1,#0
000022  7001              STRB     r1,[r0,#0]
;;;1434     
;;;1435     return HAL_OK; 
000024  4608              MOV      r0,r1
;;;1436   }
000026  4770              BX       lr
                  |L7.40|
000028  2002              MOVS     r0,#2                 ;1423
00002a  4770              BX       lr
;;;1437   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;440    {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d004              BEQ      |L8.22|
;;;441      /* Check the UART handle allocation */
;;;442      if(huart == NULL)
;;;443      {
;;;444        return HAL_ERROR;
;;;445      }
;;;446    
;;;447      /* Check UART instance capabilities */  
;;;448      assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
;;;449    
;;;450      /* Check the Address & wake up method parameters */
;;;451      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;452      assert_param(IS_UART_ADDRESS(Address));
;;;453      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;454      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;455    
;;;456      if(huart->State == HAL_UART_STATE_RESET)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2500              MOVS     r5,#0
000012  b118              CBZ      r0,|L8.28|
000014  e007              B        |L8.38|
                  |L8.22|
000016  2001              MOVS     r0,#1                 ;444
                  |L8.24|
;;;457      {   
;;;458        /* Allocate lock resource and initialize it */
;;;459        huart->Lock = HAL_UNLOCKED;
;;;460    
;;;461        /* Init the low level hardware */
;;;462        HAL_UART_MspInit(huart);
;;;463      }
;;;464    
;;;465      huart->State = HAL_UART_STATE_BUSY;
;;;466    
;;;467      /* Disable the peripheral */
;;;468      __HAL_UART_DISABLE(huart);
;;;469      
;;;470      /* Set the UART Communication parameters */
;;;471      UART_SetConfig(huart);
;;;472      
;;;473      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;474         - LINEN and CLKEN bits in the USART_CR2 register,
;;;475         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;476      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;477      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;478      
;;;479      /* Set the USART address node */
;;;480      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
;;;481      
;;;482      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;483      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;484      
;;;485      /* Enable the peripheral */
;;;486      __HAL_UART_ENABLE(huart);
;;;487      
;;;488      /* Initialize the UART state */
;;;489      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;490      huart->State= HAL_UART_STATE_READY;
;;;491      
;;;492      return HAL_OK;
;;;493    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L8.28|
00001c  f8845038          STRB     r5,[r4,#0x38]         ;459
000020  4620              MOV      r0,r4                 ;462
000022  f7fffffe          BL       HAL_UART_MspInit
                  |L8.38|
000026  2002              MOVS     r0,#2                 ;465
000028  f8840039          STRB     r0,[r4,#0x39]         ;465
00002c  6820              LDR      r0,[r4,#0]            ;468
00002e  68c1              LDR      r1,[r0,#0xc]          ;468
000030  f4215100          BIC      r1,r1,#0x2000         ;468
000034  60c1              STR      r1,[r0,#0xc]          ;468
000036  4620              MOV      r0,r4                 ;471
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;476
00003e  6901              LDR      r1,[r0,#0x10]         ;476
000040  f4214190          BIC      r1,r1,#0x4800         ;476
000044  6101              STR      r1,[r0,#0x10]         ;476
000046  6820              LDR      r0,[r4,#0]            ;477
000048  6941              LDR      r1,[r0,#0x14]         ;477
00004a  f021012a          BIC      r1,r1,#0x2a           ;477
00004e  6141              STR      r1,[r0,#0x14]         ;477
000050  6820              LDR      r0,[r4,#0]            ;480
000052  6901              LDR      r1,[r0,#0x10]         ;480
000054  f021010f          BIC      r1,r1,#0xf            ;480
000058  4339              ORRS     r1,r1,r7              ;480
00005a  6101              STR      r1,[r0,#0x10]         ;480
00005c  6820              LDR      r0,[r4,#0]            ;483
00005e  68c1              LDR      r1,[r0,#0xc]          ;483
000060  f4216100          BIC      r1,r1,#0x800          ;483
000064  4331              ORRS     r1,r1,r6              ;483
000066  60c1              STR      r1,[r0,#0xc]          ;483
000068  6820              LDR      r0,[r4,#0]            ;486
00006a  68c1              LDR      r1,[r0,#0xc]          ;486
00006c  f4415100          ORR      r1,r1,#0x2000         ;486
000070  60c1              STR      r1,[r0,#0xc]          ;486
000072  63e5              STR      r5,[r4,#0x3c]         ;489
000074  2001              MOVS     r0,#1                 ;490
000076  f8840039          STRB     r0,[r4,#0x39]         ;490
00007a  2000              MOVS     r0,#0                 ;492
00007c  e7cc              B        |L8.24|
;;;494    
                          ENDP


                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1071     */
;;;1072   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1073   {
;;;1074     /* Process Locked */
;;;1075     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d013              BEQ      |L9.48|
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
;;;1076     
;;;1077     if(huart->State == HAL_UART_STATE_BUSY_TX)
00000e  f8902039          LDRB     r2,[r0,#0x39]
000012  2100              MOVS     r1,#0
000014  2a12              CMP      r2,#0x12
000016  d00d              BEQ      |L9.52|
;;;1078     {
;;;1079       /* Disable the UART DMA Tx request */
;;;1080       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1081     }
;;;1082     else if(huart->State == HAL_UART_STATE_BUSY_RX)
000018  f8902039          LDRB     r2,[r0,#0x39]
00001c  2a22              CMP      r2,#0x22
00001e  d00e              BEQ      |L9.62|
;;;1083     {
;;;1084       /* Disable the UART DMA Rx request */
;;;1085       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1086     }
;;;1087     else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
000020  f8902039          LDRB     r2,[r0,#0x39]
000024  2a32              CMP      r2,#0x32
000026  d00f              BEQ      |L9.72|
;;;1088     {
;;;1089       /* Disable the UART DMA Tx & Rx requests */
;;;1090       CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
;;;1091     }
;;;1092     else
;;;1093     {
;;;1094       /* Process Unlocked */
;;;1095       __HAL_UNLOCK(huart);
000028  f8801038          STRB     r1,[r0,#0x38]
;;;1096     
;;;1097       return HAL_ERROR; 
00002c  2001              MOVS     r0,#1
;;;1098     }
;;;1099     
;;;1100     /* Process Unlocked */
;;;1101     __HAL_UNLOCK(huart);
;;;1102   
;;;1103     return HAL_OK; 
;;;1104   }
00002e  4770              BX       lr
                  |L9.48|
000030  2002              MOVS     r0,#2                 ;1075
000032  4770              BX       lr
                  |L9.52|
000034  6802              LDR      r2,[r0,#0]            ;1080
000036  6953              LDR      r3,[r2,#0x14]         ;1080
000038  f0230380          BIC      r3,r3,#0x80           ;1080
00003c  e008              B        |L9.80|
                  |L9.62|
00003e  6802              LDR      r2,[r0,#0]            ;1085
000040  6953              LDR      r3,[r2,#0x14]         ;1085
000042  f0230340          BIC      r3,r3,#0x40           ;1085
000046  e003              B        |L9.80|
                  |L9.72|
000048  6802              LDR      r2,[r0,#0]            ;1090
00004a  6953              LDR      r3,[r2,#0x14]         ;1090
00004c  f02303c0          BIC      r3,r3,#0xc0           ;1090
                  |L9.80|
000050  6153              STR      r3,[r2,#0x14]         ;1090
000052  f8801038          STRB     r1,[r0,#0x38]         ;1101
000056  2000              MOVS     r0,#0                 ;1103
000058  4770              BX       lr
;;;1105   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1111     */
;;;1112   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1113   {
;;;1114     /* Process Locked */
;;;1115     __HAL_LOCK(huart);
000002  f8901038          LDRB     r1,[r0,#0x38]
000006  2901              CMP      r1,#1
000008  d013              BEQ      |L10.50|
00000a  2101              MOVS     r1,#1
00000c  f8801038          STRB     r1,[r0,#0x38]
;;;1116   
;;;1117     if(huart->State == HAL_UART_STATE_BUSY_TX)
000010  f8901039          LDRB     r1,[r0,#0x39]
000014  2200              MOVS     r2,#0
000016  2912              CMP      r1,#0x12
000018  d00d              BEQ      |L10.54|
;;;1118     {
;;;1119       /* Enable the UART DMA Tx request */
;;;1120       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1121     }
;;;1122     else if(huart->State == HAL_UART_STATE_BUSY_RX)
00001a  f8901039          LDRB     r1,[r0,#0x39]
00001e  2922              CMP      r1,#0x22
000020  d00e              BEQ      |L10.64|
;;;1123     {
;;;1124       /* Clear the Overrun flag before resumming the Rx transfer*/
;;;1125       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1126       /* Enable the UART DMA Rx request */
;;;1127       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1128     }
;;;1129     else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
000022  f8901039          LDRB     r1,[r0,#0x39]
000026  2932              CMP      r1,#0x32
000028  d012              BEQ      |L10.80|
;;;1130     {
;;;1131       /* Clear the Overrun flag before resumming the Rx transfer*/
;;;1132       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1133       /* Enable the UART DMA Tx & Rx request */
;;;1134       SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
;;;1135     }
;;;1136     else
;;;1137     {
;;;1138       /* Process Unlocked */
;;;1139       __HAL_UNLOCK(huart);
00002a  f8802038          STRB     r2,[r0,#0x38]
;;;1140   
;;;1141       return HAL_ERROR; 
00002e  2001              MOVS     r0,#1
;;;1142     }
;;;1143   
;;;1144     /* Process Unlocked */
;;;1145     __HAL_UNLOCK(huart);
;;;1146   
;;;1147     return HAL_OK;
;;;1148   }
000030  bd08              POP      {r3,pc}
                  |L10.50|
000032  2002              MOVS     r0,#2                 ;1115
000034  bd08              POP      {r3,pc}
                  |L10.54|
000036  6801              LDR      r1,[r0,#0]            ;1120
000038  694b              LDR      r3,[r1,#0x14]         ;1120
00003a  f0430380          ORR      r3,r3,#0x80           ;1120
00003e  e00e              B        |L10.94|
                  |L10.64|
000040  6801              LDR      r1,[r0,#0]            ;1125
000042  680b              LDR      r3,[r1,#0]            ;1125
000044  684b              LDR      r3,[r1,#4]            ;1125
000046  9300              STR      r3,[sp,#0]            ;1127
000048  694b              LDR      r3,[r1,#0x14]         ;1127
00004a  f0430340          ORR      r3,r3,#0x40           ;1127
00004e  e006              B        |L10.94|
                  |L10.80|
000050  6801              LDR      r1,[r0,#0]            ;1132
000052  680b              LDR      r3,[r1,#0]            ;1132
000054  684b              LDR      r3,[r1,#4]            ;1132
000056  9300              STR      r3,[sp,#0]            ;1134
000058  694b              LDR      r3,[r1,#0x14]         ;1134
00005a  f04303c0          ORR      r3,r3,#0xc0           ;1134
                  |L10.94|
00005e  614b              STR      r3,[r1,#0x14]         ;1134
000060  f8802038          STRB     r2,[r0,#0x38]         ;1145
000064  2000              MOVS     r0,#0                 ;1147
000066  bd08              POP      {r3,pc}
;;;1149   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1155     */
;;;1156   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1157   {
000002  4604              MOV      r4,r0
;;;1158     /* The Lock is not implemented on this API to allow the user application
;;;1159        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1160        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1161        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1162        */
;;;1163     
;;;1164     /* Disable the UART Tx/Rx DMA requests */
;;;1165     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  6141              STR      r1,[r0,#0x14]
00000e  6b20              LDR      r0,[r4,#0x30]         ;1157
000010  b108              CBZ      r0,|L11.22|
;;;1166     
;;;1167     /* Abort the UART DMA tx channel */
;;;1168     if(huart->hdmatx != NULL)
;;;1169     {
;;;1170       HAL_DMA_Abort(huart->hdmatx);
000012  f7fffffe          BL       HAL_DMA_Abort
                  |L11.22|
;;;1171     }
;;;1172     /* Abort the UART DMA rx channel */
;;;1173     if(huart->hdmarx != NULL)
000016  6b60              LDR      r0,[r4,#0x34]
000018  b108              CBZ      r0,|L11.30|
;;;1174     {
;;;1175       HAL_DMA_Abort(huart->hdmarx);
00001a  f7fffffe          BL       HAL_DMA_Abort
                  |L11.30|
;;;1176     }
;;;1177     
;;;1178     huart->State = HAL_UART_STATE_READY;
00001e  2001              MOVS     r0,#1
000020  f8840039          STRB     r0,[r4,#0x39]
;;;1179     
;;;1180     return HAL_OK;
000024  2000              MOVS     r0,#0
;;;1181   }
000026  bd10              POP      {r4,pc}
;;;1182   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;500      */
;;;501    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;502    {
000002  0004              MOVS     r4,r0
000004  d018              BEQ      |L12.56|
;;;503      /* Check the UART handle allocation */
;;;504      if(huart == NULL)
;;;505      {
;;;506        return HAL_ERROR;
;;;507      }
;;;508      
;;;509      /* Check the parameters */
;;;510      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;511    
;;;512      huart->State = HAL_UART_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  f8840039          STRB     r0,[r4,#0x39]
;;;513      
;;;514      /* Disable the Peripheral */
;;;515      __HAL_UART_DISABLE(huart);
00000c  6820              LDR      r0,[r4,#0]
00000e  68c1              LDR      r1,[r0,#0xc]
000010  f4215100          BIC      r1,r1,#0x2000
000014  60c1              STR      r1,[r0,#0xc]
;;;516      
;;;517      huart->Instance->CR1 = 0x0;
000016  6820              LDR      r0,[r4,#0]
000018  2500              MOVS     r5,#0
00001a  60c5              STR      r5,[r0,#0xc]
;;;518      huart->Instance->CR2 = 0x0;
00001c  6820              LDR      r0,[r4,#0]
00001e  6105              STR      r5,[r0,#0x10]
;;;519      huart->Instance->CR3 = 0x0;
000020  6820              LDR      r0,[r4,#0]
000022  6145              STR      r5,[r0,#0x14]
;;;520      
;;;521      /* DeInit the low level hardware */
;;;522      HAL_UART_MspDeInit(huart);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_UART_MspDeInit
;;;523    
;;;524      huart->ErrorCode = HAL_UART_ERROR_NONE;
00002a  63e5              STR      r5,[r4,#0x3c]
;;;525      huart->State = HAL_UART_STATE_RESET;
00002c  f8845039          STRB     r5,[r4,#0x39]
;;;526    
;;;527      /* Process Unlock */
;;;528      __HAL_UNLOCK(huart);
000030  f8845038          STRB     r5,[r4,#0x38]
;;;529    
;;;530      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;531    }
000036  bd70              POP      {r4-r6,pc}
                  |L12.56|
000038  2001              MOVS     r0,#1                 ;506
00003a  bd70              POP      {r4-r6,pc}
;;;532    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1324     */
;;;1325    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1326   {
;;;1327     /* Prevent unused argument(s) compilation warning */
;;;1328     UNUSED(huart);
;;;1329     /* NOTE: This function should not be modified, when the callback is needed,
;;;1330              the HAL_UART_ErrorCallback can be implemented in the user file
;;;1331      */ 
;;;1332   }
;;;1333   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1528   */
;;;1529   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;1530   {
;;;1531     return huart->ErrorCode;
;;;1532   }
000002  4770              BX       lr
;;;1533   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1517     */
;;;1518   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;1519   {
;;;1520     return huart->State;
;;;1521   }
000004  4770              BX       lr
;;;1522   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1188     */
;;;1189   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b538              PUSH     {r3-r5,lr}
;;;1190   {
000002  4604              MOV      r4,r0
;;;1191     uint32_t tmp_flag = 0, tmp_it_source = 0;
;;;1192   
;;;1193     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
;;;1194     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
000008  68c2              LDR      r2,[r0,#0xc]
00000a  f0110f01          TST      r1,#1                 ;1193
00000e  f4027280          AND      r2,r2,#0x100
000012  d004              BEQ      |L16.30|
;;;1195     /* UART parity error interrupt occurred ------------------------------------*/
;;;1196     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000014  b11a              CBZ      r2,|L16.30|
;;;1197     { 
;;;1198       huart->ErrorCode |= HAL_UART_ERROR_PE;
000016  6be1              LDR      r1,[r4,#0x3c]
000018  f0410101          ORR      r1,r1,#1
00001c  63e1              STR      r1,[r4,#0x3c]
                  |L16.30|
;;;1199     }
;;;1200     
;;;1201     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
00001e  6801              LDR      r1,[r0,#0]
000020  f3c10240          UBFX     r2,r1,#1,#1
;;;1202     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0010101          AND      r1,r1,#1
;;;1203     /* UART frame error interrupt occurred -------------------------------------*/
;;;1204     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00002a  b122              CBZ      r2,|L16.54|
00002c  b119              CBZ      r1,|L16.54|
;;;1205     { 
;;;1206       huart->ErrorCode |= HAL_UART_ERROR_FE;
00002e  6be2              LDR      r2,[r4,#0x3c]
000030  f0420204          ORR      r2,r2,#4
000034  63e2              STR      r2,[r4,#0x3c]
                  |L16.54|
;;;1207     }
;;;1208     
;;;1209     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
000036  6802              LDR      r2,[r0,#0]
000038  f3c20280          UBFX     r2,r2,#2,#1
;;;1210     /* UART noise error interrupt occurred -------------------------------------*/
;;;1211     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00003c  b122              CBZ      r2,|L16.72|
00003e  b119              CBZ      r1,|L16.72|
;;;1212     { 
;;;1213       huart->ErrorCode |= HAL_UART_ERROR_NE;
000040  6be2              LDR      r2,[r4,#0x3c]
000042  f0420202          ORR      r2,r2,#2
000046  63e2              STR      r2,[r4,#0x3c]
                  |L16.72|
;;;1214     }
;;;1215     
;;;1216     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
000048  6802              LDR      r2,[r0,#0]
00004a  f3c202c0          UBFX     r2,r2,#3,#1
;;;1217     /* UART Over-Run interrupt occurred ----------------------------------------*/
;;;1218     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00004e  b122              CBZ      r2,|L16.90|
000050  b119              CBZ      r1,|L16.90|
;;;1219     { 
;;;1220       huart->ErrorCode |= HAL_UART_ERROR_ORE;
000052  6be1              LDR      r1,[r4,#0x3c]
000054  f0410108          ORR      r1,r1,#8
000058  63e1              STR      r1,[r4,#0x3c]
                  |L16.90|
;;;1221     }
;;;1222     
;;;1223     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
00005a  6801              LDR      r1,[r0,#0]
;;;1224     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
00005c  68c0              LDR      r0,[r0,#0xc]
00005e  f3c11140          UBFX     r1,r1,#5,#1           ;1223
000062  f0000020          AND      r0,r0,#0x20
;;;1225     /* UART in mode Receiver ---------------------------------------------------*/
;;;1226     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000066  b119              CBZ      r1,|L16.112|
000068  b110              CBZ      r0,|L16.112|
;;;1227     { 
;;;1228       UART_Receive_IT(huart);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       UART_Receive_IT
                  |L16.112|
;;;1229     }
;;;1230     
;;;1231     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
000070  6820              LDR      r0,[r4,#0]
000072  6801              LDR      r1,[r0,#0]
;;;1232     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
000074  68c0              LDR      r0,[r0,#0xc]
000076  f3c111c0          UBFX     r1,r1,#7,#1           ;1231
00007a  f0000080          AND      r0,r0,#0x80
;;;1233     /* UART in mode Transmitter ------------------------------------------------*/
;;;1234     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00007e  b119              CBZ      r1,|L16.136|
000080  b110              CBZ      r0,|L16.136|
;;;1235     {
;;;1236       UART_Transmit_IT(huart);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       UART_Transmit_IT
                  |L16.136|
;;;1237     }
;;;1238   
;;;1239     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
000088  6821              LDR      r1,[r4,#0]
00008a  6808              LDR      r0,[r1,#0]
;;;1240     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
00008c  68ca              LDR      r2,[r1,#0xc]
00008e  f3c01080          UBFX     r0,r0,#6,#1           ;1239
000092  f0020240          AND      r2,r2,#0x40
000096  2501              MOVS     r5,#1
;;;1241     /* UART in mode Transmitter end --------------------------------------------*/
;;;1242     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000098  b170              CBZ      r0,|L16.184|
00009a  b16a              CBZ      r2,|L16.184|
00009c  68ca              LDR      r2,[r1,#0xc]
;;;1243     {
;;;1244       UART_EndTransmit_IT(huart);
00009e  4620              MOV      r0,r4
0000a0  f0220240          BIC      r2,r2,#0x40
0000a4  60ca              STR      r2,[r1,#0xc]
0000a6  f8941039          LDRB     r1,[r4,#0x39]
0000aa  2932              CMP      r1,#0x32
0000ac  d011              BEQ      |L16.210|
0000ae  f8805039          STRB     r5,[r0,#0x39]
0000b2  bf00              NOP      
                  |L16.180|
0000b4  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L16.184|
;;;1245     }  
;;;1246   
;;;1247     if(huart->ErrorCode != HAL_UART_ERROR_NONE)
0000b8  6be0              LDR      r0,[r4,#0x3c]
0000ba  2800              CMP      r0,#0
0000bc  d008              BEQ      |L16.208|
;;;1248     {
;;;1249       /* Clear all the error flag at once */
;;;1250       __HAL_UART_CLEAR_PEFLAG(huart);
0000be  6820              LDR      r0,[r4,#0]
0000c0  6801              LDR      r1,[r0,#0]
0000c2  6840              LDR      r0,[r0,#4]
;;;1251       
;;;1252       /* Set the UART state ready to be able to start again the process */
;;;1253       huart->State = HAL_UART_STATE_READY;
0000c4  9000              STR      r0,[sp,#0]
0000c6  f8845039          STRB     r5,[r4,#0x39]
;;;1254       
;;;1255       HAL_UART_ErrorCallback(huart);
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L16.208|
;;;1256     }  
;;;1257   }
0000d0  bd38              POP      {r3-r5,pc}
                  |L16.210|
0000d2  2122              MOVS     r1,#0x22
0000d4  f8801039          STRB     r1,[r0,#0x39]
0000d8  e7ec              B        |L16.180|
;;;1258   
                          ENDP


                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;250      */
;;;251    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;252    {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L17.16|
;;;253      /* Check the UART handle allocation */
;;;254      if(huart == NULL)
;;;255      {
;;;256        return HAL_ERROR;
;;;257      }
;;;258    
;;;259      /* Check the parameters */
;;;260      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;261      {
;;;262        /* The hardware flow control is available only for USART1, USART2, USART3 */
;;;263        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;264        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;265      }
;;;266      else
;;;267      {
;;;268        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;269      }
;;;270      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;271      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;272      
;;;273      if(huart->State == HAL_UART_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  2500              MOVS     r5,#0
00000c  b110              CBZ      r0,|L17.20|
00000e  e006              B        |L17.30|
                  |L17.16|
000010  2001              MOVS     r0,#1                 ;256
;;;274      {  
;;;275        /* Allocate lock resource and initialize it */
;;;276        huart->Lock = HAL_UNLOCKED;
;;;277        
;;;278        /* Init the low level hardware */
;;;279        HAL_UART_MspInit(huart);
;;;280      }
;;;281    
;;;282      huart->State = HAL_UART_STATE_BUSY;
;;;283    
;;;284      /* Disable the peripheral */
;;;285      __HAL_UART_DISABLE(huart);
;;;286      
;;;287      /* Set the UART Communication parameters */
;;;288      UART_SetConfig(huart);
;;;289      
;;;290      /* In asynchronous mode, the following bits must be kept cleared: 
;;;291         - LINEN and CLKEN bits in the USART_CR2 register,
;;;292         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;293      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;294      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;295      
;;;296      /* Enable the peripheral */
;;;297      __HAL_UART_ENABLE(huart);
;;;298      
;;;299      /* Initialize the UART state */
;;;300      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;301      huart->State= HAL_UART_STATE_READY;
;;;302      
;;;303      return HAL_OK;
;;;304    }
000012  bd70              POP      {r4-r6,pc}
                  |L17.20|
000014  f8845038          STRB     r5,[r4,#0x38]         ;276
000018  4620              MOV      r0,r4                 ;279
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L17.30|
00001e  2002              MOVS     r0,#2                 ;282
000020  f8840039          STRB     r0,[r4,#0x39]         ;282
000024  6820              LDR      r0,[r4,#0]            ;285
000026  68c1              LDR      r1,[r0,#0xc]          ;285
000028  f4215100          BIC      r1,r1,#0x2000         ;285
00002c  60c1              STR      r1,[r0,#0xc]          ;285
00002e  4620              MOV      r0,r4                 ;288
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;293
000036  6901              LDR      r1,[r0,#0x10]         ;293
000038  f4214190          BIC      r1,r1,#0x4800         ;293
00003c  6101              STR      r1,[r0,#0x10]         ;293
00003e  6820              LDR      r0,[r4,#0]            ;294
000040  6941              LDR      r1,[r0,#0x14]         ;294
000042  f021012a          BIC      r1,r1,#0x2a           ;294
000046  6141              STR      r1,[r0,#0x14]         ;294
000048  6820              LDR      r0,[r4,#0]            ;297
00004a  68c1              LDR      r1,[r0,#0xc]          ;297
00004c  f4415100          ORR      r1,r1,#0x2000         ;297
000050  60c1              STR      r1,[r0,#0xc]          ;297
000052  63e5              STR      r5,[r4,#0x3c]         ;300
000054  2001              MOVS     r0,#1                 ;301
000056  f8840039          STRB     r0,[r4,#0x39]         ;301
00005a  2000              MOVS     r0,#0                 ;303
00005c  bd70              POP      {r4-r6,pc}
;;;305    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;553      */
;;;554     __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;555    {
;;;556      /* Prevent unused argument(s) compilation warning */
;;;557      UNUSED(huart);
;;;558      /* NOTE: This function should not be modified, when the callback is needed,
;;;559               the HAL_UART_MspDeInit can be implemented in the user file
;;;560       */ 
;;;561    }
;;;562    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;538      */
;;;539     __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;540    {
;;;541      /* Prevent unused argument(s) compilation warning */
;;;542      UNUSED(huart);
;;;543      /* NOTE: This function should not be modified, when the callback is needed,
;;;544               the HAL_UART_MspInit can be implemented in the user file
;;;545       */ 
;;;546    }
;;;547    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;728    {
000004  4604              MOV      r4,r0
;;;729      uint16_t* tmp;
;;;730      uint32_t  tmp_state = 0;
;;;731    
;;;732      tmp_state = huart->State;
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  4699              MOV      r9,r3                 ;728
00000c  460d              MOV      r5,r1                 ;728
;;;733      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
00000e  2801              CMP      r0,#1
000010  d001              BEQ      |L20.22|
000012  2812              CMP      r0,#0x12
000014  d158              BNE      |L20.200|
                  |L20.22|
;;;734      {
;;;735        if((pData == NULL ) || (Size == 0))
000016  b32d              CBZ      r5,|L20.100|
000018  b322              CBZ      r2,|L20.100|
;;;736        {
;;;737          return  HAL_ERROR;
;;;738        }
;;;739    
;;;740        /* Process Locked */
;;;741        __HAL_LOCK(huart);
00001a  f8940038          LDRB     r0,[r4,#0x38]
00001e  2801              CMP      r0,#1
000020  d052              BEQ      |L20.200|
000022  2601              MOVS     r6,#1
000024  f8846038          STRB     r6,[r4,#0x38]
;;;742    
;;;743        huart->ErrorCode = HAL_UART_ERROR_NONE;
000028  2700              MOVS     r7,#0
00002a  63e7              STR      r7,[r4,#0x3c]
;;;744        /* Check if a non-blocking transmit process is ongoing or not */
;;;745        if(huart->State == HAL_UART_STATE_BUSY_TX)
00002c  f8940039          LDRB     r0,[r4,#0x39]
000030  2812              CMP      r0,#0x12
000032  d01a              BEQ      |L20.106|
;;;746        {
;;;747          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;748        }
;;;749        else
;;;750        {
;;;751          huart->State = HAL_UART_STATE_BUSY_RX;
000034  f05f0022          MOVS.W   r0,#0x22
                  |L20.56|
000038  f8840039          STRB     r0,[r4,#0x39]
;;;752        }
;;;753    
;;;754        huart->RxXferSize = Size;
00003c  85a2              STRH     r2,[r4,#0x2c]
;;;755        huart->RxXferCount = Size;
00003e  85e2              STRH     r2,[r4,#0x2e]
;;;756    
;;;757        /* Check the remain data to be received */
;;;758        while(huart->RxXferCount > 0)
;;;759        {
;;;760          huart->RxXferCount--;
;;;761          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
000040  f44f5880          MOV      r8,#0x1000
                  |L20.68|
000044  8de0              LDRH     r0,[r4,#0x2e]         ;760
;;;762          {
;;;763            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;764            {
;;;765              return HAL_TIMEOUT;
;;;766            }
;;;767            tmp = (uint16_t*) pData ;
;;;768            if(huart->Init.Parity == UART_PARITY_NONE)
;;;769            {
;;;770              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;771              pData +=2;
;;;772            }
;;;773            else
;;;774            {
;;;775              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;776              pData +=1;
;;;777            }
;;;778    
;;;779          }
;;;780          else
;;;781          {
;;;782            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
000046  464b              MOV      r3,r9
000048  1e40              SUBS     r0,r0,#1              ;760
00004a  85e0              STRH     r0,[r4,#0x2e]         ;760
00004c  68a0              LDR      r0,[r4,#8]            ;761
00004e  f04f0200          MOV      r2,#0
000052  4540              CMP      r0,r8                 ;761
000054  f04f0120          MOV      r1,#0x20
000058  4620              MOV      r0,r4
00005a  d116              BNE      |L20.138|
00005c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000060  b9b0              CBNZ     r0,|L20.144|
000062  e004              B        |L20.110|
                  |L20.100|
000064  2001              MOVS     r0,#1                 ;737
                  |L20.102|
;;;783            {
;;;784              return HAL_TIMEOUT;
;;;785            }
;;;786            if(huart->Init.Parity == UART_PARITY_NONE)
;;;787            {
;;;788              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;789            }
;;;790            else
;;;791            {
;;;792              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;793            }
;;;794    
;;;795          }
;;;796        }
;;;797    
;;;798        /* Check if a non-blocking transmit process is ongoing or not */
;;;799        if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;800        {
;;;801          huart->State = HAL_UART_STATE_BUSY_TX;
;;;802        }
;;;803        else
;;;804        {
;;;805          huart->State = HAL_UART_STATE_READY;
;;;806        }
;;;807        /* Process Unlocked */
;;;808        __HAL_UNLOCK(huart);
;;;809    
;;;810        return HAL_OK;
;;;811      }
;;;812      else
;;;813      {
;;;814        return HAL_BUSY;
;;;815      }
;;;816    }
000066  e8bd87f0          POP      {r4-r10,pc}
                  |L20.106|
00006a  2032              MOVS     r0,#0x32              ;747
00006c  e7e4              B        |L20.56|
                  |L20.110|
00006e  6920              LDR      r0,[r4,#0x10]         ;768
000070  2800              CMP      r0,#0                 ;768
000072  6820              LDR      r0,[r4,#0]            ;775
000074  6840              LDR      r0,[r0,#4]            ;775
000076  d003              BEQ      |L20.128|
000078  b2c1              UXTB     r1,r0                 ;775
00007a  f8251b01          STRH     r1,[r5],#1            ;775
00007e  e012              B        |L20.166|
                  |L20.128|
000080  f3c00108          UBFX     r1,r0,#0,#9           ;770
000084  f8251b02          STRH     r1,[r5],#2            ;770
000088  e00d              B        |L20.166|
                  |L20.138|
00008a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00008e  b108              CBZ      r0,|L20.148|
                  |L20.144|
000090  2003              MOVS     r0,#3                 ;784
000092  e7e8              B        |L20.102|
                  |L20.148|
000094  6920              LDR      r0,[r4,#0x10]         ;786
000096  2800              CMP      r0,#0                 ;786
000098  6820              LDR      r0,[r4,#0]            ;792
00009a  6840              LDR      r0,[r0,#4]            ;792
00009c  d001              BEQ      |L20.162|
00009e  f000007f          AND      r0,r0,#0x7f           ;792
                  |L20.162|
0000a2  f8050b01          STRB     r0,[r5],#1            ;788
                  |L20.166|
0000a6  8de0              LDRH     r0,[r4,#0x2e]         ;758
0000a8  2800              CMP      r0,#0                 ;758
0000aa  d1cb              BNE      |L20.68|
0000ac  f8940039          LDRB     r0,[r4,#0x39]         ;799
0000b0  2832              CMP      r0,#0x32              ;799
0000b2  d005              BEQ      |L20.192|
0000b4  f8846039          STRB     r6,[r4,#0x39]         ;805
                  |L20.184|
0000b8  f8847038          STRB     r7,[r4,#0x38]         ;808
0000bc  2000              MOVS     r0,#0                 ;810
0000be  e7d2              B        |L20.102|
                  |L20.192|
0000c0  2012              MOVS     r0,#0x12              ;801
0000c2  f8840039          STRB     r0,[r4,#0x39]         ;801
0000c6  e7f7              B        |L20.184|
                  |L20.200|
0000c8  2002              MOVS     r0,#2                 ;814
0000ca  e7cc              B        |L20.102|
;;;817    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1007     */
;;;1008   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1009   {
000002  4604              MOV      r4,r0
;;;1010     uint32_t *tmp;
;;;1011     uint32_t tmp_state = 0;
;;;1012   
;;;1013     tmp_state = huart->State;
000004  f8900039          LDRB     r0,[r0,#0x39]
;;;1014     if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L21.16|
00000c  2812              CMP      r0,#0x12
00000e  d132              BNE      |L21.118|
                  |L21.16|
;;;1015     {
;;;1016       if((pData == NULL ) || (Size == 0))
000010  b369              CBZ      r1,|L21.110|
000012  b362              CBZ      r2,|L21.110|
;;;1017       {
;;;1018         return HAL_ERROR;
;;;1019       }
;;;1020   
;;;1021       /* Process Locked */
;;;1022       __HAL_LOCK(huart);
000014  f8940038          LDRB     r0,[r4,#0x38]
000018  2801              CMP      r0,#1
00001a  d02c              BEQ      |L21.118|
00001c  2001              MOVS     r0,#1
00001e  f8840038          STRB     r0,[r4,#0x38]
;;;1023   
;;;1024       huart->pRxBuffPtr = pData;
;;;1025       huart->RxXferSize = Size;
000022  62a1              STR      r1,[r4,#0x28]
000024  85a2              STRH     r2,[r4,#0x2c]
;;;1026   
;;;1027       huart->ErrorCode = HAL_UART_ERROR_NONE;
000026  2500              MOVS     r5,#0
000028  63e5              STR      r5,[r4,#0x3c]
;;;1028       /* Check if a transmit process is ongoing or not */
;;;1029       if(huart->State == HAL_UART_STATE_BUSY_TX)
00002a  f8940039          LDRB     r0,[r4,#0x39]
00002e  2812              CMP      r0,#0x12
000030  d01f              BEQ      |L21.114|
;;;1030       {
;;;1031         huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;1032       }
;;;1033       else
;;;1034       {
;;;1035         huart->State = HAL_UART_STATE_BUSY_RX;
000032  2022              MOVS     r0,#0x22
                  |L21.52|
000034  f8840039          STRB     r0,[r4,#0x39]
;;;1036       }
;;;1037   
;;;1038       /* Set the UART DMA transfer complete callback */
;;;1039       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
000038  6b63              LDR      r3,[r4,#0x34]
00003a  4810              LDR      r0,|L21.124|
;;;1040   
;;;1041       /* Set the UART DMA Half transfer complete callback */
;;;1042       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
00003c  6298              STR      r0,[r3,#0x28]
00003e  6b63              LDR      r3,[r4,#0x34]
000040  480f              LDR      r0,|L21.128|
;;;1043   
;;;1044       /* Set the DMA error callback */
;;;1045       huart->hdmarx->XferErrorCallback = UART_DMAError;
000042  62d8              STR      r0,[r3,#0x2c]
000044  6b63              LDR      r3,[r4,#0x34]
000046  480f              LDR      r0,|L21.132|
000048  6318              STR      r0,[r3,#0x30]
00004a  4608              MOV      r0,r1
;;;1046   
;;;1047       /* Enable the DMA channel */
;;;1048       tmp = (uint32_t*)&pData;
;;;1049       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
00004c  4613              MOV      r3,r2
00004e  6b66              LDR      r6,[r4,#0x34]
000050  6821              LDR      r1,[r4,#0]
000052  4602              MOV      r2,r0
000054  4630              MOV      r0,r6
000056  1d09              ADDS     r1,r1,#4
000058  f7fffffe          BL       HAL_DMA_Start_IT
;;;1050   
;;;1051       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1052          in the UART CR3 register */
;;;1053       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00005c  6820              LDR      r0,[r4,#0]
00005e  6941              LDR      r1,[r0,#0x14]
000060  f0410140          ORR      r1,r1,#0x40
000064  6141              STR      r1,[r0,#0x14]
;;;1054   
;;;1055       /* Process Unlocked */
;;;1056       __HAL_UNLOCK(huart);
000066  f8845038          STRB     r5,[r4,#0x38]
;;;1057   
;;;1058       return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;1059     }
;;;1060     else
;;;1061     {
;;;1062       return HAL_BUSY;
;;;1063     }
;;;1064   }
00006c  bd70              POP      {r4-r6,pc}
                  |L21.110|
00006e  2001              MOVS     r0,#1                 ;1018
000070  bd70              POP      {r4-r6,pc}
                  |L21.114|
000072  2032              MOVS     r0,#0x32              ;1031
000074  e7de              B        |L21.52|
                  |L21.118|
000076  2002              MOVS     r0,#2                 ;1062
000078  bd70              POP      {r4-r6,pc}
;;;1065       
                          ENDP

00007a  0000              DCW      0x0000
                  |L21.124|
                          DCD      UART_DMAReceiveCplt
                  |L21.128|
                          DCD      UART_DMARxHalfCplt
                  |L21.132|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_IT PROC
;;;877      */
;;;878    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;879    {
;;;880      uint32_t tmp_state = 0;
;;;881      
;;;882      tmp_state = huart->State;
;;;883      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
000004  2b01              CMP      r3,#1
000006  d001              BEQ      |L22.12|
000008  2b12              CMP      r3,#0x12
00000a  d12c              BNE      |L22.102|
                  |L22.12|
;;;884      {
;;;885        if((pData == NULL ) || (Size == 0))
00000c  b339              CBZ      r1,|L22.94|
00000e  b332              CBZ      r2,|L22.94|
;;;886        {
;;;887          return HAL_ERROR;
;;;888        }
;;;889    
;;;890        /* Process Locked */
;;;891        __HAL_LOCK(huart);
000010  f8903038          LDRB     r3,[r0,#0x38]
000014  2b01              CMP      r3,#1
000016  d026              BEQ      |L22.102|
000018  2301              MOVS     r3,#1
00001a  f8803038          STRB     r3,[r0,#0x38]
;;;892    
;;;893        huart->pRxBuffPtr = pData;
;;;894        huart->RxXferSize = Size;
00001e  6281              STR      r1,[r0,#0x28]
000020  8582              STRH     r2,[r0,#0x2c]
;;;895        huart->RxXferCount = Size;
000022  85c2              STRH     r2,[r0,#0x2e]
;;;896    
;;;897        huart->ErrorCode = HAL_UART_ERROR_NONE;
000024  2100              MOVS     r1,#0
000026  63c1              STR      r1,[r0,#0x3c]
;;;898        /* Check if a transmit process is ongoing or not */
;;;899        if(huart->State == HAL_UART_STATE_BUSY_TX)
000028  f8902039          LDRB     r2,[r0,#0x39]
00002c  2a12              CMP      r2,#0x12
00002e  d018              BEQ      |L22.98|
;;;900        {
;;;901          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;902        }
;;;903        else
;;;904        {
;;;905          huart->State = HAL_UART_STATE_BUSY_RX;
000030  f05f0222          MOVS.W   r2,#0x22
                  |L22.52|
000034  f8802039          STRB     r2,[r0,#0x39]
;;;906        }
;;;907    
;;;908        /* Process Unlocked */
;;;909        __HAL_UNLOCK(huart);
000038  f8801038          STRB     r1,[r0,#0x38]
;;;910    
;;;911        /* Enable the UART Parity Error Interrupt */
;;;912        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
00003c  6801              LDR      r1,[r0,#0]
00003e  68ca              LDR      r2,[r1,#0xc]
000040  f4427280          ORR      r2,r2,#0x100
000044  60ca              STR      r2,[r1,#0xc]
;;;913    
;;;914        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;915        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
000046  6801              LDR      r1,[r0,#0]
000048  694a              LDR      r2,[r1,#0x14]
00004a  f0420201          ORR      r2,r2,#1
00004e  614a              STR      r2,[r1,#0x14]
;;;916    
;;;917        /* Enable the UART Data Register not empty Interrupt */
;;;918        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
000050  6800              LDR      r0,[r0,#0]
000052  68c1              LDR      r1,[r0,#0xc]
000054  f0410120          ORR      r1,r1,#0x20
000058  60c1              STR      r1,[r0,#0xc]
;;;919    
;;;920        return HAL_OK;
00005a  2000              MOVS     r0,#0
;;;921      }
;;;922      else
;;;923      {
;;;924        return HAL_BUSY;
;;;925      }
;;;926    }
00005c  4770              BX       lr
                  |L22.94|
00005e  2001              MOVS     r0,#1                 ;887
000060  4770              BX       lr
                  |L22.98|
000062  2232              MOVS     r2,#0x32              ;901
000064  e7e6              B        |L22.52|
                  |L22.102|
000066  2002              MOVS     r0,#2                 ;924
000068  4770              BX       lr
;;;927    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1294     */
;;;1295   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1296   {
;;;1297     /* Prevent unused argument(s) compilation warning */
;;;1298     UNUSED(huart);
;;;1299     /* NOTE: This function should not be modified, when the callback is needed,
;;;1300              the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1301      */
;;;1302   }
;;;1303   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1309     */
;;;1310   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1311   {
;;;1312     /* Prevent unused argument(s) compilation warning */
;;;1313     UNUSED(huart);
;;;1314     /* NOTE: This function should not be modified, when the callback is needed,
;;;1315              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1316      */
;;;1317   }
;;;1318   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit PROC
;;;632      */
;;;633    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;634    {
000004  4604              MOV      r4,r0
;;;635      uint16_t* tmp;
;;;636      uint32_t tmp_state = 0;
;;;637      
;;;638      tmp_state = huart->State;
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  4699              MOV      r9,r3                 ;634
00000c  460d              MOV      r5,r1                 ;634
;;;639      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
00000e  2801              CMP      r0,#1
000010  d001              BEQ      |L25.22|
000012  2822              CMP      r0,#0x22
000014  d158              BNE      |L25.200|
                  |L25.22|
;;;640      {
;;;641        if((pData == NULL) || (Size == 0))
000016  b32d              CBZ      r5,|L25.100|
000018  b322              CBZ      r2,|L25.100|
;;;642        {
;;;643          return  HAL_ERROR;
;;;644        }
;;;645    
;;;646        /* Process Locked */
;;;647        __HAL_LOCK(huart);
00001a  f8940038          LDRB     r0,[r4,#0x38]
00001e  2801              CMP      r0,#1
000020  d052              BEQ      |L25.200|
000022  2601              MOVS     r6,#1
000024  f8846038          STRB     r6,[r4,#0x38]
;;;648    
;;;649        huart->ErrorCode = HAL_UART_ERROR_NONE;
000028  2700              MOVS     r7,#0
00002a  63e7              STR      r7,[r4,#0x3c]
;;;650        /* Check if a non-blocking receive process is ongoing or not */
;;;651        if(huart->State == HAL_UART_STATE_BUSY_RX) 
00002c  f8940039          LDRB     r0,[r4,#0x39]
000030  2822              CMP      r0,#0x22
000032  d01a              BEQ      |L25.106|
;;;652        {
;;;653          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;654        }
;;;655        else
;;;656        {
;;;657          huart->State = HAL_UART_STATE_BUSY_TX;
000034  f05f0012          MOVS.W   r0,#0x12
                  |L25.56|
000038  f8840039          STRB     r0,[r4,#0x39]
;;;658        }
;;;659    
;;;660        huart->TxXferSize = Size;
00003c  84a2              STRH     r2,[r4,#0x24]
;;;661        huart->TxXferCount = Size;
00003e  84e2              STRH     r2,[r4,#0x26]
;;;662        while(huart->TxXferCount > 0)
;;;663        {
;;;664          huart->TxXferCount--;
;;;665          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
000040  f44f5880          MOV      r8,#0x1000
                  |L25.68|
000044  8ce0              LDRH     r0,[r4,#0x26]         ;664
;;;666          {
;;;667            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;668            {
;;;669              return HAL_TIMEOUT;
;;;670            }
;;;671            tmp = (uint16_t*) pData;
;;;672            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;673            if(huart->Init.Parity == UART_PARITY_NONE)
;;;674            {
;;;675              pData +=2;
;;;676            }
;;;677            else
;;;678            { 
;;;679              pData +=1;
;;;680            }
;;;681          } 
;;;682          else
;;;683          {
;;;684            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
000046  464b              MOV      r3,r9
000048  1e40              SUBS     r0,r0,#1              ;664
00004a  84e0              STRH     r0,[r4,#0x26]         ;664
00004c  68a0              LDR      r0,[r4,#8]            ;665
00004e  f04f0200          MOV      r2,#0
000052  4540              CMP      r0,r8                 ;665
000054  f04f0180          MOV      r1,#0x80
000058  4620              MOV      r0,r4
00005a  d113              BNE      |L25.132|
00005c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000060  bb08              CBNZ     r0,|L25.166|
000062  e004              B        |L25.110|
                  |L25.100|
000064  2001              MOVS     r0,#1                 ;643
                  |L25.102|
;;;685            {
;;;686              return HAL_TIMEOUT;
;;;687            }
;;;688            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;689          }
;;;690        }
;;;691    
;;;692        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
;;;693        { 
;;;694          return HAL_TIMEOUT;
;;;695        }
;;;696    
;;;697        /* Check if a non-blocking receive process is ongoing or not */
;;;698        if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;699        {
;;;700          huart->State = HAL_UART_STATE_BUSY_RX;
;;;701        }
;;;702        else
;;;703        {
;;;704          huart->State = HAL_UART_STATE_READY;
;;;705        }
;;;706    
;;;707        /* Process Unlocked */
;;;708        __HAL_UNLOCK(huart);
;;;709    
;;;710        return HAL_OK;
;;;711      }
;;;712      else
;;;713      {
;;;714        return HAL_BUSY;
;;;715      }
;;;716    }
000066  e8bd87f0          POP      {r4-r10,pc}
                  |L25.106|
00006a  2032              MOVS     r0,#0x32              ;653
00006c  e7e4              B        |L25.56|
                  |L25.110|
00006e  8828              LDRH     r0,[r5,#0]            ;672
000070  6821              LDR      r1,[r4,#0]            ;672
000072  f3c00008          UBFX     r0,r0,#0,#9           ;672
000076  6048              STR      r0,[r1,#4]            ;672
000078  6920              LDR      r0,[r4,#0x10]         ;673
00007a  b108              CBZ      r0,|L25.128|
00007c  1c6d              ADDS     r5,r5,#1              ;673
00007e  e008              B        |L25.146|
                  |L25.128|
000080  1cad              ADDS     r5,r5,#2              ;679
000082  e006              B        |L25.146|
                  |L25.132|
000084  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000088  b968              CBNZ     r0,|L25.166|
00008a  6821              LDR      r1,[r4,#0]            ;688
00008c  f8150b01          LDRB     r0,[r5],#1            ;688
000090  6048              STR      r0,[r1,#4]            ;688
                  |L25.146|
000092  8ce0              LDRH     r0,[r4,#0x26]         ;662
000094  2800              CMP      r0,#0                 ;662
000096  d1d5              BNE      |L25.68|
000098  464b              MOV      r3,r9                 ;692
00009a  2200              MOVS     r2,#0                 ;692
00009c  2140              MOVS     r1,#0x40              ;692
00009e  4620              MOV      r0,r4                 ;692
0000a0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a4  b108              CBZ      r0,|L25.170|
                  |L25.166|
0000a6  2003              MOVS     r0,#3                 ;694
0000a8  e7dd              B        |L25.102|
                  |L25.170|
0000aa  f8940039          LDRB     r0,[r4,#0x39]         ;698
0000ae  2832              CMP      r0,#0x32              ;698
0000b0  d006              BEQ      |L25.192|
0000b2  f8846039          STRB     r6,[r4,#0x39]         ;704
0000b6  bf00              NOP                            ;708
                  |L25.184|
0000b8  f8847038          STRB     r7,[r4,#0x38]         ;708
0000bc  2000              MOVS     r0,#0                 ;710
0000be  e7d2              B        |L25.102|
                  |L25.192|
0000c0  2022              MOVS     r0,#0x22              ;700
0000c2  f8840039          STRB     r0,[r4,#0x39]         ;700
0000c6  e7f7              B        |L25.184|
                  |L25.200|
0000c8  2002              MOVS     r0,#2                 ;714
0000ca  e7cc              B        |L25.102|
;;;717    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;935      */
;;;936    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;937    {
000002  4604              MOV      r4,r0
;;;938      uint32_t *tmp;
;;;939      uint32_t tmp_state = 0;
;;;940    
;;;941      tmp_state = huart->State;
000004  f8900039          LDRB     r0,[r0,#0x39]
;;;942      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L26.16|
00000c  2822              CMP      r0,#0x22
00000e  d136              BNE      |L26.126|
                  |L26.16|
;;;943      {
;;;944        if((pData == NULL ) || (Size == 0)) 
000010  b381              CBZ      r1,|L26.116|
000012  b37a              CBZ      r2,|L26.116|
;;;945        {
;;;946          return HAL_ERROR;
;;;947        }
;;;948    
;;;949        /* Process Locked */
;;;950        __HAL_LOCK(huart);
000014  f8940038          LDRB     r0,[r4,#0x38]
000018  2801              CMP      r0,#1
00001a  d030              BEQ      |L26.126|
00001c  2001              MOVS     r0,#1
00001e  f8840038          STRB     r0,[r4,#0x38]
;;;951    
;;;952        huart->pTxBuffPtr = pData;
;;;953        huart->TxXferSize = Size;
000022  6221              STR      r1,[r4,#0x20]
000024  84a2              STRH     r2,[r4,#0x24]
;;;954        huart->TxXferCount = Size;
000026  84e2              STRH     r2,[r4,#0x26]
;;;955    
;;;956        huart->ErrorCode = HAL_UART_ERROR_NONE;
000028  2500              MOVS     r5,#0
00002a  63e5              STR      r5,[r4,#0x3c]
;;;957        /* Check if a receive process is ongoing or not */
;;;958        if(huart->State == HAL_UART_STATE_BUSY_RX)
00002c  f8940039          LDRB     r0,[r4,#0x39]
000030  2822              CMP      r0,#0x22
000032  d022              BEQ      |L26.122|
;;;959        {
;;;960          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;961        }
;;;962        else
;;;963        {
;;;964          huart->State = HAL_UART_STATE_BUSY_TX;
000034  f05f0012          MOVS.W   r0,#0x12
                  |L26.56|
000038  f8840039          STRB     r0,[r4,#0x39]
;;;965        }
;;;966    
;;;967        /* Set the UART DMA transfer complete callback */
;;;968        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
00003c  6b23              LDR      r3,[r4,#0x30]
00003e  4811              LDR      r0,|L26.132|
;;;969    
;;;970        /* Set the UART DMA Half transfer complete callback */
;;;971        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
000040  6298              STR      r0,[r3,#0x28]
000042  6b23              LDR      r3,[r4,#0x30]
000044  4810              LDR      r0,|L26.136|
;;;972    
;;;973        /* Set the DMA error callback */
;;;974        huart->hdmatx->XferErrorCallback = UART_DMAError;
000046  62d8              STR      r0,[r3,#0x2c]
000048  6b23              LDR      r3,[r4,#0x30]
00004a  4810              LDR      r0,|L26.140|
;;;975    
;;;976        /* Enable the UART transmit DMA channel */
;;;977        tmp = (uint32_t*)&pData;
;;;978        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
00004c  6318              STR      r0,[r3,#0x30]
00004e  6826              LDR      r6,[r4,#0]
000050  4613              MOV      r3,r2
000052  1d32              ADDS     r2,r6,#4
000054  6b20              LDR      r0,[r4,#0x30]
000056  f7fffffe          BL       HAL_DMA_Start_IT
;;;979    
;;;980        /* Clear the TC flag in the SR register by writing 0 to it */
;;;981        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
00005a  6821              LDR      r1,[r4,#0]
00005c  f06f0040          MVN      r0,#0x40
000060  6008              STR      r0,[r1,#0]
;;;982    
;;;983        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;984           in the UART CR3 register */
;;;985        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000062  6820              LDR      r0,[r4,#0]
000064  6941              LDR      r1,[r0,#0x14]
000066  f0410180          ORR      r1,r1,#0x80
00006a  6141              STR      r1,[r0,#0x14]
;;;986    
;;;987        /* Process Unlocked */
;;;988        __HAL_UNLOCK(huart);
00006c  f8845038          STRB     r5,[r4,#0x38]
;;;989    
;;;990        return HAL_OK;
000070  2000              MOVS     r0,#0
                  |L26.114|
;;;991      }
;;;992      else
;;;993      {
;;;994        return HAL_BUSY;
;;;995      }
;;;996    }
000072  bd70              POP      {r4-r6,pc}
                  |L26.116|
000074  e7ff              B        |L26.118|
                  |L26.118|
000076  2001              MOVS     r0,#1                 ;946
000078  e7fb              B        |L26.114|
                  |L26.122|
00007a  2032              MOVS     r0,#0x32              ;960
00007c  e7dc              B        |L26.56|
                  |L26.126|
00007e  2002              MOVS     r0,#2                 ;994
000080  e7f7              B        |L26.114|
;;;997    
                          ENDP

000082  0000              DCW      0x0000
                  |L26.132|
                          DCD      UART_DMATransmitCplt
                  |L26.136|
                          DCD      UART_DMATxHalfCplt
                  |L26.140|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_IT PROC
;;;825      */
;;;826    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;827    {
;;;828      uint32_t tmp_state = 0;
;;;829    
;;;830      tmp_state = huart->State;
;;;831      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
000004  2b01              CMP      r3,#1
000006  d001              BEQ      |L27.12|
000008  2b22              CMP      r3,#0x22
00000a  d122              BNE      |L27.82|
                  |L27.12|
;;;832      {
;;;833        if((pData == NULL ) || (Size == 0))
00000c  b1e9              CBZ      r1,|L27.74|
00000e  b1e2              CBZ      r2,|L27.74|
;;;834        {
;;;835          return HAL_ERROR;
;;;836        }
;;;837        
;;;838        /* Process Locked */
;;;839        __HAL_LOCK(huart);
000010  f8903038          LDRB     r3,[r0,#0x38]
000014  2b01              CMP      r3,#1
000016  d01c              BEQ      |L27.82|
000018  2301              MOVS     r3,#1
00001a  f8803038          STRB     r3,[r0,#0x38]
;;;840        
;;;841        huart->pTxBuffPtr = pData;
;;;842        huart->TxXferSize = Size;
00001e  6201              STR      r1,[r0,#0x20]
000020  8482              STRH     r2,[r0,#0x24]
;;;843        huart->TxXferCount = Size;
000022  84c2              STRH     r2,[r0,#0x26]
;;;844    
;;;845        huart->ErrorCode = HAL_UART_ERROR_NONE;
000024  2100              MOVS     r1,#0
000026  63c1              STR      r1,[r0,#0x3c]
;;;846        /* Check if a receive process is ongoing or not */
;;;847        if(huart->State == HAL_UART_STATE_BUSY_RX) 
000028  f8902039          LDRB     r2,[r0,#0x39]
00002c  2a22              CMP      r2,#0x22
00002e  d00e              BEQ      |L27.78|
;;;848        {
;;;849          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;850        }
;;;851        else
;;;852        {
;;;853          huart->State = HAL_UART_STATE_BUSY_TX;
000030  f05f0212          MOVS.W   r2,#0x12
                  |L27.52|
000034  f8802039          STRB     r2,[r0,#0x39]
;;;854        }
;;;855    
;;;856        /* Process Unlocked */
;;;857        __HAL_UNLOCK(huart);
000038  f8801038          STRB     r1,[r0,#0x38]
;;;858    
;;;859        /* Enable the UART Transmit data register empty Interrupt */
;;;860        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
00003c  6800              LDR      r0,[r0,#0]
00003e  68c1              LDR      r1,[r0,#0xc]
000040  f0410180          ORR      r1,r1,#0x80
000044  60c1              STR      r1,[r0,#0xc]
;;;861        
;;;862        return HAL_OK;
000046  2000              MOVS     r0,#0
;;;863      }
;;;864      else
;;;865      {
;;;866        return HAL_BUSY;
;;;867      }
;;;868    }
000048  4770              BX       lr
                  |L27.74|
00004a  2001              MOVS     r0,#1                 ;835
00004c  4770              BX       lr
                  |L27.78|
00004e  2232              MOVS     r2,#0x32              ;849
000050  e7f0              B        |L27.52|
                  |L27.82|
000052  2002              MOVS     r0,#2                 ;866
000054  4770              BX       lr
;;;869    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1264     */
;;;1265    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1266   {
;;;1267     /* Prevent unused argument(s) compilation warning */
;;;1268     UNUSED(huart);
;;;1269     /* NOTE: This function should not be modified, when the callback is needed,
;;;1270              the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1271      */ 
;;;1272   }
;;;1273   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1279     */
;;;1280    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1281   {
;;;1282     /* Prevent unused argument(s) compilation warning */
;;;1283     UNUSED(huart);
;;;1284     /* NOTE: This function should not be modified, when the callback is needed,
;;;1285              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1286      */ 
;;;1287   }
;;;1288   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1636     */
;;;1637   static void UART_DMAError(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;1638   {
;;;1639     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1640     huart->RxXferCount = 0;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;1641     huart->TxXferCount = 0;
000008  84c1              STRH     r1,[r0,#0x26]
;;;1642     huart->State= HAL_UART_STATE_READY;
00000a  2101              MOVS     r1,#1
00000c  f8801039          STRB     r1,[r0,#0x39]
;;;1643     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000010  6bc1              LDR      r1,[r0,#0x3c]
000012  f0410110          ORR      r1,r1,#0x10
000016  63c1              STR      r1,[r0,#0x3c]
;;;1644     HAL_UART_ErrorCallback(huart);
000018  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1645   }
00001c  bd10              POP      {r4,pc}
;;;1646   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=2

                  UART_DMAReceiveCplt PROC
;;;1592     */
;;;1593   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
000000  b510              PUSH     {r4,lr}
;;;1594   {
000002  4601              MOV      r1,r0
;;;1595     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a40              LDR      r0,[r0,#0x24]
;;;1596     /* DMA Normal mode*/
;;;1597     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40e              BMI      |L31.44|
;;;1598     {
;;;1599       huart->RxXferCount = 0;
00000e  2100              MOVS     r1,#0
000010  85c1              STRH     r1,[r0,#0x2e]
;;;1600     
;;;1601       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1602          in the UART CR3 register */
;;;1603       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220240          BIC      r2,r2,#0x40
00001a  614a              STR      r2,[r1,#0x14]
;;;1604   
;;;1605       /* Check if a transmit process is ongoing or not */
;;;1606       if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
00001c  f8901039          LDRB     r1,[r0,#0x39]
000020  2932              CMP      r1,#0x32
000022  d006              BEQ      |L31.50|
;;;1607       {
;;;1608         huart->State = HAL_UART_STATE_BUSY_TX;
;;;1609       }
;;;1610       else
;;;1611       {
;;;1612         huart->State = HAL_UART_STATE_READY;
000024  f05f0101          MOVS.W   r1,#1
                  |L31.40|
000028  f8801039          STRB     r1,[r0,#0x39]         ;1608
                  |L31.44|
;;;1613       }
;;;1614     }
;;;1615     HAL_UART_RxCpltCallback(huart);
00002c  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1616   }
000030  bd10              POP      {r4,pc}
                  |L31.50|
000032  2112              MOVS     r1,#0x12              ;1608
000034  e7f8              B        |L31.40|
;;;1617   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1623     */
;;;1624   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1625   {
;;;1626     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1627   
;;;1628     HAL_UART_RxHalfCpltCallback(huart); 
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1629   }
000008  bd10              POP      {r4,pc}
;;;1630   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1551     */
;;;1552   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
000000  b510              PUSH     {r4,lr}
;;;1553   {
000002  4601              MOV      r1,r0
;;;1554     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a40              LDR      r0,[r0,#0x24]
;;;1555     /* DMA Normal mode*/
;;;1556     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40c              BMI      |L33.40|
;;;1557     {
;;;1558       huart->TxXferCount = 0;
00000e  2100              MOVS     r1,#0
000010  84c1              STRH     r1,[r0,#0x26]
;;;1559   
;;;1560       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1561          in the UART CR3 register */
;;;1562       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220280          BIC      r2,r2,#0x80
00001a  614a              STR      r2,[r1,#0x14]
;;;1563   
;;;1564       /* Enable the UART Transmit Complete Interrupt */    
;;;1565       __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
00001c  6800              LDR      r0,[r0,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  f0410140          ORR      r1,r1,#0x40
000024  60c1              STR      r1,[r0,#0xc]
;;;1566     }
;;;1567     /* DMA Circular mode */
;;;1568     else
;;;1569     {
;;;1570       HAL_UART_TxCpltCallback(huart);
;;;1571     }
;;;1572   }
000026  bd10              POP      {r4,pc}
                  |L33.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;1573   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1579     */
;;;1580   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1581   {
;;;1582     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1583   
;;;1584     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1585   }
000008  bd10              POP      {r4,pc}
;;;1586   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  UART_Receive_IT PROC
;;;1797     */
;;;1798   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1799   {
;;;1800     uint16_t* tmp;
;;;1801     uint32_t tmp_state = 0;
;;;1802     
;;;1803     tmp_state = huart->State; 
000002  f8901039          LDRB     r1,[r0,#0x39]
;;;1804     if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
000006  2922              CMP      r1,#0x22
000008  d003              BEQ      |L35.18|
00000a  2932              CMP      r1,#0x32
00000c  d001              BEQ      |L35.18|
;;;1805     {
;;;1806       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1807       {
;;;1808         tmp = (uint16_t*) huart->pRxBuffPtr;
;;;1809         if(huart->Init.Parity == UART_PARITY_NONE)
;;;1810         {
;;;1811           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1812           huart->pRxBuffPtr += 2;
;;;1813         }
;;;1814         else
;;;1815         {
;;;1816           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;1817           huart->pRxBuffPtr += 1;
;;;1818         }
;;;1819       }
;;;1820       else
;;;1821       {
;;;1822         if(huart->Init.Parity == UART_PARITY_NONE)
;;;1823         {
;;;1824           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1825         }
;;;1826         else
;;;1827         {
;;;1828           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1829         }
;;;1830       }
;;;1831   
;;;1832       if(--huart->RxXferCount == 0)
;;;1833       {
;;;1834         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;1835   
;;;1836         /* Check if a transmit process is ongoing or not */
;;;1837         if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;1838         {
;;;1839           huart->State = HAL_UART_STATE_BUSY_TX;
;;;1840         }
;;;1841         else
;;;1842         {
;;;1843           /* Disable the UART Parity Error Interrupt */
;;;1844           __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;1845   
;;;1846           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1847           __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;1848   
;;;1849           huart->State = HAL_UART_STATE_READY;
;;;1850         }
;;;1851         HAL_UART_RxCpltCallback(huart);
;;;1852   
;;;1853         return HAL_OK;
;;;1854       }
;;;1855       return HAL_OK;
;;;1856     }
;;;1857     else
;;;1858     {
;;;1859       return HAL_BUSY; 
00000e  2002              MOVS     r0,#2
;;;1860     }
;;;1861   }
000010  bd10              POP      {r4,pc}
                  |L35.18|
000012  6881              LDR      r1,[r0,#8]            ;1806
000014  f5b15f80          CMP      r1,#0x1000            ;1806
000018  d011              BEQ      |L35.62|
00001a  6901              LDR      r1,[r0,#0x10]         ;1822
00001c  2900              CMP      r1,#0                 ;1822
00001e  6801              LDR      r1,[r0,#0]            ;1822
000020  d01f              BEQ      |L35.98|
000022  6849              LDR      r1,[r1,#4]            ;1828
000024  f001037f          AND      r3,r1,#0x7f           ;1828
000028  6a81              LDR      r1,[r0,#0x28]         ;1828
00002a  1c4a              ADDS     r2,r1,#1              ;1828
00002c  6282              STR      r2,[r0,#0x28]         ;1828
00002e  700b              STRB     r3,[r1,#0]            ;1828
                  |L35.48|
000030  8dc1              LDRH     r1,[r0,#0x2e]         ;1832
000032  1e49              SUBS     r1,r1,#1              ;1832
000034  0409              LSLS     r1,r1,#16             ;1832
000036  0c09              LSRS     r1,r1,#16             ;1832
000038  85c1              STRH     r1,[r0,#0x2e]         ;1832
00003a  d018              BEQ      |L35.110|
00003c  e030              B        |L35.160|
                  |L35.62|
00003e  6902              LDR      r2,[r0,#0x10]         ;1809
000040  6a81              LDR      r1,[r0,#0x28]         ;1809
000042  2a00              CMP      r2,#0                 ;1809
000044  6802              LDR      r2,[r0,#0]            ;1816
000046  6852              LDR      r2,[r2,#4]            ;1816
000048  d005              BEQ      |L35.86|
00004a  b2d2              UXTB     r2,r2                 ;1816
00004c  800a              STRH     r2,[r1,#0]            ;1816
00004e  6a81              LDR      r1,[r0,#0x28]         ;1817
000050  1c49              ADDS     r1,r1,#1              ;1817
                  |L35.82|
000052  6281              STR      r1,[r0,#0x28]         ;1817
000054  e7ec              B        |L35.48|
                  |L35.86|
000056  f3c20208          UBFX     r2,r2,#0,#9           ;1811
00005a  800a              STRH     r2,[r1,#0]            ;1811
00005c  6a81              LDR      r1,[r0,#0x28]         ;1812
00005e  1c89              ADDS     r1,r1,#2              ;1812
000060  e7f7              B        |L35.82|
                  |L35.98|
000062  684a              LDR      r2,[r1,#4]            ;1824
000064  6a81              LDR      r1,[r0,#0x28]         ;1824
000066  1c4b              ADDS     r3,r1,#1              ;1824
000068  6283              STR      r3,[r0,#0x28]         ;1824
00006a  700a              STRB     r2,[r1,#0]            ;1824
00006c  e7e0              B        |L35.48|
                  |L35.110|
00006e  6801              LDR      r1,[r0,#0]            ;1834
000070  68ca              LDR      r2,[r1,#0xc]          ;1834
000072  f0220220          BIC      r2,r2,#0x20           ;1834
000076  60ca              STR      r2,[r1,#0xc]          ;1834
000078  f8901039          LDRB     r1,[r0,#0x39]         ;1837
00007c  2932              CMP      r1,#0x32              ;1837
00007e  d011              BEQ      |L35.164|
000080  6801              LDR      r1,[r0,#0]            ;1844
000082  68ca              LDR      r2,[r1,#0xc]          ;1844
000084  f4227280          BIC      r2,r2,#0x100          ;1844
000088  60ca              STR      r2,[r1,#0xc]          ;1844
00008a  6801              LDR      r1,[r0,#0]            ;1847
00008c  694a              LDR      r2,[r1,#0x14]         ;1847
00008e  f0220201          BIC      r2,r2,#1              ;1847
000092  614a              STR      r2,[r1,#0x14]         ;1847
000094  f05f0101          MOVS.W   r1,#1                 ;1849
                  |L35.152|
000098  f8801039          STRB     r1,[r0,#0x39]         ;1849
00009c  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L35.160|
0000a0  2000              MOVS     r0,#0                 ;1855
0000a2  bd10              POP      {r4,pc}
                  |L35.164|
0000a4  2112              MOVS     r1,#0x12              ;1839
0000a6  e7f7              B        |L35.152|
;;;1862   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1868     */
;;;1869   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1870   {
000004  4604              MOV      r4,r0
;;;1871     uint32_t tmpreg = 0x00;
;;;1872     
;;;1873     /* Check the parameters */
;;;1874     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
;;;1875     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1876     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1877     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1878   
;;;1879     /*------- UART-associated USART registers setting : CR2 Configuration ------*/
;;;1880     /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
;;;1881      * to huart->Init.StopBits value */
;;;1882     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6800              LDR      r0,[r0,#0]
000008  6901              LDR      r1,[r0,#0x10]
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000
000010  4311              ORRS     r1,r1,r2
000012  6101              STR      r1,[r0,#0x10]
;;;1883   
;;;1884     /*------- UART-associated USART registers setting : CR1 Configuration ------*/
;;;1885     /* Configure the UART Word Length, Parity and mode: 
;;;1886        Set the M bits according to huart->Init.WordLength value 
;;;1887        Set PCE and PS bits according to huart->Init.Parity value
;;;1888        Set TE and RE bits according to huart->Init.Mode value */
;;;1889     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode ;
000014  6921              LDR      r1,[r4,#0x10]
000016  68a0              LDR      r0,[r4,#8]
000018  4308              ORRS     r0,r0,r1
00001a  6961              LDR      r1,[r4,#0x14]
00001c  4308              ORRS     r0,r0,r1
;;;1890     MODIFY_REG(huart->Instance->CR1, 
00001e  6821              LDR      r1,[r4,#0]
000020  68ca              LDR      r2,[r1,#0xc]
000022  f241630c          MOV      r3,#0x160c
000026  439a              BICS     r2,r2,r3
000028  4302              ORRS     r2,r2,r0
00002a  60ca              STR      r2,[r1,#0xc]
;;;1891                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
;;;1892                tmpreg);
;;;1893     
;;;1894     /*------- UART-associated USART registers setting : CR3 Configuration ------*/
;;;1895     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;1896     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  69a2              LDR      r2,[r4,#0x18]
000032  f4217140          BIC      r1,r1,#0x300
000036  4311              ORRS     r1,r1,r2
000038  6141              STR      r1,[r0,#0x14]
;;;1897     
;;;1898     /*------- UART-associated USART registers setting : BRR Configuration ------*/
;;;1899     if((huart->Instance == USART1))
00003a  494c              LDR      r1,|L36.364|
00003c  6820              LDR      r0,[r4,#0]
;;;1900     {
;;;1901       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00003e  2564              MOVS     r5,#0x64
000040  2632              MOVS     r6,#0x32
000042  4288              CMP      r0,r1                 ;1899
000044  d13c              BNE      |L36.192|
000046  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6861              LDR      r1,[r4,#4]
000054  0089              LSLS     r1,r1,#2
000056  fbb0f7f1          UDIV     r7,r0,r1
00005a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005e  eb0001c0          ADD      r1,r0,r0,LSL #3
000062  eb011000          ADD      r0,r1,r0,LSL #4
000066  6861              LDR      r1,[r4,#4]
000068  46b0              MOV      r8,r6
00006a  0089              LSLS     r1,r1,#2
00006c  fbb0f0f1          UDIV     r0,r0,r1
000070  fbb0f0f5          UDIV     r0,r0,r5
000074  f06f0118          MVN      r1,#0x18
000078  4348              MULS     r0,r1,r0
00007a  eb070180          ADD      r1,r7,r0,LSL #2
00007e  eb061001          ADD      r0,r6,r1,LSL #4
000082  fbb0f0f5          UDIV     r0,r0,r5
000086  f00006f0          AND      r6,r0,#0xf0
00008a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00008e  eb0001c0          ADD      r1,r0,r0,LSL #3
000092  eb011000          ADD      r0,r1,r0,LSL #4
000096  6861              LDR      r1,[r4,#4]
000098  0089              LSLS     r1,r1,#2
00009a  fbb0f0f1          UDIV     r0,r0,r1
00009e  fbb0f0f5          UDIV     r0,r0,r5
0000a2  eb061600          ADD      r6,r6,r0,LSL #4
0000a6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000aa  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ae  eb011000          ADD      r0,r1,r0,LSL #4
0000b2  6861              LDR      r1,[r4,#4]
0000b4  0089              LSLS     r1,r1,#2
0000b6  fbb0f7f1          UDIV     r7,r0,r1
0000ba  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000be  e03b              B        |L36.312|
                  |L36.192|
;;;1902     }
;;;1903     else
;;;1904     {
;;;1905       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
0000c0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000c4  eb0001c0          ADD      r1,r0,r0,LSL #3
0000c8  eb011000          ADD      r0,r1,r0,LSL #4
0000cc  6861              LDR      r1,[r4,#4]
0000ce  0089              LSLS     r1,r1,#2
0000d0  fbb0f7f1          UDIV     r7,r0,r1
0000d4  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000d8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000dc  eb011000          ADD      r0,r1,r0,LSL #4
0000e0  6861              LDR      r1,[r4,#4]
0000e2  46b0              MOV      r8,r6
0000e4  0089              LSLS     r1,r1,#2
0000e6  fbb0f0f1          UDIV     r0,r0,r1
0000ea  fbb0f0f5          UDIV     r0,r0,r5
0000ee  f06f0118          MVN      r1,#0x18
0000f2  4348              MULS     r0,r1,r0
0000f4  eb070180          ADD      r1,r7,r0,LSL #2
0000f8  eb061001          ADD      r0,r6,r1,LSL #4
0000fc  fbb0f0f5          UDIV     r0,r0,r5
000100  f00006f0          AND      r6,r0,#0xf0
000104  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000108  eb0001c0          ADD      r1,r0,r0,LSL #3
00010c  eb011000          ADD      r0,r1,r0,LSL #4
000110  6861              LDR      r1,[r4,#4]
000112  0089              LSLS     r1,r1,#2
000114  fbb0f0f1          UDIV     r0,r0,r1
000118  fbb0f0f5          UDIV     r0,r0,r5
00011c  eb061600          ADD      r6,r6,r0,LSL #4
000120  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000124  eb0001c0          ADD      r1,r0,r0,LSL #3
000128  eb011000          ADD      r0,r1,r0,LSL #4
00012c  6861              LDR      r1,[r4,#4]
00012e  0089              LSLS     r1,r1,#2
000130  fbb0f7f1          UDIV     r7,r0,r1
000134  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
                  |L36.312|
000138  eb0001c0          ADD      r1,r0,r0,LSL #3       ;1901
00013c  eb011000          ADD      r0,r1,r0,LSL #4       ;1901
000140  6861              LDR      r1,[r4,#4]            ;1901
000142  0089              LSLS     r1,r1,#2              ;1901
000144  fbb0f0f1          UDIV     r0,r0,r1              ;1901
000148  fbb0f0f5          UDIV     r0,r0,r5              ;1901
00014c  f06f0118          MVN      r1,#0x18              ;1901
000150  4348              MULS     r0,r1,r0              ;1901
000152  eb070180          ADD      r1,r7,r0,LSL #2       ;1901
000156  eb081001          ADD      r0,r8,r1,LSL #4       ;1901
00015a  fbb0f0f5          UDIV     r0,r0,r5              ;1901
00015e  6821              LDR      r1,[r4,#0]            ;1901
000160  f000000f          AND      r0,r0,#0xf            ;1901
000164  4430              ADD      r0,r0,r6              ;1901
000166  6088              STR      r0,[r1,#8]            ;1901
;;;1906     }
;;;1907   }
000168  e8bd81f0          POP      {r4-r8,pc}
;;;1908   /**
                          ENDP

                  |L36.364|
                          DCD      0x40013800

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;1722     */
;;;1723   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  f8901039          LDRB     r1,[r0,#0x39]
;;;1724   {
;;;1725     uint16_t* tmp;
;;;1726     uint32_t tmp_state = 0;
;;;1727     
;;;1728     tmp_state = huart->State;
;;;1729     if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
000004  2912              CMP      r1,#0x12
000006  d003              BEQ      |L37.16|
000008  2932              CMP      r1,#0x32
00000a  d001              BEQ      |L37.16|
;;;1730     {
;;;1731       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1732       {
;;;1733         tmp = (uint16_t*) huart->pTxBuffPtr;
;;;1734         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;1735         if(huart->Init.Parity == UART_PARITY_NONE)
;;;1736         {
;;;1737           huart->pTxBuffPtr += 2;
;;;1738         }
;;;1739         else
;;;1740         {
;;;1741           huart->pTxBuffPtr += 1;
;;;1742         }
;;;1743       } 
;;;1744       else
;;;1745       {
;;;1746         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;1747       }
;;;1748   
;;;1749       if(--huart->TxXferCount == 0)
;;;1750       {
;;;1751         /* Disable the UART Transmit Complete Interrupt */
;;;1752         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;1753   
;;;1754         /* Enable the UART Transmit Complete Interrupt */    
;;;1755         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
;;;1756       }
;;;1757       return HAL_OK;
;;;1758     }
;;;1759     else
;;;1760     {
;;;1761       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1762     }
;;;1763   }
00000e  4770              BX       lr
                  |L37.16|
000010  6881              LDR      r1,[r0,#8]            ;1731
000012  f5b15f80          CMP      r1,#0x1000            ;1731
000016  6a01              LDR      r1,[r0,#0x20]         ;1731
000018  d00b              BEQ      |L37.50|
00001a  1c4a              ADDS     r2,r1,#1              ;1746
00001c  6202              STR      r2,[r0,#0x20]         ;1746
00001e  6802              LDR      r2,[r0,#0]            ;1746
000020  7809              LDRB     r1,[r1,#0]            ;1746
000022  6051              STR      r1,[r2,#4]            ;1746
                  |L37.36|
000024  8cc1              LDRH     r1,[r0,#0x26]         ;1749
000026  1e49              SUBS     r1,r1,#1              ;1749
000028  0409              LSLS     r1,r1,#16             ;1749
00002a  0c09              LSRS     r1,r1,#16             ;1749
00002c  84c1              STRH     r1,[r0,#0x26]         ;1749
00002e  d00e              BEQ      |L37.78|
000030  e017              B        |L37.98|
                  |L37.50|
000032  8809              LDRH     r1,[r1,#0]            ;1734
000034  6802              LDR      r2,[r0,#0]            ;1734
000036  f3c10108          UBFX     r1,r1,#0,#9           ;1734
00003a  6051              STR      r1,[r2,#4]            ;1734
00003c  6901              LDR      r1,[r0,#0x10]         ;1735
00003e  2900              CMP      r1,#0                 ;1735
000040  6a01              LDR      r1,[r0,#0x20]         ;1735
000042  d002              BEQ      |L37.74|
000044  1c49              ADDS     r1,r1,#1              ;1735
                  |L37.70|
000046  6201              STR      r1,[r0,#0x20]         ;1741
000048  e7ec              B        |L37.36|
                  |L37.74|
00004a  1c89              ADDS     r1,r1,#2              ;1741
00004c  e7fb              B        |L37.70|
                  |L37.78|
00004e  6801              LDR      r1,[r0,#0]            ;1752
000050  68ca              LDR      r2,[r1,#0xc]          ;1752
000052  f0220280          BIC      r2,r2,#0x80           ;1752
000056  60ca              STR      r2,[r1,#0xc]          ;1752
000058  6800              LDR      r0,[r0,#0]            ;1755
00005a  68c1              LDR      r1,[r0,#0xc]          ;1755
00005c  f0410140          ORR      r1,r1,#0x40           ;1755
000060  60c1              STR      r1,[r0,#0xc]          ;1755
                  |L37.98|
000062  2000              MOVS     r0,#0                 ;1757
000064  4770              BX       lr
;;;1764   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1655     */
;;;1656   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1657   {
000004  461d              MOV      r5,r3
000006  4690              MOV      r8,r2
000008  460e              MOV      r6,r1
00000a  4604              MOV      r4,r0
;;;1658     uint32_t tickstart = 0;
;;;1659   
;;;1660     /* Get tick */ 
;;;1661     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4607              MOV      r7,r0
;;;1662   
;;;1663     /* Wait until flag is set */
;;;1664     if(Status == RESET)
000012  ea5f0008          MOVS     r0,r8
000016  f04f0900          MOV      r9,#0
;;;1665     {
;;;1666       while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
;;;1667       {
;;;1668         /* Check for the Timeout */
;;;1669         if(Timeout != HAL_MAX_DELAY)
;;;1670         {
;;;1671           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1672           {
;;;1673             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1674             __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;1675             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;1676             __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;1677             __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;1678   
;;;1679             huart->State= HAL_UART_STATE_READY;
00001a  f04f0801          MOV      r8,#1
00001e  d008              BEQ      |L38.50|
000020  e030              B        |L38.132|
                  |L38.34|
000022  1c68              ADDS     r0,r5,#1              ;1669
000024  d005              BEQ      |L38.50|
000026  b195              CBZ      r5,|L38.78|
000028  f7fffffe          BL       HAL_GetTick
00002c  1bc0              SUBS     r0,r0,r7              ;1671
00002e  42a8              CMP      r0,r5                 ;1671
000030  d80d              BHI      |L38.78|
                  |L38.50|
000032  6820              LDR      r0,[r4,#0]            ;1666
000034  6800              LDR      r0,[r0,#0]            ;1666
000036  ea360000          BICS     r0,r6,r0              ;1666
00003a  d1f2              BNE      |L38.34|
00003c  e027              B        |L38.142|
                  |L38.62|
;;;1680   
;;;1681             /* Process Unlocked */
;;;1682             __HAL_UNLOCK(huart);
;;;1683   
;;;1684             return HAL_TIMEOUT;
;;;1685           }
;;;1686         }
;;;1687       }
;;;1688     }
;;;1689     else
;;;1690     {
;;;1691       while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
;;;1692       {
;;;1693         /* Check for the Timeout */
;;;1694         if(Timeout != HAL_MAX_DELAY)
00003e  1c68              ADDS     r0,r5,#1
000040  d020              BEQ      |L38.132|
;;;1695         {
;;;1696           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000042  b125              CBZ      r5,|L38.78|
000044  f7fffffe          BL       HAL_GetTick
000048  1bc0              SUBS     r0,r0,r7
00004a  42a8              CMP      r0,r5
00004c  d91a              BLS      |L38.132|
                  |L38.78|
;;;1697           {
;;;1698             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1699             __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
00004e  6820              LDR      r0,[r4,#0]
000050  68c1              LDR      r1,[r0,#0xc]
000052  f0210180          BIC      r1,r1,#0x80
000056  60c1              STR      r1,[r0,#0xc]
;;;1700             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  f0210120          BIC      r1,r1,#0x20
000060  60c1              STR      r1,[r0,#0xc]
;;;1701             __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000062  6820              LDR      r0,[r4,#0]
000064  68c1              LDR      r1,[r0,#0xc]
000066  f4217180          BIC      r1,r1,#0x100
00006a  60c1              STR      r1,[r0,#0xc]
;;;1702             __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
00006c  6820              LDR      r0,[r4,#0]
00006e  6941              LDR      r1,[r0,#0x14]
000070  f0210101          BIC      r1,r1,#1
000074  6141              STR      r1,[r0,#0x14]
;;;1703   
;;;1704             huart->State= HAL_UART_STATE_READY;
000076  f8848039          STRB     r8,[r4,#0x39]
;;;1705   
;;;1706             /* Process Unlocked */
;;;1707             __HAL_UNLOCK(huart);
00007a  f8849038          STRB     r9,[r4,#0x38]
;;;1708   
;;;1709             return HAL_TIMEOUT;
00007e  2003              MOVS     r0,#3
                  |L38.128|
;;;1710           }
;;;1711         }
;;;1712       }
;;;1713     }
;;;1714     return HAL_OK;
;;;1715   }
000080  e8bd87f0          POP      {r4-r10,pc}
                  |L38.132|
000084  6820              LDR      r0,[r4,#0]            ;1691
000086  6800              LDR      r0,[r0,#0]            ;1691
000088  ea360000          BICS     r0,r6,r0              ;1691
00008c  d0d7              BEQ      |L38.62|
                  |L38.142|
00008e  2000              MOVS     r0,#0                 ;1714
000090  e7f6              B        |L38.128|
;;;1716   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
