; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\heap_4.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\heap_4.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\heap_4.crf ..\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c]
                          THUMB

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;366    
;;;367    static void prvHeapInit( void )
000000  4810              LDR      r0,|L1.68|
;;;368    {
;;;369    BlockLink_t *pxFirstFreeBlock;
;;;370    uint8_t *pucAlignedHeap;
;;;371    size_t uxAddress;
;;;372    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
000002  f44f6140          MOV      r1,#0xc00
;;;373    
;;;374    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;375    	uxAddress = ( size_t ) ucHeap;
;;;376    
;;;377    	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
000006  0742              LSLS     r2,r0,#29
000008  d006              BEQ      |L1.24|
00000a  1dc0              ADDS     r0,r0,#7              ;368
;;;378    	{
;;;379    		uxAddress += ( portBYTE_ALIGNMENT - 1 );
;;;380    		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
;;;381    		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
00000c  490d              LDR      r1,|L1.68|
00000e  f0200007          BIC      r0,r0,#7              ;380
000012  1a41              SUBS     r1,r0,r1
000014  f5c16140          RSB      r1,r1,#0xc00
                  |L1.24|
;;;382    	}
;;;383    
;;;384    	pucAlignedHeap = ( uint8_t * ) uxAddress;
;;;385    
;;;386    	/* xStart is used to hold a pointer to the first item in the list of free
;;;387    	blocks.  The void cast is used to prevent compiler warnings. */
;;;388    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000018  4a0b              LDR      r2,|L1.72|
;;;389    	xStart.xBlockSize = ( size_t ) 0;
00001a  2300              MOVS     r3,#0
;;;390    
;;;391    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;392    	at the end of the heap space. */
;;;393    	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
00001c  4401              ADD      r1,r1,r0
00001e  e9c20300          STRD     r0,r3,[r2,#0]         ;389
000022  3908              SUBS     r1,r1,#8
;;;394    	uxAddress -= xHeapStructSize;
;;;395    	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
;;;396    	pxEnd = ( void * ) uxAddress;
000024  3a10              SUBS     r2,r2,#0x10
000026  f0210107          BIC      r1,r1,#7              ;395
;;;397    	pxEnd->xBlockSize = 0;
00002a  6011              STR      r1,[r2,#0]  ; pxEnd
;;;398    	pxEnd->pxNextFreeBlock = NULL;
00002c  604b              STR      r3,[r1,#4]
;;;399    
;;;400    	/* To start with there is a single free block that is sized to take up the
;;;401    	entire heap space, minus the space taken by pxEnd. */
;;;402    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
;;;403    	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
00002e  600b              STR      r3,[r1,#0]
000030  1a0b              SUBS     r3,r1,r0
000032  e9c01300          STRD     r1,r3,[r0,#0]
;;;404    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
;;;405    
;;;406    	/* Only one block exists - and it covers the entire usable heap space. */
;;;407    	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
;;;408    	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
000036  6093              STR      r3,[r2,#8]  ; xMinimumEverFreeBytesRemaining
;;;409    
;;;410    	/* Work out the position of the top bit in a size_t variable. */
;;;411    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
000038  f04f4000          MOV      r0,#0x80000000
00003c  6053              STR      r3,[r2,#4]  ; xFreeBytesRemaining
00003e  60d0              STR      r0,[r2,#0xc]  ; xBlockAllocatedBit
;;;412    }
000040  4770              BX       lr
;;;413    /*-----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      ||.bss||
                  |L1.72|
                          DCD      ||.data||+0x10

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;414    
;;;415    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b530              PUSH     {r4,r5,lr}
;;;416    {
;;;417    BlockLink_t *pxIterator;
;;;418    uint8_t *puc;
;;;419    
;;;420    	/* Iterate through the list until a block is found that has a higher address
;;;421    	than the block being inserted. */
;;;422    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000002  4911              LDR      r1,|L2.72|
000004  e000              B        |L2.8|
                  |L2.6|
000006  4611              MOV      r1,r2                 ;416
                  |L2.8|
000008  680a              LDR      r2,[r1,#0]
00000a  4282              CMP      r2,r0
00000c  d3fb              BCC      |L2.6|
;;;423    	{
;;;424    		/* Nothing to do here, just iterate to the right position. */
;;;425    	}
;;;426    
;;;427    	/* Do the block being inserted, and the block it is being inserted after
;;;428    	make a contiguous block of memory? */
;;;429    	puc = ( uint8_t * ) pxIterator;
;;;430    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
00000e  684b              LDR      r3,[r1,#4]
000010  185c              ADDS     r4,r3,r1
000012  4284              CMP      r4,r0
000014  d103              BNE      |L2.30|
;;;431    	{
;;;432    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
000016  6840              LDR      r0,[r0,#4]
000018  4418              ADD      r0,r0,r3
;;;433    		pxBlockToInsert = pxIterator;
00001a  6048              STR      r0,[r1,#4]
00001c  4608              MOV      r0,r1
                  |L2.30|
;;;434    	}
;;;435    	else
;;;436    	{
;;;437    		mtCOVERAGE_TEST_MARKER();
;;;438    	}
;;;439    
;;;440    	/* Do the block being inserted, and the block it is being inserted before
;;;441    	make a contiguous block of memory? */
;;;442    	puc = ( uint8_t * ) pxBlockToInsert;
;;;443    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
00001e  6843              LDR      r3,[r0,#4]
000020  181c              ADDS     r4,r3,r0
000022  4294              CMP      r4,r2
000024  d109              BNE      |L2.58|
;;;444    	{
;;;445    		if( pxIterator->pxNextFreeBlock != pxEnd )
000026  4c08              LDR      r4,|L2.72|
000028  3c10              SUBS     r4,r4,#0x10
00002a  6824              LDR      r4,[r4,#0]  ; pxEnd
00002c  42a2              CMP      r2,r4
00002e  d009              BEQ      |L2.68|
;;;446    		{
;;;447    			/* Form one big block from the two blocks. */
;;;448    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
000030  6852              LDR      r2,[r2,#4]
000032  441a              ADD      r2,r2,r3
;;;449    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000034  6042              STR      r2,[r0,#4]
000036  680a              LDR      r2,[r1,#0]
000038  6812              LDR      r2,[r2,#0]
                  |L2.58|
;;;450    		}
;;;451    		else
;;;452    		{
;;;453    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
;;;454    		}
;;;455    	}
;;;456    	else
;;;457    	{
;;;458    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
00003a  6002              STR      r2,[r0,#0]
                  |L2.60|
;;;459    	}
;;;460    
;;;461    	/* If the block being inserted plugged a gab, so was merged with the block
;;;462    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;463    	already been set, and should not be set here as that would make it point
;;;464    	to itself. */
;;;465    	if( pxIterator != pxBlockToInsert )
00003c  4281              CMP      r1,r0
00003e  d000              BEQ      |L2.66|
;;;466    	{
;;;467    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
000040  6008              STR      r0,[r1,#0]
                  |L2.66|
;;;468    	}
;;;469    	else
;;;470    	{
;;;471    		mtCOVERAGE_TEST_MARKER();
;;;472    	}
;;;473    }
000042  bd30              POP      {r4,r5,pc}
                  |L2.68|
000044  6004              STR      r4,[r0,#0]            ;453
000046  e7f9              B        |L2.60|
;;;474    
                          ENDP

                  |L2.72|
                          DCD      ||.data||+0x10

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;150    
;;;151    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;152    {
000004  4605              MOV      r5,r0
;;;153    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;154    void *pvReturn = NULL;
000006  2700              MOVS     r7,#0
;;;155    
;;;156    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;157    	{
;;;158    		/* If this is the first call to malloc then the heap will require
;;;159    		initialisation to setup the list of free blocks. */
;;;160    		if( pxEnd == NULL )
00000c  4e2a              LDR      r6,|L3.184|
00000e  6830              LDR      r0,[r6,#0]  ; pxEnd
000010  b908              CBNZ     r0,|L3.22|
;;;161    		{
;;;162    			prvHeapInit();
000012  f7fffffe          BL       prvHeapInit
                  |L3.22|
;;;163    		}
;;;164    		else
;;;165    		{
;;;166    			mtCOVERAGE_TEST_MARKER();
;;;167    		}
;;;168    
;;;169    		/* Check the requested block size is not so large that the top bit is
;;;170    		set.  The top bit of the block size member of the BlockLink_t structure
;;;171    		is used to determine who owns the block - the application or the
;;;172    		kernel, so it must be free. */
;;;173    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000016  68f0              LDR      r0,[r6,#0xc]  ; xBlockAllocatedBit
000018  4205              TST      r5,r0
00001a  d142              BNE      |L3.162|
;;;174    		{
;;;175    			/* The wanted size is increased so it can contain a BlockLink_t
;;;176    			structure in addition to the requested amount of bytes. */
;;;177    			if( xWantedSize > 0 )
00001c  b3f5              CBZ      r5,|L3.156|
00001e  3508              ADDS     r5,r5,#8
;;;178    			{
;;;179    				xWantedSize += xHeapStructSize;
;;;180    
;;;181    				/* Ensure that blocks are always aligned to the required number
;;;182    				of bytes. */
;;;183    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000020  0768              LSLS     r0,r5,#29
000022  d009              BEQ      |L3.56|
;;;184    				{
;;;185    					/* Byte alignment required. */
;;;186    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000024  f0050007          AND      r0,r5,#7
000028  f1c00008          RSB      r0,r0,#8
00002c  4405              ADD      r5,r5,r0
;;;187    					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
00002e  0768              LSLS     r0,r5,#29
000030  d002              BEQ      |L3.56|
000032  f7fffffe          BL       ulPortSetInterruptMask
                  |L3.54|
000036  e7fe              B        |L3.54|
                  |L3.56|
;;;188    				}
;;;189    				else
;;;190    				{
;;;191    					mtCOVERAGE_TEST_MARKER();
;;;192    				}
;;;193    			}
;;;194    			else
;;;195    			{
;;;196    				mtCOVERAGE_TEST_MARKER();
;;;197    			}
;;;198    
;;;199    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
000038  b385              CBZ      r5,|L3.156|
00003a  6870              LDR      r0,[r6,#4]  ; xFreeBytesRemaining
00003c  4285              CMP      r5,r0
00003e  d830              BHI      |L3.162|
;;;200    			{
;;;201    				/* Traverse the list from the start	(lowest address) block until
;;;202    				one	of adequate size is found. */
;;;203    				pxPreviousBlock = &xStart;
000040  481d              LDR      r0,|L3.184|
000042  3010              ADDS     r0,r0,#0x10
;;;204    				pxBlock = xStart.pxNextFreeBlock;
000044  4601              MOV      r1,r0
;;;205    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000046  680c              LDR      r4,[r1,#0]  ; xStart
000048  e001              B        |L3.78|
                  |L3.74|
;;;206    				{
;;;207    					pxPreviousBlock = pxBlock;
00004a  4620              MOV      r0,r4
;;;208    					pxBlock = pxBlock->pxNextFreeBlock;
00004c  460c              MOV      r4,r1
                  |L3.78|
00004e  6861              LDR      r1,[r4,#4]            ;205
000050  42a9              CMP      r1,r5                 ;205
000052  d202              BCS      |L3.90|
000054  6821              LDR      r1,[r4,#0]            ;205
000056  2900              CMP      r1,#0                 ;205
000058  d1f7              BNE      |L3.74|
                  |L3.90|
;;;209    				}
;;;210    
;;;211    				/* If the end marker was reached then a block of adequate size
;;;212    				was	not found. */
;;;213    				if( pxBlock != pxEnd )
00005a  6831              LDR      r1,[r6,#0]  ; pxEnd
00005c  428c              CMP      r4,r1
00005e  d020              BEQ      |L3.162|
;;;214    				{
;;;215    					/* Return the memory space pointed to - jumping over the
;;;216    					BlockLink_t structure at its start. */
;;;217    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
;;;218    
;;;219    					/* This block is being returned for use so must be taken out
;;;220    					of the list of free blocks. */
;;;221    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
000060  6807              LDR      r7,[r0,#0]
000062  6821              LDR      r1,[r4,#0]
;;;222    
;;;223    					/* If the block is larger than required it can be split into
;;;224    					two. */
;;;225    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
000064  6001              STR      r1,[r0,#0]
000066  6860              LDR      r0,[r4,#4]
000068  3708              ADDS     r7,r7,#8
00006a  1b41              SUBS     r1,r0,r5
00006c  2910              CMP      r1,#0x10
00006e  d909              BLS      |L3.132|
;;;226    					{
;;;227    						/* This block is to be split into two.  Create a new
;;;228    						block following the number of bytes requested. The void
;;;229    						cast is used to prevent byte alignment warnings from the
;;;230    						compiler. */
;;;231    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
000070  1960              ADDS     r0,r4,r5
;;;232    						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
000072  0742              LSLS     r2,r0,#29
000074  d002              BEQ      |L3.124|
000076  f7fffffe          BL       ulPortSetInterruptMask
                  |L3.122|
00007a  e7fe              B        |L3.122|
                  |L3.124|
;;;233    
;;;234    						/* Calculate the sizes of two blocks split from the
;;;235    						single block. */
;;;236    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
;;;237    						pxBlock->xBlockSize = xWantedSize;
00007c  6041              STR      r1,[r0,#4]
;;;238    
;;;239    						/* Insert the new block into the list of free blocks. */
;;;240    						prvInsertBlockIntoFreeList( pxNewBlockLink );
00007e  6065              STR      r5,[r4,#4]
000080  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L3.132|
;;;241    					}
;;;242    					else
;;;243    					{
;;;244    						mtCOVERAGE_TEST_MARKER();
;;;245    					}
;;;246    
;;;247    					xFreeBytesRemaining -= pxBlock->xBlockSize;
000084  6861              LDR      r1,[r4,#4]
000086  6870              LDR      r0,[r6,#4]  ; xFreeBytesRemaining
000088  1a40              SUBS     r0,r0,r1
;;;248    
;;;249    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
00008a  6070              STR      r0,[r6,#4]  ; xFreeBytesRemaining
00008c  68b2              LDR      r2,[r6,#8]  ; xMinimumEverFreeBytesRemaining
00008e  4290              CMP      r0,r2
000090  d200              BCS      |L3.148|
;;;250    					{
;;;251    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
000092  60b0              STR      r0,[r6,#8]  ; xMinimumEverFreeBytesRemaining
                  |L3.148|
;;;252    					}
;;;253    					else
;;;254    					{
;;;255    						mtCOVERAGE_TEST_MARKER();
;;;256    					}
;;;257    
;;;258    					/* The block is being returned - it is allocated and owned
;;;259    					by the application and has no "next" block. */
;;;260    					pxBlock->xBlockSize |= xBlockAllocatedBit;
000094  68f0              LDR      r0,[r6,#0xc]  ; xBlockAllocatedBit
000096  4301              ORRS     r1,r1,r0
;;;261    					pxBlock->pxNextFreeBlock = NULL;
000098  2000              MOVS     r0,#0
00009a  e000              B        |L3.158|
                  |L3.156|
00009c  e001              B        |L3.162|
                  |L3.158|
00009e  e9c40100          STRD     r0,r1,[r4,#0]
                  |L3.162|
;;;262    				}
;;;263    				else
;;;264    				{
;;;265    					mtCOVERAGE_TEST_MARKER();
;;;266    				}
;;;267    			}
;;;268    			else
;;;269    			{
;;;270    				mtCOVERAGE_TEST_MARKER();
;;;271    			}
;;;272    		}
;;;273    		else
;;;274    		{
;;;275    			mtCOVERAGE_TEST_MARKER();
;;;276    		}
;;;277    
;;;278    		traceMALLOC( pvReturn, xWantedSize );
;;;279    	}
;;;280    	( void ) xTaskResumeAll();
0000a2  f7fffffe          BL       xTaskResumeAll
;;;281    
;;;282    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;283    	{
;;;284    		if( pvReturn == NULL )
;;;285    		{
;;;286    			extern void vApplicationMallocFailedHook( void );
;;;287    			vApplicationMallocFailedHook();
;;;288    		}
;;;289    		else
;;;290    		{
;;;291    			mtCOVERAGE_TEST_MARKER();
;;;292    		}
;;;293    	}
;;;294    	#endif
;;;295    
;;;296    	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
0000a6  0778              LSLS     r0,r7,#29
0000a8  d002              BEQ      |L3.176|
0000aa  f7fffffe          BL       ulPortSetInterruptMask
                  |L3.174|
0000ae  e7fe              B        |L3.174|
                  |L3.176|
;;;297    	return pvReturn;
0000b0  4638              MOV      r0,r7
;;;298    }
0000b2  e8bd81f0          POP      {r4-r8,pc}
;;;299    /*-----------------------------------------------------------*/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L3.184|
                          DCD      ||.data||

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;300    
;;;301    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;302    {
000002  2800              CMP      r0,#0
000004  d01d              BEQ      |L4.66|
;;;303    uint8_t *puc = ( uint8_t * ) pv;
;;;304    BlockLink_t *pxLink;
;;;305    
;;;306    	if( pv != NULL )
;;;307    	{
;;;308    		/* The memory being freed will have an BlockLink_t structure immediately
;;;309    		before it. */
;;;310    		puc -= xHeapStructSize;
;;;311    
;;;312    		/* This casting is to keep the compiler from issuing warnings. */
;;;313    		pxLink = ( void * ) puc;
;;;314    
;;;315    		/* Check the block is actually allocated. */
;;;316    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
000006  4d0f              LDR      r5,|L4.68|
000008  f1a00408          SUB      r4,r0,#8              ;302
00000c  6860              LDR      r0,[r4,#4]
00000e  68e9              LDR      r1,[r5,#0xc]  ; xBlockAllocatedBit
000010  4208              TST      r0,r1
000012  d102              BNE      |L4.26|
000014  f7fffffe          BL       ulPortSetInterruptMask
                  |L4.24|
000018  e7fe              B        |L4.24|
                  |L4.26|
;;;317    		configASSERT( pxLink->pxNextFreeBlock == NULL );
00001a  6822              LDR      r2,[r4,#0]
00001c  b112              CBZ      r2,|L4.36|
00001e  f7fffffe          BL       ulPortSetInterruptMask
                  |L4.34|
000022  e7fe              B        |L4.34|
                  |L4.36|
;;;318    
;;;319    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
;;;320    		{
;;;321    			if( pxLink->pxNextFreeBlock == NULL )
;;;322    			{
;;;323    				/* The block is being returned to the heap - it is no longer
;;;324    				allocated. */
;;;325    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
000024  4388              BICS     r0,r0,r1
;;;326    
;;;327    				vTaskSuspendAll();
000026  6060              STR      r0,[r4,#4]
000028  f7fffffe          BL       vTaskSuspendAll
;;;328    				{
;;;329    					/* Add this block to the list of free blocks. */
;;;330    					xFreeBytesRemaining += pxLink->xBlockSize;
00002c  6860              LDR      r0,[r4,#4]
00002e  6869              LDR      r1,[r5,#4]  ; xFreeBytesRemaining
000030  4408              ADD      r0,r0,r1
;;;331    					traceFREE( pv, pxLink->xBlockSize );
;;;332    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000032  6068              STR      r0,[r5,#4]  ; xFreeBytesRemaining
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;333    				}
;;;334    				( void ) xTaskResumeAll();
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  f7ffbffe          B.W      xTaskResumeAll
                  |L4.66|
;;;335    			}
;;;336    			else
;;;337    			{
;;;338    				mtCOVERAGE_TEST_MARKER();
;;;339    			}
;;;340    		}
;;;341    		else
;;;342    		{
;;;343    			mtCOVERAGE_TEST_MARKER();
;;;344    		}
;;;345    	}
;;;346    }
000042  bd70              POP      {r4-r6,pc}
;;;347    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.68|
                          DCD      ||.data||

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=1

                  vPortInitialiseBlocks PROC
;;;360    
;;;361    void vPortInitialiseBlocks( void )
000000  4770              BX       lr
;;;362    {
;;;363    	/* This just exists to keep the linker quiet. */
;;;364    }
;;;365    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;348    
;;;349    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L6.8|
;;;350    {
;;;351    	return xFreeBytesRemaining;
000002  6840              LDR      r0,[r0,#4]  ; xFreeBytesRemaining
;;;352    }
000004  4770              BX       lr
;;;353    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;354    
;;;355    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L7.8|
;;;356    {
;;;357    	return xMinimumEverFreeBytesRemaining;
000002  6880              LDR      r0,[r0,#8]  ; xMinimumEverFreeBytesRemaining
;;;358    }
000004  4770              BX       lr
;;;359    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        3072

                          AREA ||.data||, DATA, ALIGN=2

                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
                  xStart
                          %        8
