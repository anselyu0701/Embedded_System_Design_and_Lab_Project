; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\stm32f1xx_hal_tim.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\stm32f1xx_hal_tim.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\stm32f1xx_hal_tim.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;244      */
;;;245    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247      /* Check the parameters */
;;;248      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;249    
;;;250      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;251    
;;;252      /* Disable the TIM Peripheral Clock */
;;;253      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L1.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L1.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L1.38|
;;;254    
;;;255      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;256      HAL_TIM_Base_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;257    
;;;258      /* Change TIM state */
;;;259      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;260    
;;;261      /* Release Lock */
;;;262      __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;263    
;;;264      return HAL_OK;
;;;265    }
000036  bd10              POP      {r4,pc}
;;;266    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4372     */
;;;4373   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4374   {
;;;4375     return htim->State;
;;;4376   }
000004  4770              BX       lr
;;;4377   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;207    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L3.14|
;;;208      /* Check the TIM handle allocation */
;;;209      if(htim == NULL)
;;;210      {
;;;211        return HAL_ERROR;
;;;212      }
;;;213    
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;216      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;217      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;218    
;;;219      if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L3.18|
00000c  e007              B        |L3.30|
                  |L3.14|
00000e  2001              MOVS     r0,#1                 ;211
;;;220      {
;;;221        /* Allocate lock resource and initialize it */
;;;222        htim->Lock = HAL_UNLOCKED;
;;;223        
;;;224        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;225        HAL_TIM_Base_MspInit(htim);
;;;226      }
;;;227    
;;;228      /* Set the TIM state */
;;;229      htim->State= HAL_TIM_STATE_BUSY;
;;;230    
;;;231      /* Set the Time Base configuration */
;;;232      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;233    
;;;234      /* Initialize the TIM state*/
;;;235      htim->State= HAL_TIM_STATE_READY;
;;;236    
;;;237      return HAL_OK;
;;;238    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;222
000014  f8840038          STRB     r0,[r4,#0x38]         ;222
000018  4620              MOV      r0,r4                 ;225
00001a  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.30|
00001e  2002              MOVS     r0,#2                 ;229
000020  f8840039          STRB     r0,[r4,#0x39]         ;229
000024  1d21              ADDS     r1,r4,#4              ;232
000026  6820              LDR      r0,[r4,#0]            ;232
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;235
00002e  f8840039          STRB     r0,[r4,#0x39]         ;235
000032  2000              MOVS     r0,#0                 ;237
000034  bd10              POP      {r4,pc}
;;;239    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;285      */
;;;286    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;287    {
;;;288      /* Prevent unused argument(s) compilation warning */
;;;289      UNUSED(htim);
;;;290      /* NOTE : This function Should not be modified, when the callback is needed,
;;;291                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;292       */
;;;293    }
;;;294    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;271      */
;;;272    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;273    {
;;;274      /* Prevent unused argument(s) compilation warning */
;;;275      UNUSED(htim);
;;;276      /* NOTE : This function Should not be modified, when the callback is needed,
;;;277                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;278       */
;;;279    }
;;;280    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;300    */
;;;301    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;305    
;;;306      /* Set the TIM state */
;;;307      htim->State= HAL_TIM_STATE_BUSY;
000002  f8801039          STRB     r1,[r0,#0x39]
;;;308    
;;;309      /* Enable the Peripheral */
;;;310      __HAL_TIM_ENABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
00000a  f0420201          ORR      r2,r2,#1
00000e  600a              STR      r2,[r1,#0]
;;;311    
;;;312      /* Change the TIM state*/
;;;313      htim->State= HAL_TIM_STATE_READY;
000010  2101              MOVS     r1,#1
000012  f8801039          STRB     r1,[r0,#0x39]
;;;314    
;;;315      /* Return function status */
;;;316      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;317    }
000018  4770              BX       lr
;;;318    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;387    */
;;;388    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
000002  4604              MOV      r4,r0
;;;390      /* Check the parameters */
;;;391      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;392    
;;;393      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L7.24|
;;;394      {
;;;395         return HAL_BUSY;
;;;396      }
;;;397      else if((htim->State == HAL_TIM_STATE_READY))
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2801              CMP      r0,#1
000012  d105              BNE      |L7.32|
;;;398      {
;;;399        if((pData == 0 ) && (Length > 0))
000014  b909              CBNZ     r1,|L7.26|
000016  b102              CBZ      r2,|L7.26|
                  |L7.24|
;;;400        {
;;;401          return HAL_ERROR;
;;;402        }
;;;403        else
;;;404        {
;;;405          htim->State = HAL_TIM_STATE_BUSY;
;;;406        }
;;;407      }
;;;408      /* Set the DMA Period elapsed callback */
;;;409      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;410    
;;;411      /* Set the DMA error callback */
;;;412      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;413    
;;;414      /* Enable the DMA channel */
;;;415      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;416    
;;;417      /* Enable the TIM Update DMA request */
;;;418      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;419    
;;;420      /* Enable the Peripheral */
;;;421      __HAL_TIM_ENABLE(htim);
;;;422    
;;;423      /* Return function status */
;;;424      return HAL_OK;
;;;425    }
000018  bd70              POP      {r4-r6,pc}
                  |L7.26|
00001a  2002              MOVS     r0,#2                 ;405
00001c  f8840039          STRB     r0,[r4,#0x39]         ;405
                  |L7.32|
000020  69e3              LDR      r3,[r4,#0x1c]         ;409
000022  480c              LDR      r0,|L7.84|
000024  6298              STR      r0,[r3,#0x28]         ;412
000026  69e3              LDR      r3,[r4,#0x1c]         ;412
000028  480b              LDR      r0,|L7.88|
00002a  6318              STR      r0,[r3,#0x30]         ;415
00002c  6825              LDR      r5,[r4,#0]            ;415
00002e  4613              MOV      r3,r2                 ;415
000030  f105022c          ADD      r2,r5,#0x2c           ;415
000034  69e0              LDR      r0,[r4,#0x1c]         ;415
000036  f7fffffe          BL       HAL_DMA_Start_IT
00003a  6820              LDR      r0,[r4,#0]            ;418
00003c  68c1              LDR      r1,[r0,#0xc]          ;418
00003e  f4417180          ORR      r1,r1,#0x100          ;418
000042  60c1              STR      r1,[r0,#0xc]          ;418
000044  6820              LDR      r0,[r4,#0]            ;421
000046  6801              LDR      r1,[r0,#0]            ;421
000048  f0410101          ORR      r1,r1,#1              ;421
00004c  6001              STR      r1,[r0,#0]            ;421
00004e  2000              MOVS     r0,#0                 ;424
000050  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;346    */
;;;347    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;348    {
;;;349      /* Check the parameters */
;;;350      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;351    
;;;352       /* Enable the TIM Update interrupt */
;;;353       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;354    
;;;355       /* Enable the Peripheral */
;;;356      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;357    
;;;358      /* Return function status */
;;;359      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;360    }
000016  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;323    */
;;;324    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;328    
;;;329      /* Set the TIM state */
;;;330      htim->State= HAL_TIM_STATE_BUSY;
000002  f8801039          STRB     r1,[r0,#0x39]
;;;331    
;;;332      /* Disable the Peripheral */
;;;333      __HAL_TIM_DISABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  6a0a              LDR      r2,[r1,#0x20]
00000a  f2411311          MOV      r3,#0x1111
00000e  421a              TST      r2,r3
000010  d107              BNE      |L9.34|
000012  6a0a              LDR      r2,[r1,#0x20]
000014  109b              ASRS     r3,r3,#2
000016  421a              TST      r2,r3
000018  d103              BNE      |L9.34|
00001a  680a              LDR      r2,[r1,#0]
00001c  f0220201          BIC      r2,r2,#1
000020  600a              STR      r2,[r1,#0]
                  |L9.34|
;;;334    
;;;335      /* Change the TIM state*/
;;;336      htim->State= HAL_TIM_STATE_READY;
000022  2101              MOVS     r1,#1
000024  f8801039          STRB     r1,[r0,#0x39]
;;;337    
;;;338      /* Return function status */
;;;339      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;340    }
00002a  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;431    */
;;;432    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;436    
;;;437      /* Disable the TIM Update DMA request */
;;;438      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227280          BIC      r2,r2,#0x100
000008  60ca              STR      r2,[r1,#0xc]
;;;439    
;;;440      /* Disable the Peripheral */
;;;441      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;442    
;;;443      /* Change the htim state */
;;;444      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  f8801039          STRB     r1,[r0,#0x39]
;;;445    
;;;446      /* Return function status */
;;;447      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;448    }
00002e  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;366    */
;;;367    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;371      /* Disable the TIM Update interrupt */
;;;372      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;373    
;;;374      /* Disable the Peripheral */
;;;375      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;376    
;;;377      /* Return function status */
;;;378      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;379    }
000028  4770              BX       lr
;;;380    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3904     */ 
;;;3905   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;3906   {
000002  4604              MOV      r4,r0
;;;3907     uint32_t tmpsmcr = 0;
;;;3908   
;;;3909     /* Process Locked */
;;;3910     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d017              BEQ      |L12.60|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;3911   
;;;3912     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
;;;3913   
;;;3914     /* Check the parameters */
;;;3915     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3916   
;;;3917     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3918     tmpsmcr = htim->Instance->SMCR;
000018  6820              LDR      r0,[r4,#0]
00001a  6882              LDR      r2,[r0,#8]
;;;3919     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
00001c  f0220277          BIC      r2,r2,#0x77
;;;3920     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000020  f422427f          BIC      r2,r2,#0xff00
;;;3921     htim->Instance->SMCR = tmpsmcr;
000024  6082              STR      r2,[r0,#8]
;;;3922   
;;;3923     switch (sClockSourceConfig->ClockSource)
000026  6808              LDR      r0,[r1,#0]
000028  2850              CMP      r0,#0x50
00002a  d037              BEQ      |L12.156|
00002c  dc0d              BGT      |L12.74|
00002e  2820              CMP      r0,#0x20
000030  d059              BEQ      |L12.230|
000032  dc05              BGT      |L12.64|
000034  b388              CBZ      r0,|L12.154|
000036  2810              CMP      r0,#0x10
000038  d141              BNE      |L12.190|
00003a  e051              B        |L12.224|
                  |L12.60|
00003c  2002              MOVS     r0,#2                 ;3910
;;;3924     {
;;;3925     case TIM_CLOCKSOURCE_INTERNAL:
;;;3926       {
;;;3927         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3928         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3929         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3930       }
;;;3931       break;
;;;3932   
;;;3933     case TIM_CLOCKSOURCE_ETRMODE1:
;;;3934       {
;;;3935         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;3936         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;3937   
;;;3938         /* Check ETR input conditioning related parameters */
;;;3939         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3940         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3941         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3942         
;;;3943         /* Configure the ETR Clock source */
;;;3944         TIM_ETR_SetConfig(htim->Instance,
;;;3945                           sClockSourceConfig->ClockPrescaler,
;;;3946                           sClockSourceConfig->ClockPolarity,
;;;3947                           sClockSourceConfig->ClockFilter);
;;;3948         /* Get the TIMx SMCR register value */
;;;3949         tmpsmcr = htim->Instance->SMCR;
;;;3950         /* Reset the SMS and TS Bits */
;;;3951         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3952         /* Select the External clock mode1 and the ETRF trigger */
;;;3953         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3954         /* Write to TIMx SMCR */
;;;3955         htim->Instance->SMCR = tmpsmcr;
;;;3956       }
;;;3957       break;
;;;3958   
;;;3959     case TIM_CLOCKSOURCE_ETRMODE2:
;;;3960       {
;;;3961         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;3962         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;3963   
;;;3964         /* Check ETR input conditioning related parameters */
;;;3965         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3966         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3967         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3968         
;;;3969         /* Configure the ETR Clock source */
;;;3970         TIM_ETR_SetConfig(htim->Instance,
;;;3971                           sClockSourceConfig->ClockPrescaler,
;;;3972                           sClockSourceConfig->ClockPolarity,
;;;3973                           sClockSourceConfig->ClockFilter);
;;;3974         /* Enable the External clock mode2 */
;;;3975         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3976       }
;;;3977       break;
;;;3978   
;;;3979     case TIM_CLOCKSOURCE_TI1:
;;;3980       {
;;;3981         /* Check whether or not the timer instance supports external clock mode 1 */
;;;3982         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3983   
;;;3984         /* Check TI1 input conditioning related parameters */
;;;3985         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3986         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3987         
;;;3988         TIM_TI1_ConfigInputStage(htim->Instance,
;;;3989                                  sClockSourceConfig->ClockPolarity,
;;;3990                                  sClockSourceConfig->ClockFilter);
;;;3991         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;3992       }
;;;3993       break;
;;;3994     case TIM_CLOCKSOURCE_TI2:
;;;3995       {
;;;3996         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;3997         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3998   
;;;3999          /* Check TI2 input conditioning related parameters */
;;;4000         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4001         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4002   
;;;4003         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4004                                  sClockSourceConfig->ClockPolarity,
;;;4005                                  sClockSourceConfig->ClockFilter);
;;;4006         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4007       }
;;;4008       break;
;;;4009     case TIM_CLOCKSOURCE_TI1ED:
;;;4010       {
;;;4011         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4012         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4013   
;;;4014         /* Check TI1 input conditioning related parameters */
;;;4015         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4016         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4017   
;;;4018         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4019                                  sClockSourceConfig->ClockPolarity,
;;;4020                                  sClockSourceConfig->ClockFilter);
;;;4021         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4022       }
;;;4023       break;
;;;4024     case TIM_CLOCKSOURCE_ITR0:
;;;4025       {
;;;4026         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4027         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4028   
;;;4029         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4030       }
;;;4031       break;
;;;4032     case TIM_CLOCKSOURCE_ITR1:
;;;4033       {
;;;4034         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4035         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4036   
;;;4037         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4038       }
;;;4039       break;
;;;4040     case TIM_CLOCKSOURCE_ITR2:
;;;4041       {
;;;4042         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4043         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4044   
;;;4045         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4046       }
;;;4047       break;
;;;4048     case TIM_CLOCKSOURCE_ITR3:
;;;4049       {
;;;4050         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4051         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4052   
;;;4053         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4054       }
;;;4055       break;
;;;4056   
;;;4057     default:
;;;4058       break;
;;;4059     }
;;;4060     htim->State = HAL_TIM_STATE_READY;
;;;4061   
;;;4062     __HAL_UNLOCK(htim);
;;;4063   
;;;4064     return HAL_OK;
;;;4065   }
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2830              CMP      r0,#0x30              ;3923
000042  d053              BEQ      |L12.236|
000044  2840              CMP      r0,#0x40              ;3923
000046  d13a              BNE      |L12.190|
000048  e03f              B        |L12.202|
                  |L12.74|
00004a  2860              CMP      r0,#0x60              ;3923
00004c  d02e              BEQ      |L12.172|
00004e  2870              CMP      r0,#0x70              ;3923
000050  d00b              BEQ      |L12.106|
000052  f5b05f80          CMP      r0,#0x1000            ;3923
000056  d003              BEQ      |L12.96|
000058  f5b05f00          CMP      r0,#0x2000            ;3923
00005c  d12f              BNE      |L12.190|
00005e  e010              B        |L12.130|
                  |L12.96|
000060  6820              LDR      r0,[r4,#0]            ;3929
000062  6881              LDR      r1,[r0,#8]            ;3929
000064  f0210107          BIC      r1,r1,#7              ;3929
000068  e015              B        |L12.150|
                  |L12.106|
00006a  68cb              LDR      r3,[r1,#0xc]          ;3944
00006c  e9d12101          LDRD     r2,r1,[r1,#4]         ;3944
000070  6820              LDR      r0,[r4,#0]            ;3944
000072  f7fffffe          BL       TIM_ETR_SetConfig
000076  6821              LDR      r1,[r4,#0]            ;3949
000078  6888              LDR      r0,[r1,#8]            ;3949
00007a  f0400077          ORR      r0,r0,#0x77           ;3953
00007e  6088              STR      r0,[r1,#8]            ;3955
000080  e01d              B        |L12.190|
                  |L12.130|
000082  68cb              LDR      r3,[r1,#0xc]          ;3970
000084  e9d12101          LDRD     r2,r1,[r1,#4]         ;3970
000088  6820              LDR      r0,[r4,#0]            ;3970
00008a  f7fffffe          BL       TIM_ETR_SetConfig
00008e  6820              LDR      r0,[r4,#0]            ;3975
000090  6881              LDR      r1,[r0,#8]            ;3975
000092  f4414180          ORR      r1,r1,#0x4000         ;3975
                  |L12.150|
000096  6081              STR      r1,[r0,#8]            ;3929
000098  e011              B        |L12.190|
                  |L12.154|
00009a  e01e              B        |L12.218|
                  |L12.156|
00009c  68ca              LDR      r2,[r1,#0xc]          ;3988
00009e  6849              LDR      r1,[r1,#4]            ;3988
0000a0  6820              LDR      r0,[r4,#0]            ;3988
0000a2  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000a6  2150              MOVS     r1,#0x50              ;3991
0000a8  6820              LDR      r0,[r4,#0]            ;3993
0000aa  e006              B        |L12.186|
                  |L12.172|
0000ac  68ca              LDR      r2,[r1,#0xc]          ;4003
0000ae  6849              LDR      r1,[r1,#4]            ;4003
0000b0  6820              LDR      r0,[r4,#0]            ;4003
0000b2  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000b6  2160              MOVS     r1,#0x60              ;4006
0000b8  6820              LDR      r0,[r4,#0]            ;4006
                  |L12.186|
0000ba  f7fffffe          BL       TIM_ITRx_SetConfig
                  |L12.190|
0000be  f8845039          STRB     r5,[r4,#0x39]         ;4060
0000c2  2000              MOVS     r0,#0                 ;4062
0000c4  f8840038          STRB     r0,[r4,#0x38]         ;4062
0000c8  bd70              POP      {r4-r6,pc}
                  |L12.202|
0000ca  68ca              LDR      r2,[r1,#0xc]          ;4018
0000cc  6849              LDR      r1,[r1,#4]            ;4018
0000ce  6820              LDR      r0,[r4,#0]            ;4018
0000d0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000d4  2140              MOVS     r1,#0x40              ;4021
0000d6  6820              LDR      r0,[r4,#0]            ;4023
0000d8  e7ef              B        |L12.186|
                  |L12.218|
0000da  2100              MOVS     r1,#0                 ;4029
0000dc  6820              LDR      r0,[r4,#0]            ;4031
0000de  e7ec              B        |L12.186|
                  |L12.224|
0000e0  2110              MOVS     r1,#0x10              ;4037
0000e2  6820              LDR      r0,[r4,#0]            ;4039
0000e4  e7e9              B        |L12.186|
                  |L12.230|
0000e6  2120              MOVS     r1,#0x20              ;4045
0000e8  6820              LDR      r0,[r4,#0]            ;4047
0000ea  e7e6              B        |L12.186|
                  |L12.236|
0000ec  2130              MOVS     r1,#0x30              ;4053
0000ee  6820              LDR      r0,[r4,#0]            ;4055
0000f0  e7e3              B        |L12.186|
;;;4066   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3779     */ 
;;;3780   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3781   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3782     uint32_t tmpsmcr = 0;
;;;3783   
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3786     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3787     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3788     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3789     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3790   
;;;3791     /* Process Locked */
;;;3792     __HAL_LOCK(htim);
000008  f8941038          LDRB     r1,[r4,#0x38]
00000c  2000              MOVS     r0,#0                 ;3782
00000e  4617              MOV      r7,r2                 ;3781
000010  2901              CMP      r1,#1
000012  d00a              BEQ      |L13.42|
000014  2601              MOVS     r6,#1
000016  f8846038          STRB     r6,[r4,#0x38]
;;;3793   
;;;3794     htim->State = HAL_TIM_STATE_BUSY;
00001a  2102              MOVS     r1,#2
00001c  f8841039          STRB     r1,[r4,#0x39]
000020  6869              LDR      r1,[r5,#4]            ;3792
000022  b129              CBZ      r1,|L13.48|
;;;3795   
;;;3796     switch (sClearInputConfig->ClearInputSource)
000024  2901              CMP      r1,#1
000026  d111              BNE      |L13.76|
000028  e005              B        |L13.54|
                  |L13.42|
00002a  2002              MOVS     r0,#2                 ;3792
                  |L13.44|
;;;3797     {
;;;3798       case TIM_CLEARINPUTSOURCE_NONE:
;;;3799       {
;;;3800         /* Clear the OCREF clear selection bit */
;;;3801         tmpsmcr &= ~TIM_SMCR_OCCS;
;;;3802   
;;;3803         /* Clear the ETR Bits */
;;;3804         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3805   
;;;3806         /* Set TIMx_SMCR */
;;;3807         htim->Instance->SMCR = tmpsmcr;
;;;3808      }
;;;3809       break;
;;;3810   
;;;3811       case TIM_CLEARINPUTSOURCE_ETR:
;;;3812       {
;;;3813         TIM_ETR_SetConfig(htim->Instance,
;;;3814                           sClearInputConfig->ClearInputPrescaler,
;;;3815                           sClearInputConfig->ClearInputPolarity,
;;;3816                           sClearInputConfig->ClearInputFilter);
;;;3817   
;;;3818         /* Set the OCREF clear selection bit */
;;;3819         htim->Instance->SMCR |= TIM_SMCR_OCCS;
;;;3820       }
;;;3821       break;
;;;3822       default:
;;;3823       break;
;;;3824     }
;;;3825   
;;;3826     switch (Channel)
;;;3827     {
;;;3828       case TIM_CHANNEL_1:
;;;3829         {
;;;3830           if(sClearInputConfig->ClearInputState != RESET)
;;;3831           {
;;;3832             /* Enable the Ocref clear feature for Channel 1 */
;;;3833             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3834           }
;;;3835           else
;;;3836           {
;;;3837             /* Disable the Ocref clear feature for Channel 1 */
;;;3838           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3839           }
;;;3840         }
;;;3841         break;
;;;3842       case TIM_CHANNEL_2:
;;;3843         {
;;;3844           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3845           if(sClearInputConfig->ClearInputState != RESET)
;;;3846           {
;;;3847             /* Enable the Ocref clear feature for Channel 2 */
;;;3848             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3849           }
;;;3850           else
;;;3851           {
;;;3852             /* Disable the Ocref clear feature for Channel 2 */
;;;3853             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3854           }
;;;3855         }
;;;3856       break;
;;;3857       case TIM_CHANNEL_3:
;;;3858         {
;;;3859           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3860           if(sClearInputConfig->ClearInputState != RESET)
;;;3861           {
;;;3862             /* Enable the Ocref clear feature for Channel 3 */
;;;3863             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3864           }
;;;3865           else
;;;3866           {
;;;3867             /* Disable the Ocref clear feature for Channel 3 */
;;;3868           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3869           }
;;;3870         }
;;;3871       break;
;;;3872       case TIM_CHANNEL_4:
;;;3873         {
;;;3874           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3875           if(sClearInputConfig->ClearInputState != RESET)
;;;3876           {
;;;3877             /* Enable the Ocref clear feature for Channel 4 */
;;;3878             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3879           }
;;;3880           else
;;;3881           {
;;;3882             /* Disable the Ocref clear feature for Channel 4 */
;;;3883           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3884           }
;;;3885         }
;;;3886       break;
;;;3887       default:
;;;3888       break;
;;;3889     }
;;;3890   
;;;3891     htim->State = HAL_TIM_STATE_READY;
;;;3892   
;;;3893     __HAL_UNLOCK(htim);
;;;3894   
;;;3895     return HAL_OK;
;;;3896   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.48|
000030  6821              LDR      r1,[r4,#0]            ;3807
000032  6088              STR      r0,[r1,#8]            ;3807
000034  e00a              B        |L13.76|
                  |L13.54|
000036  e9d52102          LDRD     r2,r1,[r5,#8]         ;3813
00003a  692b              LDR      r3,[r5,#0x10]         ;3813
00003c  6820              LDR      r0,[r4,#0]            ;3813
00003e  f7fffffe          BL       TIM_ETR_SetConfig
000042  6820              LDR      r0,[r4,#0]            ;3819
000044  6881              LDR      r1,[r0,#8]            ;3819
000046  f0410108          ORR      r1,r1,#8              ;3819
00004a  6081              STR      r1,[r0,#8]            ;3819
                  |L13.76|
00004c  b137              CBZ      r7,|L13.92|
00004e  2f04              CMP      r7,#4                 ;3826
000050  d00f              BEQ      |L13.114|
000052  2f08              CMP      r7,#8                 ;3826
000054  d019              BEQ      |L13.138|
000056  2f0c              CMP      r7,#0xc               ;3826
000058  d12d              BNE      |L13.182|
00005a  e021              B        |L13.160|
                  |L13.92|
00005c  6828              LDR      r0,[r5,#0]            ;3830
00005e  2800              CMP      r0,#0                 ;3830
000060  6820              LDR      r0,[r4,#0]            ;3838
000062  6981              LDR      r1,[r0,#0x18]         ;3838
000064  d002              BEQ      |L13.108|
000066  f0410180          ORR      r1,r1,#0x80           ;3833
00006a  e00c              B        |L13.134|
                  |L13.108|
00006c  f0210180          BIC      r1,r1,#0x80           ;3838
000070  e009              B        |L13.134|
                  |L13.114|
000072  6828              LDR      r0,[r5,#0]            ;3845
000074  2800              CMP      r0,#0                 ;3845
000076  6820              LDR      r0,[r4,#0]            ;3853
000078  6981              LDR      r1,[r0,#0x18]         ;3853
00007a  d002              BEQ      |L13.130|
00007c  f4414100          ORR      r1,r1,#0x8000         ;3848
000080  e001              B        |L13.134|
                  |L13.130|
000082  f4214100          BIC      r1,r1,#0x8000         ;3853
                  |L13.134|
000086  6181              STR      r1,[r0,#0x18]         ;3848
000088  e015              B        |L13.182|
                  |L13.138|
00008a  6828              LDR      r0,[r5,#0]            ;3860
00008c  2800              CMP      r0,#0                 ;3860
00008e  6820              LDR      r0,[r4,#0]            ;3868
000090  69c1              LDR      r1,[r0,#0x1c]         ;3868
000092  d002              BEQ      |L13.154|
000094  f0410180          ORR      r1,r1,#0x80           ;3863
000098  e00c              B        |L13.180|
                  |L13.154|
00009a  f0210180          BIC      r1,r1,#0x80           ;3868
00009e  e009              B        |L13.180|
                  |L13.160|
0000a0  6828              LDR      r0,[r5,#0]            ;3875
0000a2  2800              CMP      r0,#0                 ;3875
0000a4  6820              LDR      r0,[r4,#0]            ;3883
0000a6  69c1              LDR      r1,[r0,#0x1c]         ;3883
0000a8  d002              BEQ      |L13.176|
0000aa  f4414100          ORR      r1,r1,#0x8000         ;3878
0000ae  e001              B        |L13.180|
                  |L13.176|
0000b0  f4214100          BIC      r1,r1,#0x8000         ;3883
                  |L13.180|
0000b4  61c1              STR      r1,[r0,#0x1c]         ;3878
                  |L13.182|
0000b6  f8846039          STRB     r6,[r4,#0x39]         ;3891
0000ba  2000              MOVS     r0,#0                 ;3893
0000bc  f8840038          STRB     r0,[r4,#0x38]         ;3893
0000c0  e7b4              B        |L13.44|
;;;3897   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4078     */
;;;4079   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6802              LDR      r2,[r0,#0]
;;;4080   {
;;;4081     uint32_t tmpcr2 = 0;
;;;4082   
;;;4083     /* Check the parameters */
;;;4084     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4085     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4086   
;;;4087     /* Get the TIMx CR2 register value */
;;;4088     tmpcr2 = htim->Instance->CR2;
000002  6850              LDR      r0,[r2,#4]
;;;4089   
;;;4090     /* Reset the TI1 selection */
;;;4091     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0200080          BIC      r0,r0,#0x80
;;;4092   
;;;4093     /* Set the the TI1 selection */
;;;4094     tmpcr2 |= TI1_Selection;
000008  4308              ORRS     r0,r0,r1
;;;4095   
;;;4096     /* Write to TIMxCR2 */
;;;4097     htim->Instance->CR2 = tmpcr2;
00000a  6050              STR      r0,[r2,#4]
;;;4098   
;;;4099     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4100   }
00000e  4770              BX       lr
;;;4101   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3538     */
;;;3539   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3540                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3541   {
000004  4604              MOV      r4,r0
;;;3542     /* Check the parameters */
;;;3543     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3544     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3545     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3546     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3547   
;;;3548     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  9d06              LDR      r5,[sp,#0x18]
00000c  469c              MOV      r12,r3                ;3541
00000e  4616              MOV      r6,r2                 ;3541
000010  4688              MOV      r8,r1                 ;3541
000012  2802              CMP      r0,#2
000014  d007              BEQ      |L15.38|
;;;3549     {
;;;3550        return HAL_BUSY;
;;;3551     }
;;;3552     else if((htim->State == HAL_TIM_STATE_READY))
000016  f8940039          LDRB     r0,[r4,#0x39]
00001a  2801              CMP      r0,#1
00001c  d108              BNE      |L15.48|
;;;3553     {
;;;3554       if((BurstBuffer == 0 ) && (BurstLength > 0))
00001e  f1bc0f00          CMP      r12,#0
000022  d102              BNE      |L15.42|
000024  b10d              CBZ      r5,|L15.42|
                  |L15.38|
;;;3555       {
;;;3556         return HAL_ERROR;
;;;3557       }
;;;3558       else
;;;3559       {
;;;3560         htim->State = HAL_TIM_STATE_BUSY;
;;;3561       }
;;;3562     }
;;;3563     switch(BurstRequestSrc)
;;;3564     {
;;;3565       case TIM_DMA_UPDATE:
;;;3566       {
;;;3567         /* Set the DMA Period elapsed callback */
;;;3568         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3569   
;;;3570         /* Set the DMA error callback */
;;;3571         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3572   
;;;3573         /* Enable the DMA channel */
;;;3574          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3575       }
;;;3576       break;
;;;3577       case TIM_DMA_CC1:
;;;3578       {
;;;3579         /* Set the DMA Period elapsed callback */
;;;3580         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3581   
;;;3582         /* Set the DMA error callback */
;;;3583         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3584   
;;;3585         /* Enable the DMA channel */
;;;3586         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3587       }
;;;3588       break;
;;;3589       case TIM_DMA_CC2:
;;;3590       {
;;;3591         /* Set the DMA Period elapsed callback */
;;;3592         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3593   
;;;3594         /* Set the DMA error callback */
;;;3595         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3596   
;;;3597         /* Enable the DMA channel */
;;;3598         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3599       }
;;;3600       break;
;;;3601       case TIM_DMA_CC3:
;;;3602       {
;;;3603         /* Set the DMA Period elapsed callback */
;;;3604         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3605   
;;;3606         /* Set the DMA error callback */
;;;3607         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3608   
;;;3609         /* Enable the DMA channel */
;;;3610         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3611       }
;;;3612       break;
;;;3613       case TIM_DMA_CC4:
;;;3614       {
;;;3615         /* Set the DMA Period elapsed callback */
;;;3616         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3617   
;;;3618         /* Set the DMA error callback */
;;;3619         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3620   
;;;3621         /* Enable the DMA channel */
;;;3622         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3623       }
;;;3624       break;
;;;3625       case TIM_DMA_COM:
;;;3626       {
;;;3627         /* Set the DMA Period elapsed callback */
;;;3628         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3629   
;;;3630         /* Set the DMA error callback */
;;;3631         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3632   
;;;3633         /* Enable the DMA channel */
;;;3634         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3635       }
;;;3636       break;
;;;3637       case TIM_DMA_TRIGGER:
;;;3638       {
;;;3639         /* Set the DMA Period elapsed callback */
;;;3640         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3641   
;;;3642         /* Set the DMA error callback */
;;;3643         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3644   
;;;3645         /* Enable the DMA channel */
;;;3646         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3647       }
;;;3648       break;
;;;3649       default:
;;;3650       break;
;;;3651     }
;;;3652   
;;;3653     /* configure the DMA Burst Mode */
;;;3654     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3655   
;;;3656     /* Enable the TIM DMA Request */
;;;3657     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3658   
;;;3659     htim->State = HAL_TIM_STATE_READY;
;;;3660   
;;;3661     /* Return function status */
;;;3662     return HAL_OK;
;;;3663   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L15.42|
00002a  2002              MOVS     r0,#2                 ;3560
00002c  f8840039          STRB     r0,[r4,#0x39]         ;3560
                  |L15.48|
000030  2701              MOVS     r7,#1                 ;3556
000032  482f              LDR      r0,|L15.240|
000034  492f              LDR      r1,|L15.244|
000036  eb072315          ADD      r3,r7,r5,LSR #8       ;3574
00003a  f5b66f00          CMP      r6,#0x800             ;3563
00003e  d039              BEQ      |L15.180|
000040  dc09              BGT      |L15.86|
000042  f5b67f80          CMP      r6,#0x100             ;3563
000046  d010              BEQ      |L15.106|
000048  f5b67f00          CMP      r6,#0x200             ;3563
00004c  d015              BEQ      |L15.122|
00004e  f5b66f80          CMP      r6,#0x400             ;3563
000052  d11c              BNE      |L15.142|
000054  e027              B        |L15.166|
                  |L15.86|
000056  f5b65f80          CMP      r6,#0x1000            ;3563
00005a  d032              BEQ      |L15.194|
00005c  f5b65f00          CMP      r6,#0x2000            ;3563
000060  d036              BEQ      |L15.208|
000062  f5b64f80          CMP      r6,#0x4000            ;3563
000066  d112              BNE      |L15.142|
000068  e03a              B        |L15.224|
                  |L15.106|
00006a  69e2              LDR      r2,[r4,#0x1c]         ;3568
00006c  4922              LDR      r1,|L15.248|
00006e  6291              STR      r1,[r2,#0x28]         ;3571
000070  69e1              LDR      r1,[r4,#0x1c]         ;3571
000072  6308              STR      r0,[r1,#0x30]         ;3574
000074  6821              LDR      r1,[r4,#0]            ;3576
000076  69e0              LDR      r0,[r4,#0x1c]         ;3576
000078  e005              B        |L15.134|
                  |L15.122|
00007a  6a22              LDR      r2,[r4,#0x20]         ;3580
00007c  6291              STR      r1,[r2,#0x28]         ;3583
00007e  6a21              LDR      r1,[r4,#0x20]         ;3583
000080  6308              STR      r0,[r1,#0x30]         ;3586
000082  6821              LDR      r1,[r4,#0]            ;3586
000084  6a20              LDR      r0,[r4,#0x20]         ;3586
                  |L15.134|
000086  4662              MOV      r2,r12                ;3574
000088  314c              ADDS     r1,r1,#0x4c           ;3574
00008a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.142|
00008e  6821              LDR      r1,[r4,#0]            ;3654
000090  ea480005          ORR      r0,r8,r5              ;3654
000094  6488              STR      r0,[r1,#0x48]         ;3654
000096  6820              LDR      r0,[r4,#0]            ;3657
000098  68c1              LDR      r1,[r0,#0xc]          ;3657
00009a  4331              ORRS     r1,r1,r6              ;3657
00009c  60c1              STR      r1,[r0,#0xc]          ;3657
00009e  f8847039          STRB     r7,[r4,#0x39]         ;3659
0000a2  2000              MOVS     r0,#0                 ;3662
0000a4  e7bf              B        |L15.38|
                  |L15.166|
0000a6  6a62              LDR      r2,[r4,#0x24]         ;3592
0000a8  6291              STR      r1,[r2,#0x28]         ;3595
0000aa  6a61              LDR      r1,[r4,#0x24]         ;3595
0000ac  6308              STR      r0,[r1,#0x30]         ;3598
0000ae  6821              LDR      r1,[r4,#0]            ;3600
0000b0  6a60              LDR      r0,[r4,#0x24]         ;3600
0000b2  e7e8              B        |L15.134|
                  |L15.180|
0000b4  6aa2              LDR      r2,[r4,#0x28]         ;3604
0000b6  6291              STR      r1,[r2,#0x28]         ;3607
0000b8  6aa1              LDR      r1,[r4,#0x28]         ;3607
0000ba  6308              STR      r0,[r1,#0x30]         ;3610
0000bc  6821              LDR      r1,[r4,#0]            ;3612
0000be  6aa0              LDR      r0,[r4,#0x28]         ;3612
0000c0  e7e1              B        |L15.134|
                  |L15.194|
0000c2  6ae2              LDR      r2,[r4,#0x2c]         ;3616
0000c4  6291              STR      r1,[r2,#0x28]         ;3619
0000c6  6ae1              LDR      r1,[r4,#0x2c]         ;3619
0000c8  6308              STR      r0,[r1,#0x30]         ;3622
0000ca  6821              LDR      r1,[r4,#0]            ;3624
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;3624
0000ce  e7da              B        |L15.134|
                  |L15.208|
0000d0  6b22              LDR      r2,[r4,#0x30]         ;3628
0000d2  490a              LDR      r1,|L15.252|
0000d4  6291              STR      r1,[r2,#0x28]         ;3631
0000d6  6b21              LDR      r1,[r4,#0x30]         ;3631
0000d8  6308              STR      r0,[r1,#0x30]         ;3634
0000da  6821              LDR      r1,[r4,#0]            ;3636
0000dc  6b20              LDR      r0,[r4,#0x30]         ;3636
0000de  e7d2              B        |L15.134|
                  |L15.224|
0000e0  6b62              LDR      r2,[r4,#0x34]         ;3640
0000e2  4907              LDR      r1,|L15.256|
0000e4  6291              STR      r1,[r2,#0x28]         ;3643
0000e6  6b61              LDR      r1,[r4,#0x34]         ;3643
0000e8  6308              STR      r0,[r1,#0x30]         ;3646
0000ea  6821              LDR      r1,[r4,#0]            ;3648
0000ec  6b60              LDR      r0,[r4,#0x34]         ;3648
0000ee  e7ca              B        |L15.134|
;;;3664   
                          ENDP

                  |L15.240|
                          DCD      TIM_DMAError
                  |L15.244|
                          DCD      TIM_DMACaptureCplt
                  |L15.248|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.252|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.256|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3670     */
;;;3671   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3672   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3673     /* Check the parameters */
;;;3674     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3675   
;;;3676     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3677     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
00000a  d021              BEQ      |L16.80|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d00f              BEQ      |L16.58|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d10f              BNE      |L16.64|
000020  e014              B        |L16.76|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d015              BEQ      |L16.84|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d014              BEQ      |L16.88|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d105              BNE      |L16.64|
000034  e012              B        |L16.92|
                  |L16.54|
;;;3678     {
;;;3679       case TIM_DMA_UPDATE:
;;;3680       {
;;;3681         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3682       }
;;;3683       break;
000036  69e0              LDR      r0,[r4,#0x1c]
000038  e000              B        |L16.60|
                  |L16.58|
;;;3684       case TIM_DMA_CC1:
;;;3685       {
;;;3686         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003a  6a20              LDR      r0,[r4,#0x20]
                  |L16.60|
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L16.64|
;;;3687       }
;;;3688       break;
;;;3689       case TIM_DMA_CC2:
;;;3690       {
;;;3691         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3692       }
;;;3693       break;
;;;3694       case TIM_DMA_CC3:
;;;3695       {
;;;3696         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3697       }
;;;3698       break;
;;;3699       case TIM_DMA_CC4:
;;;3700       {
;;;3701         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3702       }
;;;3703       break;
;;;3704       case TIM_DMA_COM:
;;;3705       {
;;;3706         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3707       }
;;;3708       break;
;;;3709       case TIM_DMA_TRIGGER:
;;;3710       {
;;;3711         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
;;;3712       }
;;;3713       break;
;;;3714       default:
;;;3715       break;
;;;3716     }
;;;3717   
;;;3718     /* Disable the TIM Update DMA request */
;;;3719     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3720   
;;;3721     /* Return function status */
;;;3722     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;3723   }
00004a  bd70              POP      {r4-r6,pc}
                  |L16.76|
00004c  6a60              LDR      r0,[r4,#0x24]         ;3693
00004e  e7f5              B        |L16.60|
                  |L16.80|
000050  6aa0              LDR      r0,[r4,#0x28]         ;3698
000052  e7f3              B        |L16.60|
                  |L16.84|
000054  6ae0              LDR      r0,[r4,#0x2c]         ;3703
000056  e7f1              B        |L16.60|
                  |L16.88|
000058  6b20              LDR      r0,[r4,#0x30]         ;3708
00005a  e7ef              B        |L16.60|
                  |L16.92|
00005c  6b60              LDR      r0,[r4,#0x34]         ;3713
00005e  e7ed              B        |L16.60|
;;;3724   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3315     */
;;;3316   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3317                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3318   {
000004  4604              MOV      r4,r0
;;;3319     /* Check the parameters */
;;;3320     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3321     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3322     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3323     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3324   
;;;3325     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  9d06              LDR      r5,[sp,#0x18]
00000c  469c              MOV      r12,r3                ;3318
00000e  4616              MOV      r6,r2                 ;3318
000010  4688              MOV      r8,r1                 ;3318
000012  2802              CMP      r0,#2
000014  d007              BEQ      |L17.38|
;;;3326     {
;;;3327        return HAL_BUSY;
;;;3328     }
;;;3329     else if((htim->State == HAL_TIM_STATE_READY))
000016  f8940039          LDRB     r0,[r4,#0x39]
00001a  2801              CMP      r0,#1
00001c  d108              BNE      |L17.48|
;;;3330     {
;;;3331       if((BurstBuffer == 0 ) && (BurstLength > 0))
00001e  f1bc0f00          CMP      r12,#0
000022  d102              BNE      |L17.42|
000024  b10d              CBZ      r5,|L17.42|
                  |L17.38|
;;;3332       {
;;;3333         return HAL_ERROR;
;;;3334       }
;;;3335       else
;;;3336       {
;;;3337         htim->State = HAL_TIM_STATE_BUSY;
;;;3338       }
;;;3339     }
;;;3340     switch(BurstRequestSrc)
;;;3341     {
;;;3342       case TIM_DMA_UPDATE:
;;;3343       {
;;;3344         /* Set the DMA Period elapsed callback */
;;;3345         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3346   
;;;3347         /* Set the DMA error callback */
;;;3348         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3349   
;;;3350         /* Enable the DMA channel */
;;;3351         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3352       }
;;;3353       break;
;;;3354       case TIM_DMA_CC1:
;;;3355       {
;;;3356         /* Set the DMA Period elapsed callback */
;;;3357         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3358   
;;;3359         /* Set the DMA error callback */
;;;3360         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3361   
;;;3362         /* Enable the DMA channel */
;;;3363         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3364       }
;;;3365       break;
;;;3366       case TIM_DMA_CC2:
;;;3367       {
;;;3368         /* Set the DMA Period elapsed callback */
;;;3369         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3370   
;;;3371         /* Set the DMA error callback */
;;;3372         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3373   
;;;3374         /* Enable the DMA channel */
;;;3375         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3376       }
;;;3377       break;
;;;3378       case TIM_DMA_CC3:
;;;3379       {
;;;3380         /* Set the DMA Period elapsed callback */
;;;3381         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3382   
;;;3383         /* Set the DMA error callback */
;;;3384         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3385   
;;;3386         /* Enable the DMA channel */
;;;3387         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3388       }
;;;3389       break;
;;;3390       case TIM_DMA_CC4:
;;;3391       {
;;;3392         /* Set the DMA Period elapsed callback */
;;;3393         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3394   
;;;3395         /* Set the DMA error callback */
;;;3396         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3397   
;;;3398         /* Enable the DMA channel */
;;;3399         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3400       }
;;;3401       break;
;;;3402       case TIM_DMA_COM:
;;;3403       {
;;;3404         /* Set the DMA Period elapsed callback */
;;;3405         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3406   
;;;3407         /* Set the DMA error callback */
;;;3408         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3409   
;;;3410         /* Enable the DMA channel */
;;;3411         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3412       }
;;;3413       break;
;;;3414       case TIM_DMA_TRIGGER:
;;;3415       {
;;;3416         /* Set the DMA Period elapsed callback */
;;;3417         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3418   
;;;3419         /* Set the DMA error callback */
;;;3420         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3421   
;;;3422         /* Enable the DMA channel */
;;;3423         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3424       }
;;;3425       break;
;;;3426       default:
;;;3427       break;
;;;3428     }
;;;3429      /* configure the DMA Burst Mode */
;;;3430      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3431   
;;;3432      /* Enable the TIM DMA Request */
;;;3433      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3434   
;;;3435      htim->State = HAL_TIM_STATE_READY;
;;;3436   
;;;3437     /* Return function status */
;;;3438     return HAL_OK;
;;;3439   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L17.42|
00002a  2002              MOVS     r0,#2                 ;3337
00002c  f8840039          STRB     r0,[r4,#0x39]         ;3337
                  |L17.48|
000030  2701              MOVS     r7,#1                 ;3333
000032  482f              LDR      r0,|L17.240|
000034  492f              LDR      r1,|L17.244|
000036  eb072315          ADD      r3,r7,r5,LSR #8       ;3351
00003a  f5b66f00          CMP      r6,#0x800             ;3340
00003e  d039              BEQ      |L17.180|
000040  dc09              BGT      |L17.86|
000042  f5b67f80          CMP      r6,#0x100             ;3340
000046  d010              BEQ      |L17.106|
000048  f5b67f00          CMP      r6,#0x200             ;3340
00004c  d015              BEQ      |L17.122|
00004e  f5b66f80          CMP      r6,#0x400             ;3340
000052  d11c              BNE      |L17.142|
000054  e027              B        |L17.166|
                  |L17.86|
000056  f5b65f80          CMP      r6,#0x1000            ;3340
00005a  d032              BEQ      |L17.194|
00005c  f5b65f00          CMP      r6,#0x2000            ;3340
000060  d036              BEQ      |L17.208|
000062  f5b64f80          CMP      r6,#0x4000            ;3340
000066  d112              BNE      |L17.142|
000068  e03a              B        |L17.224|
                  |L17.106|
00006a  69e2              LDR      r2,[r4,#0x1c]         ;3345
00006c  4922              LDR      r1,|L17.248|
00006e  6291              STR      r1,[r2,#0x28]         ;3348
000070  69e1              LDR      r1,[r4,#0x1c]         ;3348
000072  6308              STR      r0,[r1,#0x30]         ;3351
000074  6822              LDR      r2,[r4,#0]            ;3353
000076  69e0              LDR      r0,[r4,#0x1c]         ;3353
000078  e005              B        |L17.134|
                  |L17.122|
00007a  6a22              LDR      r2,[r4,#0x20]         ;3357
00007c  6291              STR      r1,[r2,#0x28]         ;3360
00007e  6a21              LDR      r1,[r4,#0x20]         ;3360
000080  6308              STR      r0,[r1,#0x30]         ;3363
000082  6822              LDR      r2,[r4,#0]            ;3363
000084  6a20              LDR      r0,[r4,#0x20]         ;3363
                  |L17.134|
000086  4661              MOV      r1,r12                ;3351
000088  324c              ADDS     r2,r2,#0x4c           ;3351
00008a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.142|
00008e  6821              LDR      r1,[r4,#0]            ;3430
000090  ea480005          ORR      r0,r8,r5              ;3430
000094  6488              STR      r0,[r1,#0x48]         ;3430
000096  6820              LDR      r0,[r4,#0]            ;3433
000098  68c1              LDR      r1,[r0,#0xc]          ;3433
00009a  4331              ORRS     r1,r1,r6              ;3433
00009c  60c1              STR      r1,[r0,#0xc]          ;3433
00009e  f8847039          STRB     r7,[r4,#0x39]         ;3435
0000a2  2000              MOVS     r0,#0                 ;3438
0000a4  e7bf              B        |L17.38|
                  |L17.166|
0000a6  6a62              LDR      r2,[r4,#0x24]         ;3369
0000a8  6291              STR      r1,[r2,#0x28]         ;3372
0000aa  6a61              LDR      r1,[r4,#0x24]         ;3372
0000ac  6308              STR      r0,[r1,#0x30]         ;3375
0000ae  6822              LDR      r2,[r4,#0]            ;3377
0000b0  6a60              LDR      r0,[r4,#0x24]         ;3377
0000b2  e7e8              B        |L17.134|
                  |L17.180|
0000b4  6aa2              LDR      r2,[r4,#0x28]         ;3381
0000b6  6291              STR      r1,[r2,#0x28]         ;3384
0000b8  6aa1              LDR      r1,[r4,#0x28]         ;3384
0000ba  6308              STR      r0,[r1,#0x30]         ;3387
0000bc  6822              LDR      r2,[r4,#0]            ;3389
0000be  6aa0              LDR      r0,[r4,#0x28]         ;3389
0000c0  e7e1              B        |L17.134|
                  |L17.194|
0000c2  6ae2              LDR      r2,[r4,#0x2c]         ;3393
0000c4  6291              STR      r1,[r2,#0x28]         ;3396
0000c6  6ae1              LDR      r1,[r4,#0x2c]         ;3396
0000c8  6308              STR      r0,[r1,#0x30]         ;3399
0000ca  6822              LDR      r2,[r4,#0]            ;3401
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;3401
0000ce  e7da              B        |L17.134|
                  |L17.208|
0000d0  6b22              LDR      r2,[r4,#0x30]         ;3405
0000d2  490a              LDR      r1,|L17.252|
0000d4  6291              STR      r1,[r2,#0x28]         ;3408
0000d6  6b21              LDR      r1,[r4,#0x30]         ;3408
0000d8  6308              STR      r0,[r1,#0x30]         ;3411
0000da  6822              LDR      r2,[r4,#0]            ;3413
0000dc  6b20              LDR      r0,[r4,#0x30]         ;3413
0000de  e7d2              B        |L17.134|
                  |L17.224|
0000e0  6b62              LDR      r2,[r4,#0x34]         ;3417
0000e2  4907              LDR      r1,|L17.256|
0000e4  6291              STR      r1,[r2,#0x28]         ;3420
0000e6  6b61              LDR      r1,[r4,#0x34]         ;3420
0000e8  6308              STR      r0,[r1,#0x30]         ;3423
0000ea  6822              LDR      r2,[r4,#0]            ;3425
0000ec  6b60              LDR      r0,[r4,#0x34]         ;3425
0000ee  e7ca              B        |L17.134|
;;;3440   
                          ENDP

                  |L17.240|
                          DCD      TIM_DMAError
                  |L17.244|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.248|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.252|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.256|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3446     */
;;;3447   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3448   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3449     /* Check the parameters */
;;;3450     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3451   
;;;3452     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3453     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
00000a  d021              BEQ      |L18.80|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d00f              BEQ      |L18.58|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d10f              BNE      |L18.64|
000020  e014              B        |L18.76|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d015              BEQ      |L18.84|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d014              BEQ      |L18.88|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d105              BNE      |L18.64|
000034  e012              B        |L18.92|
                  |L18.54|
;;;3454     {
;;;3455       case TIM_DMA_UPDATE:
;;;3456       {
;;;3457         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3458       }
;;;3459       break;
000036  69e0              LDR      r0,[r4,#0x1c]
000038  e000              B        |L18.60|
                  |L18.58|
;;;3460       case TIM_DMA_CC1:
;;;3461       {
;;;3462         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003a  6a20              LDR      r0,[r4,#0x20]
                  |L18.60|
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L18.64|
;;;3463       }
;;;3464       break;
;;;3465       case TIM_DMA_CC2:
;;;3466       {
;;;3467         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3468       }
;;;3469       break;
;;;3470       case TIM_DMA_CC3:
;;;3471       {
;;;3472         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3473       }
;;;3474       break;
;;;3475       case TIM_DMA_CC4:
;;;3476       {
;;;3477         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3478       }
;;;3479       break;
;;;3480       case TIM_DMA_COM:
;;;3481       {
;;;3482         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3483       }
;;;3484       break;
;;;3485       case TIM_DMA_TRIGGER:
;;;3486       {
;;;3487         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
;;;3488       }
;;;3489       break;
;;;3490       default:
;;;3491       break;
;;;3492     }
;;;3493   
;;;3494     /* Disable the TIM Update DMA request */
;;;3495     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3496   
;;;3497     /* Return function status */
;;;3498     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;3499   }
00004a  bd70              POP      {r4-r6,pc}
                  |L18.76|
00004c  6a60              LDR      r0,[r4,#0x24]         ;3469
00004e  e7f5              B        |L18.60|
                  |L18.80|
000050  6aa0              LDR      r0,[r4,#0x28]         ;3474
000052  e7f3              B        |L18.60|
                  |L18.84|
000054  6ae0              LDR      r0,[r4,#0x2c]         ;3479
000056  e7f1              B        |L18.60|
                  |L18.88|
000058  6b20              LDR      r0,[r4,#0x30]         ;3484
00005a  e7ef              B        |L18.60|
                  |L18.92|
00005c  6b60              LDR      r0,[r4,#0x34]         ;3489
00005e  e7ed              B        |L18.60|
;;;3500   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2324     */
;;;2325   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2326   {
000002  4604              MOV      r4,r0
;;;2327     /* Check the parameters */
;;;2328     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2329   
;;;2330     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;2331   
;;;2332     /* Disable the TIM Peripheral Clock */
;;;2333     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L19.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L19.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L19.38|
;;;2334   
;;;2335     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2336     HAL_TIM_Encoder_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2337   
;;;2338     /* Change TIM state */
;;;2339     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;2340   
;;;2341     /* Release Lock */
;;;2342     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;2343   
;;;2344     return HAL_OK;
;;;2345   }
000036  bd10              POP      {r4,pc}
;;;2346   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4422     */
;;;4423   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4424   {
;;;4425     return htim->State;
;;;4426   }
000004  4770              BX       lr
;;;4427   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2234     */
;;;2235   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2236   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d003              BEQ      |L21.18|
;;;2237     uint32_t tmpsmcr = 0;
;;;2238     uint32_t tmpccmr1 = 0;
;;;2239     uint32_t tmpccer = 0;
;;;2240   
;;;2241     /* Check the TIM handle allocation */
;;;2242     if(htim == NULL)
;;;2243     {
;;;2244       return HAL_ERROR;
;;;2245     }
;;;2246   
;;;2247     /* Check the parameters */
;;;2248     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2249     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2250     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2251     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2252     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2253     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2254     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2255     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2256     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2257     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2258   
;;;2259     if(htim->State == HAL_TIM_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  b118              CBZ      r0,|L21.24|
000010  e008              B        |L21.36|
                  |L21.18|
000012  2001              MOVS     r0,#1                 ;2244
                  |L21.20|
;;;2260     {
;;;2261       /* Allocate lock resource and initialize it */
;;;2262       htim->Lock = HAL_UNLOCKED;
;;;2263       
;;;2264       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2265       HAL_TIM_Encoder_MspInit(htim);
;;;2266     }
;;;2267   
;;;2268     /* Set the TIM state */
;;;2269     htim->State= HAL_TIM_STATE_BUSY;
;;;2270   
;;;2271     /* Reset the SMS bits */
;;;2272     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2273   
;;;2274     /* Configure the Time base in the Encoder Mode */
;;;2275     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2276   
;;;2277     /* Get the TIMx SMCR register value */
;;;2278     tmpsmcr = htim->Instance->SMCR;
;;;2279   
;;;2280     /* Get the TIMx CCMR1 register value */
;;;2281     tmpccmr1 = htim->Instance->CCMR1;
;;;2282   
;;;2283     /* Get the TIMx CCER register value */
;;;2284     tmpccer = htim->Instance->CCER;
;;;2285   
;;;2286     /* Set the encoder Mode */
;;;2287     tmpsmcr |= sConfig->EncoderMode;
;;;2288   
;;;2289     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2290     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2291     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2292   
;;;2293     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2294     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2295     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2296     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2297     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2298   
;;;2299     /* Set the TI1 and the TI2 Polarities */
;;;2300     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2301     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2302     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2303   
;;;2304     /* Write to TIMx SMCR */
;;;2305     htim->Instance->SMCR = tmpsmcr;
;;;2306   
;;;2307     /* Write to TIMx CCMR1 */
;;;2308     htim->Instance->CCMR1 = tmpccmr1;
;;;2309   
;;;2310     /* Write to TIMx CCER */
;;;2311     htim->Instance->CCER = tmpccer;
;;;2312   
;;;2313     /* Initialize the TIM state*/
;;;2314     htim->State= HAL_TIM_STATE_READY;
;;;2315   
;;;2316     return HAL_OK;
;;;2317   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  2000              MOVS     r0,#0                 ;2262
00001a  f8840038          STRB     r0,[r4,#0x38]         ;2262
00001e  4620              MOV      r0,r4                 ;2265
000020  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.36|
000024  2002              MOVS     r0,#2                 ;2269
000026  f8840039          STRB     r0,[r4,#0x39]         ;2269
00002a  6820              LDR      r0,[r4,#0]            ;2272
00002c  6881              LDR      r1,[r0,#8]            ;2272
00002e  f0210107          BIC      r1,r1,#7              ;2272
000032  6081              STR      r1,[r0,#8]            ;2272
000034  1d21              ADDS     r1,r4,#4              ;2275
000036  6820              LDR      r0,[r4,#0]            ;2275
000038  f7fffffe          BL       TIM_Base_SetConfig
00003c  6822              LDR      r2,[r4,#0]            ;2278
00003e  6890              LDR      r0,[r2,#8]            ;2278
000040  6991              LDR      r1,[r2,#0x18]         ;2281
000042  6a16              LDR      r6,[r2,#0x20]         ;2284
000044  682b              LDR      r3,[r5,#0]            ;2287
000046  69af              LDR      r7,[r5,#0x18]         ;2291
000048  4303              ORRS     r3,r3,r0              ;2287
00004a  f2403003          MOV      r0,#0x303             ;2290
00004e  4381              BICS     r1,r1,r0              ;2290
000050  ea412107          ORR      r1,r1,r7,LSL #8       ;2291
000054  68a8              LDR      r0,[r5,#8]            ;2291
000056  69ef              LDR      r7,[r5,#0x1c]         ;2296
000058  4308              ORRS     r0,r0,r1              ;2291
00005a  f64f41fc          MOV      r1,#0xfcfc            ;2294
00005e  4388              BICS     r0,r0,r1              ;2294
000060  68e9              LDR      r1,[r5,#0xc]          ;2296
000062  ea402007          ORR      r0,r0,r7,LSL #8       ;2296
000066  4301              ORRS     r1,r1,r0              ;2296
000068  6928              LDR      r0,[r5,#0x10]         ;2297
00006a  6a2f              LDR      r7,[r5,#0x20]         ;2297
00006c  0100              LSLS     r0,r0,#4              ;2297
00006e  ea403007          ORR      r0,r0,r7,LSL #12      ;2297
000072  4308              ORRS     r0,r0,r1              ;2297
000074  6869              LDR      r1,[r5,#4]            ;2302
000076  696d              LDR      r5,[r5,#0x14]         ;2302
000078  f02606aa          BIC      r6,r6,#0xaa           ;2301
00007c  ea461505          ORR      r5,r6,r5,LSL #4       ;2302
000080  4329              ORRS     r1,r1,r5              ;2302
000082  6093              STR      r3,[r2,#8]            ;2305
000084  6822              LDR      r2,[r4,#0]            ;2308
000086  6190              STR      r0,[r2,#0x18]         ;2308
000088  6820              LDR      r0,[r4,#0]            ;2311
00008a  6201              STR      r1,[r0,#0x20]         ;2311
00008c  2001              MOVS     r0,#1                 ;2314
00008e  f8840039          STRB     r0,[r4,#0x39]         ;2314
000092  2000              MOVS     r0,#0                 ;2316
000094  e7be              B        |L21.20|
;;;2318   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2365     */
;;;2366   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2367   {
;;;2368     /* Prevent unused argument(s) compilation warning */
;;;2369     UNUSED(htim);
;;;2370     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2371               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2372      */
;;;2373   }
;;;2374   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2351     */
;;;2352   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2353   {
;;;2354     /* Prevent unused argument(s) compilation warning */
;;;2355     UNUSED(htim);
;;;2356     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2357               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2358      */
;;;2359   }
;;;2360   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start PROC
;;;2384   */
;;;2385   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2386   {
000002  4604              MOV      r4,r0
;;;2387     /* Check the parameters */
;;;2388     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2389   
;;;2390     /* Enable the encoder interface channels */
;;;2391     switch (Channel)
;;;2392     {
;;;2393       case TIM_CHANNEL_1:
;;;2394     {
;;;2395       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b191              CBZ      r1,|L24.46|
000008  2904              CMP      r1,#4                 ;2391
00000a  d004              BEQ      |L24.22|
;;;2396         break;
;;;2397     }
;;;2398       case TIM_CHANNEL_2:
;;;2399     {
;;;2400       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2401         break;
;;;2402     }
;;;2403       default :
;;;2404     {
;;;2405        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000c  2201              MOVS     r2,#1
00000e  2100              MOVS     r1,#0
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2406        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L24.22|
000016  2201              MOVS     r2,#1                 ;2400
000018  f05f0104          MOVS.W   r1,#4                 ;2400
                  |L24.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2407        break;
;;;2408       }
;;;2409     }
;;;2410     /* Enable the Peripheral */
;;;2411     __HAL_TIM_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0410101          ORR      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
;;;2412   
;;;2413     /* Return function status */
;;;2414     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2415   }
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  2201              MOVS     r2,#1                 ;2395
000030  2100              MOVS     r1,#0                 ;2395
000032  e7f3              B        |L24.28|
;;;2416   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2572   */
;;;2573   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2574   {
000004  4604              MOV      r4,r0
;;;2575     /* Check the parameters */
;;;2576     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2577   
;;;2578     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  9f06              LDR      r7,[sp,#0x18]
00000c  4698              MOV      r8,r3                 ;2574
00000e  2802              CMP      r0,#2
000010  d009              BEQ      |L25.38|
;;;2579     {
;;;2580        return HAL_BUSY;
;;;2581     }
;;;2582     else if((htim->State == HAL_TIM_STATE_READY))
000012  f8940039          LDRB     r0,[r4,#0x39]
000016  2801              CMP      r0,#1
000018  d10a              BNE      |L25.48|
;;;2583     {
;;;2584       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0))
00001a  b112              CBZ      r2,|L25.34|
00001c  f1b80f00          CMP      r8,#0
000020  d103              BNE      |L25.42|
                  |L25.34|
000022  b117              CBZ      r7,|L25.42|
;;;2585       {
;;;2586         return HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L25.38|
;;;2587       }
;;;2588       else
;;;2589       {
;;;2590         htim->State = HAL_TIM_STATE_BUSY;
;;;2591       }
;;;2592     }
;;;2593   
;;;2594     switch (Channel)
;;;2595     {
;;;2596       case TIM_CHANNEL_1:
;;;2597       {
;;;2598         /* Set the DMA Period elapsed callback */
;;;2599         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2600   
;;;2601         /* Set the DMA error callback */
;;;2602         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2603   
;;;2604         /* Enable the DMA channel */
;;;2605         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2606   
;;;2607         /* Enable the TIM Input Capture DMA request */
;;;2608         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2609   
;;;2610         /* Enable the Peripheral */
;;;2611         __HAL_TIM_ENABLE(htim);
;;;2612   
;;;2613         /* Enable the Capture compare channel */
;;;2614         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2615       }
;;;2616       break;
;;;2617   
;;;2618       case TIM_CHANNEL_2:
;;;2619       {
;;;2620         /* Set the DMA Period elapsed callback */
;;;2621         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2622   
;;;2623         /* Set the DMA error callback */
;;;2624         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2625         /* Enable the DMA channel */
;;;2626         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2627   
;;;2628         /* Enable the TIM Input Capture  DMA request */
;;;2629         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2630   
;;;2631         /* Enable the Peripheral */
;;;2632         __HAL_TIM_ENABLE(htim);
;;;2633   
;;;2634         /* Enable the Capture compare channel */
;;;2635         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2636       }
;;;2637       break;
;;;2638   
;;;2639       case TIM_CHANNEL_ALL:
;;;2640       {
;;;2641         /* Set the DMA Period elapsed callback */
;;;2642         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2643   
;;;2644         /* Set the DMA error callback */
;;;2645         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2646   
;;;2647         /* Enable the DMA channel */
;;;2648         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2649   
;;;2650         /* Set the DMA Period elapsed callback */
;;;2651         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2652   
;;;2653         /* Set the DMA error callback */
;;;2654         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2655   
;;;2656         /* Enable the DMA channel */
;;;2657         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2658   
;;;2659        /* Enable the Peripheral */
;;;2660         __HAL_TIM_ENABLE(htim);
;;;2661   
;;;2662         /* Enable the Capture compare channel */
;;;2663         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2664         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2665   
;;;2666         /* Enable the TIM Input Capture  DMA request */
;;;2667         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2668         /* Enable the TIM Input Capture  DMA request */
;;;2669         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2670       }
;;;2671       break;
;;;2672   
;;;2673       default:
;;;2674       break;
;;;2675     }
;;;2676     /* Return function status */
;;;2677     return HAL_OK;
;;;2678   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L25.42|
00002a  2002              MOVS     r0,#2                 ;2590
00002c  f8840039          STRB     r0,[r4,#0x39]         ;2590
                  |L25.48|
000030  4d35              LDR      r5,|L25.264|
000032  4e36              LDR      r6,|L25.268|
000034  b121              CBZ      r1,|L25.64|
000036  2904              CMP      r1,#4                 ;2594
000038  d01a              BEQ      |L25.112|
00003a  2918              CMP      r1,#0x18              ;2594
00003c  d161              BNE      |L25.258|
00003e  e032              B        |L25.166|
                  |L25.64|
000040  6a20              LDR      r0,[r4,#0x20]         ;2599
000042  463b              MOV      r3,r7                 ;2605
000044  6285              STR      r5,[r0,#0x28]         ;2602
000046  6a20              LDR      r0,[r4,#0x20]         ;2602
000048  6306              STR      r6,[r0,#0x30]         ;2605
00004a  6821              LDR      r1,[r4,#0]            ;2605
00004c  6a20              LDR      r0,[r4,#0x20]         ;2605
00004e  3134              ADDS     r1,r1,#0x34           ;2605
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;2608
000056  68c1              LDR      r1,[r0,#0xc]          ;2608
000058  f4417100          ORR      r1,r1,#0x200          ;2608
00005c  60c1              STR      r1,[r0,#0xc]          ;2608
00005e  6820              LDR      r0,[r4,#0]            ;2611
000060  6801              LDR      r1,[r0,#0]            ;2611
000062  f0410101          ORR      r1,r1,#1              ;2611
000066  6001              STR      r1,[r0,#0]            ;2611
000068  2201              MOVS     r2,#1                 ;2614
00006a  2100              MOVS     r1,#0                 ;2614
00006c  6820              LDR      r0,[r4,#0]            ;2616
00006e  e017              B        |L25.160|
                  |L25.112|
000070  6a60              LDR      r0,[r4,#0x24]         ;2621
000072  463b              MOV      r3,r7                 ;2626
000074  4642              MOV      r2,r8                 ;2626
000076  6285              STR      r5,[r0,#0x28]         ;2624
000078  6a60              LDR      r0,[r4,#0x24]         ;2624
00007a  6306              STR      r6,[r0,#0x30]         ;2626
00007c  6821              LDR      r1,[r4,#0]            ;2626
00007e  6a60              LDR      r0,[r4,#0x24]         ;2626
000080  3138              ADDS     r1,r1,#0x38           ;2626
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  6820              LDR      r0,[r4,#0]            ;2629
000088  68c1              LDR      r1,[r0,#0xc]          ;2629
00008a  f4416180          ORR      r1,r1,#0x400          ;2629
00008e  60c1              STR      r1,[r0,#0xc]          ;2629
000090  6820              LDR      r0,[r4,#0]            ;2632
000092  6801              LDR      r1,[r0,#0]            ;2632
000094  f0410101          ORR      r1,r1,#1              ;2632
000098  6001              STR      r1,[r0,#0]            ;2632
00009a  2201              MOVS     r2,#1                 ;2635
00009c  2104              MOVS     r1,#4                 ;2635
00009e  6820              LDR      r0,[r4,#0]            ;2635
                  |L25.160|
0000a0  f7fffffe          BL       TIM_CCxChannelCmd
0000a4  e02d              B        |L25.258|
                  |L25.166|
0000a6  6a20              LDR      r0,[r4,#0x20]         ;2642
0000a8  463b              MOV      r3,r7                 ;2648
0000aa  6285              STR      r5,[r0,#0x28]         ;2645
0000ac  6a20              LDR      r0,[r4,#0x20]         ;2645
0000ae  6306              STR      r6,[r0,#0x30]         ;2648
0000b0  6821              LDR      r1,[r4,#0]            ;2648
0000b2  6a20              LDR      r0,[r4,#0x20]         ;2648
0000b4  3134              ADDS     r1,r1,#0x34           ;2648
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6a60              LDR      r0,[r4,#0x24]         ;2651
0000bc  463b              MOV      r3,r7                 ;2657
0000be  4642              MOV      r2,r8                 ;2657
0000c0  6285              STR      r5,[r0,#0x28]         ;2654
0000c2  6a60              LDR      r0,[r4,#0x24]         ;2654
0000c4  6306              STR      r6,[r0,#0x30]         ;2657
0000c6  6821              LDR      r1,[r4,#0]            ;2657
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2657
0000ca  3138              ADDS     r1,r1,#0x38           ;2657
0000cc  f7fffffe          BL       HAL_DMA_Start_IT
0000d0  6820              LDR      r0,[r4,#0]            ;2660
0000d2  6801              LDR      r1,[r0,#0]            ;2660
0000d4  f0410101          ORR      r1,r1,#1              ;2660
0000d8  6001              STR      r1,[r0,#0]            ;2660
0000da  2201              MOVS     r2,#1                 ;2663
0000dc  2100              MOVS     r1,#0                 ;2663
0000de  6820              LDR      r0,[r4,#0]            ;2663
0000e0  f7fffffe          BL       TIM_CCxChannelCmd
0000e4  2201              MOVS     r2,#1                 ;2664
0000e6  2104              MOVS     r1,#4                 ;2664
0000e8  6820              LDR      r0,[r4,#0]            ;2664
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  6820              LDR      r0,[r4,#0]            ;2667
0000f0  68c1              LDR      r1,[r0,#0xc]          ;2667
0000f2  f4417100          ORR      r1,r1,#0x200          ;2667
0000f6  60c1              STR      r1,[r0,#0xc]          ;2667
0000f8  6820              LDR      r0,[r4,#0]            ;2669
0000fa  68c1              LDR      r1,[r0,#0xc]          ;2669
0000fc  f4416180          ORR      r1,r1,#0x400          ;2669
000100  60c1              STR      r1,[r0,#0xc]          ;2669
                  |L25.258|
000102  2000              MOVS     r0,#0                 ;2677
000104  e78f              B        |L25.38|
;;;2679   
                          ENDP

000106  0000              DCW      0x0000
                  |L25.264|
                          DCD      TIM_DMACaptureCplt
                  |L25.268|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2470   */
;;;2471   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2472   {
000002  4604              MOV      r4,r0
;;;2473     /* Check the parameters */
;;;2474     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2475   
;;;2476     /* Enable the encoder interface channels */
;;;2477     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2478     switch (Channel)
;;;2479     {
;;;2480       case TIM_CHANNEL_1:
;;;2481     {
;;;2482       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b189              CBZ      r1,|L26.44|
000008  2904              CMP      r1,#4                 ;2478
;;;2483       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2484         break;
;;;2485     }
;;;2486       case TIM_CHANNEL_2:
;;;2487     {
;;;2488       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000a  f04f0201          MOV      r2,#1
00000e  d016              BEQ      |L26.62|
;;;2489       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2490         break;
;;;2491     }
;;;2492       default :
;;;2493     {
;;;2494        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2495        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000016  2201              MOVS     r2,#1
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2496        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0410102          ORR      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
;;;2497        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2498        break;
00002a  e00b              B        |L26.68|
                  |L26.44|
00002c  2201              MOVS     r2,#1                 ;2482
00002e  2100              MOVS     r1,#0                 ;2482
000030  f7fffffe          BL       TIM_CCxChannelCmd
000034  6820              LDR      r0,[r4,#0]            ;2483
000036  68c1              LDR      r1,[r0,#0xc]          ;2483
000038  f0410102          ORR      r1,r1,#2              ;2483
00003c  e006              B        |L26.76|
                  |L26.62|
00003e  2104              MOVS     r1,#4                 ;2488
000040  f7fffffe          BL       TIM_CCxChannelCmd
                  |L26.68|
000044  6820              LDR      r0,[r4,#0]            ;2497
000046  68c1              LDR      r1,[r0,#0xc]          ;2497
000048  f0410104          ORR      r1,r1,#4              ;2497
                  |L26.76|
00004c  60c1              STR      r1,[r0,#0xc]          ;2483
;;;2499       }
;;;2500     }
;;;2501   
;;;2502     /* Enable the Peripheral */
;;;2503     __HAL_TIM_ENABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6801              LDR      r1,[r0,#0]
000052  f0410101          ORR      r1,r1,#1
000056  6001              STR      r1,[r0,#0]
;;;2504   
;;;2505     /* Return function status */
;;;2506     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;2507   }
00005a  bd10              POP      {r4,pc}
;;;2508   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop PROC
;;;2426   */
;;;2427   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2428   {
000002  4604              MOV      r4,r0
;;;2429     /* Check the parameters */
;;;2430       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2431   
;;;2432      /* Disable the Input Capture channels 1 and 2
;;;2433       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2434     switch (Channel)
;;;2435     {
;;;2436       case TIM_CHANNEL_1:
;;;2437     {
;;;2438        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b1d9              CBZ      r1,|L27.64|
000008  2904              CMP      r1,#4                 ;2434
00000a  d004              BEQ      |L27.22|
;;;2439         break;
;;;2440     }
;;;2441       case TIM_CHANNEL_2:
;;;2442     {
;;;2443       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2444         break;
;;;2445     }
;;;2446       default :
;;;2447     {
;;;2448       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2449       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L27.22|
000016  2200              MOVS     r2,#0                 ;2443
000018  f05f0104          MOVS.W   r1,#4                 ;2443
                  |L27.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2450        break;
;;;2451       }
;;;2452     }
;;;2453   
;;;2454     /* Disable the Peripheral */
;;;2455     __HAL_TIM_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a01              LDR      r1,[r0,#0x20]
000024  f2411211          MOV      r2,#0x1111
000028  4211              TST      r1,r2
00002a  d107              BNE      |L27.60|
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  1092              ASRS     r2,r2,#2
000030  4211              TST      r1,r2
000032  d103              BNE      |L27.60|
000034  6801              LDR      r1,[r0,#0]
000036  f0210101          BIC      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L27.60|
;;;2456   
;;;2457     /* Return function status */
;;;2458     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2459   }
00003e  bd10              POP      {r4,pc}
                  |L27.64|
000040  2200              MOVS     r2,#0                 ;2438
000042  4611              MOV      r1,r2                 ;2438
000044  e7ea              B        |L27.28|
;;;2460   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2689   */
;;;2690   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2691   {
000002  4604              MOV      r4,r0
;;;2692     /* Check the parameters */
;;;2693     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2694   
;;;2695     /* Disable the Input Capture channels 1 and 2
;;;2696       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2697     if(Channel == TIM_CHANNEL_1)
;;;2698     {
;;;2699       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b341              CBZ      r1,|L28.90|
;;;2700   
;;;2701       /* Disable the capture compare DMA Request 1 */
;;;2702       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2703     }
;;;2704     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2705     {
;;;2706       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2707   
;;;2708       /* Disable the capture compare DMA Request 2 */
;;;2709       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2710     }
;;;2711     else
;;;2712     {
;;;2713       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000a  f04f0200          MOV      r2,#0
00000e  d02d              BEQ      |L28.108|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2714       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2715   
;;;2716       /* Disable the capture compare DMA Request 1 and 2 */
;;;2717       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f4217100          BIC      r1,r1,#0x200
000028  60c1              STR      r1,[r0,#0xc]
                  |L28.42|
00002a  6820              LDR      r0,[r4,#0]            ;2709
00002c  68c1              LDR      r1,[r0,#0xc]          ;2709
00002e  f4216180          BIC      r1,r1,#0x400          ;2709
                  |L28.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2709
;;;2718       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2719     }
;;;2720   
;;;2721     /* Disable the Peripheral */
;;;2722     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L28.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L28.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L28.80|
;;;2723   
;;;2724     /* Change the htim state */
;;;2725     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f8840039          STRB     r0,[r4,#0x39]
;;;2726   
;;;2727     /* Return function status */
;;;2728     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2729   }
000058  bd10              POP      {r4,pc}
                  |L28.90|
00005a  2200              MOVS     r2,#0                 ;2699
00005c  4611              MOV      r1,r2                 ;2699
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2702
000064  68c1              LDR      r1,[r0,#0xc]          ;2702
000066  f4217100          BIC      r1,r1,#0x200          ;2702
00006a  e7e2              B        |L28.50|
                  |L28.108|
00006c  2104              MOVS     r1,#4                 ;2706
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  e7da              B        |L28.42|
;;;2730   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2518   */
;;;2519   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2520   {
000002  4604              MOV      r4,r0
;;;2521     /* Check the parameters */
;;;2522     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2523   
;;;2524     /* Disable the Input Capture channels 1 and 2
;;;2525       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2526     if(Channel == TIM_CHANNEL_1)
;;;2527     {
;;;2528       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b341              CBZ      r1,|L29.90|
;;;2529   
;;;2530       /* Disable the capture compare Interrupts 1 */
;;;2531     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2532     }
;;;2533     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2534     {
;;;2535       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2536   
;;;2537       /* Disable the capture compare Interrupts 2 */
;;;2538     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2539     }
;;;2540     else
;;;2541     {
;;;2542       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000a  f04f0200          MOV      r2,#0
00000e  d02d              BEQ      |L29.108|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2543       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2544   
;;;2545       /* Disable the capture compare Interrupts 1 and 2 */
;;;2546       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0210102          BIC      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
                  |L29.42|
00002a  6820              LDR      r0,[r4,#0]            ;2538
00002c  68c1              LDR      r1,[r0,#0xc]          ;2538
00002e  f0210104          BIC      r1,r1,#4              ;2538
                  |L29.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2538
;;;2547       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2548     }
;;;2549   
;;;2550     /* Disable the Peripheral */
;;;2551     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L29.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L29.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L29.80|
;;;2552   
;;;2553     /* Change the htim state */
;;;2554     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f8840039          STRB     r0,[r4,#0x39]
;;;2555   
;;;2556     /* Return function status */
;;;2557     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2558   }
000058  bd10              POP      {r4,pc}
                  |L29.90|
00005a  2200              MOVS     r2,#0                 ;2528
00005c  4611              MOV      r1,r2                 ;2528
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2531
000064  68c1              LDR      r1,[r0,#0xc]          ;2531
000066  f0210102          BIC      r1,r1,#2              ;2531
00006a  e7e2              B        |L29.50|
                  |L29.108|
00006c  2104              MOVS     r1,#4                 ;2535
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  e7da              B        |L29.42|
;;;2559   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4339     */
;;;4340   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4341   {
;;;4342     /* Prevent unused argument(s) compilation warning */
;;;4343     UNUSED(htim);
;;;4344     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4345               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4346      */
;;;4347   }
;;;4348   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3742   
;;;3743   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  f8902038          LDRB     r2,[r0,#0x38]
;;;3744   {
;;;3745     /* Check the parameters */
;;;3746     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3747     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3748   
;;;3749     /* Process Locked */
;;;3750     __HAL_LOCK(htim);
000004  2a01              CMP      r2,#1
000006  d00c              BEQ      |L31.34|
000008  2201              MOVS     r2,#1
00000a  f8002f38          STRB     r2,[r0,#0x38]!
;;;3751   
;;;3752     /* Change the TIM state */
;;;3753     htim->State = HAL_TIM_STATE_BUSY;
00000e  2302              MOVS     r3,#2
000010  7043              STRB     r3,[r0,#1]
;;;3754   
;;;3755     /* Set the event sources */
;;;3756     htim->Instance->EGR = EventSource;
000012  f8503c38          LDR      r3,[r0,#-0x38]
000016  6159              STR      r1,[r3,#0x14]
;;;3757   
;;;3758     /* Change the TIM state */
;;;3759     htim->State = HAL_TIM_STATE_READY;
000018  7042              STRB     r2,[r0,#1]
;;;3760   
;;;3761     __HAL_UNLOCK(htim);
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;3762   
;;;3763     /* Return function status */
;;;3764     return HAL_OK;
00001e  4608              MOV      r0,r1
;;;3765   }
000020  4770              BX       lr
                  |L31.34|
000022  2002              MOVS     r0,#2                 ;3750
000024  4770              BX       lr
;;;3766   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4297     */
;;;4298   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4299   {
;;;4300     /* Prevent unused argument(s) compilation warning */
;;;4301     UNUSED(htim);
;;;4302     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4303               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4304      */
;;;4305   }
;;;4306   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_ConfigChannel PROC
;;;2983     */
;;;2984   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2985   {
000004  4604              MOV      r4,r0
;;;2986     /* Check the parameters */
;;;2987     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2988     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;2989     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;2990     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;2991     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;2992   
;;;2993     __HAL_LOCK(htim);
000006  f8900038          LDRB     r0,[r0,#0x38]
00000a  460d              MOV      r5,r1                 ;2985
00000c  2801              CMP      r0,#1
00000e  d03d              BEQ      |L33.140|
000010  2601              MOVS     r6,#1
000012  f8846038          STRB     r6,[r4,#0x38]
;;;2994   
;;;2995     htim->State = HAL_TIM_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  f8840039          STRB     r0,[r4,#0x39]
00001c  b3aa              CBZ      r2,|L33.138|
;;;2996   
;;;2997     if (Channel == TIM_CHANNEL_1)
;;;2998     {
;;;2999       /* TI1 Configuration */
;;;3000       TIM_TI1_SetConfig(htim->Instance,
;;;3001                  sConfig->ICPolarity,
;;;3002                  sConfig->ICSelection,
;;;3003                  sConfig->ICFilter);
;;;3004   
;;;3005       /* Reset the IC1PSC Bits */
;;;3006       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3007   
;;;3008       /* Set the IC1PSC value */
;;;3009       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3010     }
;;;3011     else if (Channel == TIM_CHANNEL_2)
00001e  2a04              CMP      r2,#4
000020  d046              BEQ      |L33.176|
;;;3012     {
;;;3013       /* TI2 Configuration */
;;;3014       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3015   
;;;3016       TIM_TI2_SetConfig(htim->Instance,
;;;3017                         sConfig->ICPolarity,
;;;3018                         sConfig->ICSelection,
;;;3019                         sConfig->ICFilter);
;;;3020   
;;;3021       /* Reset the IC2PSC Bits */
;;;3022       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3023   
;;;3024       /* Set the IC2PSC value */
;;;3025       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3026     }
;;;3027     else if (Channel == TIM_CHANNEL_3)
000022  6820              LDR      r0,[r4,#0]
000024  2a08              CMP      r2,#8
000026  d055              BEQ      |L33.212|
;;;3028     {
;;;3029       /* TI3 Configuration */
;;;3030       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3031   
;;;3032       TIM_TI3_SetConfig(htim->Instance,
;;;3033                  sConfig->ICPolarity,
;;;3034                  sConfig->ICSelection,
;;;3035                  sConfig->ICFilter);
;;;3036   
;;;3037       /* Reset the IC3PSC Bits */
;;;3038       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3039   
;;;3040       /* Set the IC3PSC value */
;;;3041       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3042     }
;;;3043     else
;;;3044     {
;;;3045       /* TI4 Configuration */
;;;3046       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3047   
;;;3048       TIM_TI4_SetConfig(htim->Instance,
000028  e9d52700          LDRD     r2,r7,[r5,#0]
00002c  68e9              LDR      r1,[r5,#0xc]
00002e  6a03              LDR      r3,[r0,#0x20]
000030  f4235380          BIC      r3,r3,#0x1000
000034  6203              STR      r3,[r0,#0x20]
000036  f8d0c01c          LDR      r12,[r0,#0x1c]
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  f42c7c40          BIC      r12,r12,#0x300
000040  ea4c2707          ORR      r7,r12,r7,LSL #8
000044  f64f7cff          MOV      r12,#0xffff
000048  f4274770          BIC      r7,r7,#0xf000
00004c  ea0c3101          AND      r1,r12,r1,LSL #12
000050  4339              ORRS     r1,r1,r7
000052  f44f4720          MOV      r7,#0xa000
000056  f4234320          BIC      r3,r3,#0xa000
00005a  ea073202          AND      r2,r7,r2,LSL #12
00005e  431a              ORRS     r2,r2,r3
000060  61c1              STR      r1,[r0,#0x1c]
000062  6202              STR      r2,[r0,#0x20]
;;;3049                  sConfig->ICPolarity,
;;;3050                  sConfig->ICSelection,
;;;3051                  sConfig->ICFilter);
;;;3052   
;;;3053       /* Reset the IC4PSC Bits */
;;;3054       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
000064  6820              LDR      r0,[r4,#0]
000066  69c1              LDR      r1,[r0,#0x1c]
000068  f4216140          BIC      r1,r1,#0xc00
00006c  61c1              STR      r1,[r0,#0x1c]
;;;3055   
;;;3056       /* Set the IC4PSC value */
;;;3057       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
00006e  6820              LDR      r0,[r4,#0]
000070  69c1              LDR      r1,[r0,#0x1c]
000072  68aa              LDR      r2,[r5,#8]
000074  ea412102          ORR      r1,r1,r2,LSL #8
                  |L33.120|
000078  f8c0101c          STR.W    r1,[r0,#0x1c]         ;3041
                  |L33.124|
;;;3058     }
;;;3059   
;;;3060     htim->State = HAL_TIM_STATE_READY;
00007c  f8846039          STRB     r6,[r4,#0x39]
;;;3061   
;;;3062     __HAL_UNLOCK(htim);
000080  2000              MOVS     r0,#0
000082  f8840038          STRB     r0,[r4,#0x38]
                  |L33.134|
;;;3063   
;;;3064     return HAL_OK;
;;;3065   }
000086  e8bd81f0          POP      {r4-r8,pc}
                  |L33.138|
00008a  e001              B        |L33.144|
                  |L33.140|
00008c  2002              MOVS     r0,#2                 ;2993
00008e  e7fa              B        |L33.134|
                  |L33.144|
000090  e9d51200          LDRD     r1,r2,[r5,#0]         ;3000
000094  68eb              LDR      r3,[r5,#0xc]          ;3000
000096  6820              LDR      r0,[r4,#0]            ;3000
000098  f7fffffe          BL       TIM_TI1_SetConfig
00009c  6820              LDR      r0,[r4,#0]            ;3006
00009e  6981              LDR      r1,[r0,#0x18]         ;3006
0000a0  f021010c          BIC      r1,r1,#0xc            ;3006
0000a4  6181              STR      r1,[r0,#0x18]         ;3006
0000a6  6820              LDR      r0,[r4,#0]            ;3009
0000a8  6981              LDR      r1,[r0,#0x18]         ;3009
0000aa  68aa              LDR      r2,[r5,#8]            ;3009
0000ac  4311              ORRS     r1,r1,r2              ;3009
0000ae  e00f              B        |L33.208|
                  |L33.176|
0000b0  e9d51200          LDRD     r1,r2,[r5,#0]         ;3016
0000b4  68eb              LDR      r3,[r5,#0xc]          ;3016
0000b6  6820              LDR      r0,[r4,#0]            ;3016
0000b8  f7fffffe          BL       TIM_TI2_SetConfig
0000bc  6820              LDR      r0,[r4,#0]            ;3022
0000be  6981              LDR      r1,[r0,#0x18]         ;3022
0000c0  f4216140          BIC      r1,r1,#0xc00          ;3022
0000c4  6181              STR      r1,[r0,#0x18]         ;3022
0000c6  6820              LDR      r0,[r4,#0]            ;3025
0000c8  6981              LDR      r1,[r0,#0x18]         ;3025
0000ca  68aa              LDR      r2,[r5,#8]            ;3025
0000cc  ea412102          ORR      r1,r1,r2,LSL #8       ;3025
                  |L33.208|
0000d0  6181              STR      r1,[r0,#0x18]         ;3025
0000d2  e7d3              B        |L33.124|
                  |L33.212|
0000d4  e9d52c00          LDRD     r2,r12,[r5,#0]        ;3025
0000d8  7b2f              LDRB     r7,[r5,#0xc]          ;3032
0000da  6a01              LDR      r1,[r0,#0x20]         ;3032
0000dc  f4217180          BIC      r1,r1,#0x100          ;3032
0000e0  6201              STR      r1,[r0,#0x20]         ;3032
0000e2  69c1              LDR      r1,[r0,#0x1c]         ;3032
0000e4  6a03              LDR      r3,[r0,#0x20]         ;3032
0000e6  f0210103          BIC      r1,r1,#3              ;3032
0000ea  ea41010c          ORR      r1,r1,r12             ;3032
0000ee  f0210cf0          BIC      r12,r1,#0xf0          ;3032
0000f2  0739              LSLS     r1,r7,#28             ;3032
0000f4  f44f6720          MOV      r7,#0xa00             ;3032
0000f8  ea4c6111          ORR      r1,r12,r1,LSR #24     ;3032
0000fc  f4236320          BIC      r3,r3,#0xa00          ;3032
000100  ea072202          AND      r2,r7,r2,LSL #8       ;3032
000104  431a              ORRS     r2,r2,r3              ;3032
000106  61c1              STR      r1,[r0,#0x1c]         ;3032
000108  6202              STR      r2,[r0,#0x20]         ;3032
00010a  6820              LDR      r0,[r4,#0]            ;3038
00010c  69c1              LDR      r1,[r0,#0x1c]         ;3038
00010e  f021010c          BIC      r1,r1,#0xc            ;3038
000112  61c1              STR      r1,[r0,#0x1c]         ;3038
000114  6820              LDR      r0,[r4,#0]            ;3041
000116  69c1              LDR      r1,[r0,#0x1c]         ;3041
000118  68aa              LDR      r2,[r5,#8]            ;3041
00011a  4311              ORRS     r1,r1,r2              ;3041
00011c  e7ac              B        |L33.120|
;;;3066   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1530     */
;;;1531   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1532   {
000002  4604              MOV      r4,r0
;;;1533     /* Check the parameters */
;;;1534     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1535   
;;;1536     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1537   
;;;1538     /* Disable the TIM Peripheral Clock */
;;;1539     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L34.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L34.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L34.38|
;;;1540   
;;;1541     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1542     HAL_TIM_IC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1543   
;;;1544     /* Change TIM state */
;;;1545     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;1546   
;;;1547     /* Release Lock */
;;;1548     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;1549   
;;;1550     return HAL_OK;
;;;1551   }
000036  bd10              POP      {r4,pc}
;;;1552   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4402     */
;;;4403   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4404   {
;;;4405     return htim->State;
;;;4406   }
000004  4770              BX       lr
;;;4407   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1491     */
;;;1492   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1493   {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L36.14|
;;;1494     /* Check the TIM handle allocation */
;;;1495     if(htim == NULL)
;;;1496     {
;;;1497       return HAL_ERROR;
;;;1498     }
;;;1499   
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1502     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1503     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1504   
;;;1505     if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L36.18|
00000c  e007              B        |L36.30|
                  |L36.14|
00000e  2001              MOVS     r0,#1                 ;1497
;;;1506     {
;;;1507       /* Allocate lock resource and initialize it */
;;;1508       htim->Lock = HAL_UNLOCKED;
;;;1509       
;;;1510       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1511       HAL_TIM_IC_MspInit(htim);
;;;1512     }
;;;1513   
;;;1514     /* Set the TIM state */
;;;1515     htim->State= HAL_TIM_STATE_BUSY;
;;;1516   
;;;1517     /* Init the base time for the input capture */
;;;1518     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1519   
;;;1520     /* Initialize the TIM state*/
;;;1521     htim->State= HAL_TIM_STATE_READY;
;;;1522   
;;;1523     return HAL_OK;
;;;1524   }
000010  bd10              POP      {r4,pc}
                  |L36.18|
000012  2000              MOVS     r0,#0                 ;1508
000014  f8840038          STRB     r0,[r4,#0x38]         ;1508
000018  4620              MOV      r0,r4                 ;1511
00001a  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.30|
00001e  2002              MOVS     r0,#2                 ;1515
000020  f8840039          STRB     r0,[r4,#0x39]         ;1515
000024  1d21              ADDS     r1,r4,#4              ;1518
000026  6820              LDR      r0,[r4,#0]            ;1518
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;1521
00002e  f8840039          STRB     r0,[r4,#0x39]         ;1521
000032  2000              MOVS     r0,#0                 ;1523
000034  bd10              POP      {r4,pc}
;;;1525   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1571     */
;;;1572   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1573   {
;;;1574     /* Prevent unused argument(s) compilation warning */
;;;1575     UNUSED(htim);
;;;1576     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1577               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1578      */
;;;1579   }
;;;1580   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1557     */
;;;1558   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1559   {
;;;1560     /* Prevent unused argument(s) compilation warning */
;;;1561     UNUSED(htim);
;;;1562     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1563               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1564      */
;;;1565   }
;;;1566   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1591   */
;;;1592   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1593   {
000002  4604              MOV      r4,r0
;;;1594     /* Check the parameters */
;;;1595     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1596   
;;;1597     /* Enable the Input Capture channel */
;;;1598     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1599   
;;;1600     /* Enable the Peripheral */
;;;1601     __HAL_TIM_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0410101          ORR      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;1602   
;;;1603     /* Return function status */
;;;1604     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1605   }
000018  bd10              POP      {r4,pc}
;;;1606   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1764   */
;;;1765   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1766   {
000002  4604              MOV      r4,r0
;;;1767     /* Check the parameters */
;;;1768     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1769     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1770   
;;;1771     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  460e              MOV      r6,r1                 ;1766
00000a  2802              CMP      r0,#2
00000c  d005              BEQ      |L40.26|
;;;1772     {
;;;1773        return HAL_BUSY;
;;;1774     }
;;;1775     else if((htim->State == HAL_TIM_STATE_READY))
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2801              CMP      r0,#1
000014  d105              BNE      |L40.34|
;;;1776     {
;;;1777       if((pData == 0 ) && (Length > 0))
000016  b90a              CBNZ     r2,|L40.28|
000018  b103              CBZ      r3,|L40.28|
                  |L40.26|
;;;1778       {
;;;1779         return HAL_ERROR;
;;;1780       }
;;;1781       else
;;;1782       {
;;;1783         htim->State = HAL_TIM_STATE_BUSY;
;;;1784       }
;;;1785     }
;;;1786   
;;;1787     switch (Channel)
;;;1788     {
;;;1789       case TIM_CHANNEL_1:
;;;1790       {
;;;1791         /* Set the DMA Period elapsed callback */
;;;1792         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1793   
;;;1794         /* Set the DMA error callback */
;;;1795         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1796   
;;;1797         /* Enable the DMA channel */
;;;1798         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1799   
;;;1800         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1801         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1802       }
;;;1803       break;
;;;1804   
;;;1805       case TIM_CHANNEL_2:
;;;1806       {
;;;1807         /* Set the DMA Period elapsed callback */
;;;1808         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1809   
;;;1810         /* Set the DMA error callback */
;;;1811         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1812   
;;;1813         /* Enable the DMA channel */
;;;1814         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1815   
;;;1816         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1817         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1818       }
;;;1819       break;
;;;1820   
;;;1821       case TIM_CHANNEL_3:
;;;1822       {
;;;1823         /* Set the DMA Period elapsed callback */
;;;1824         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1825   
;;;1826         /* Set the DMA error callback */
;;;1827         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1828   
;;;1829         /* Enable the DMA channel */
;;;1830         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1831   
;;;1832         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1833         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1834       }
;;;1835       break;
;;;1836   
;;;1837       case TIM_CHANNEL_4:
;;;1838       {
;;;1839         /* Set the DMA Period elapsed callback */
;;;1840         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1841   
;;;1842         /* Set the DMA error callback */
;;;1843         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1844   
;;;1845         /* Enable the DMA channel */
;;;1846         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1847   
;;;1848         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1849         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1850       }
;;;1851       break;
;;;1852   
;;;1853       default:
;;;1854       break;
;;;1855     }
;;;1856   
;;;1857     /* Enable the Input Capture channel */
;;;1858     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1859   
;;;1860     /* Enable the Peripheral */
;;;1861     __HAL_TIM_ENABLE(htim);
;;;1862   
;;;1863     /* Return function status */
;;;1864     return HAL_OK;
;;;1865   }
00001a  bd70              POP      {r4-r6,pc}
                  |L40.28|
00001c  2002              MOVS     r0,#2                 ;1783
00001e  f8840039          STRB     r0,[r4,#0x39]         ;1783
                  |L40.34|
000022  4827              LDR      r0,|L40.192|
000024  4d27              LDR      r5,|L40.196|
000026  b136              CBZ      r6,|L40.54|
000028  2e04              CMP      r6,#4                 ;1787
00002a  d012              BEQ      |L40.82|
00002c  2e08              CMP      r6,#8                 ;1787
00002e  d02a              BEQ      |L40.134|
000030  2e0c              CMP      r6,#0xc               ;1787
000032  d11c              BNE      |L40.110|
000034  e035              B        |L40.162|
                  |L40.54|
000036  6a21              LDR      r1,[r4,#0x20]         ;1792
000038  6288              STR      r0,[r1,#0x28]         ;1795
00003a  6a20              LDR      r0,[r4,#0x20]         ;1795
00003c  6305              STR      r5,[r0,#0x30]         ;1798
00003e  6821              LDR      r1,[r4,#0]            ;1798
000040  6a20              LDR      r0,[r4,#0x20]         ;1798
000042  3134              ADDS     r1,r1,#0x34           ;1798
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;1801
00004a  68c1              LDR      r1,[r0,#0xc]          ;1801
00004c  f4417100          ORR      r1,r1,#0x200          ;1801
000050  e00c              B        |L40.108|
                  |L40.82|
000052  6a61              LDR      r1,[r4,#0x24]         ;1808
000054  6288              STR      r0,[r1,#0x28]         ;1811
000056  6a60              LDR      r0,[r4,#0x24]         ;1811
000058  6305              STR      r5,[r0,#0x30]         ;1814
00005a  6821              LDR      r1,[r4,#0]            ;1814
00005c  6a60              LDR      r0,[r4,#0x24]         ;1814
00005e  3138              ADDS     r1,r1,#0x38           ;1814
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;1817
000066  68c1              LDR      r1,[r0,#0xc]          ;1817
000068  f4416180          ORR      r1,r1,#0x400          ;1817
                  |L40.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;1801
                  |L40.110|
00006e  2201              MOVS     r2,#1                 ;1858
000070  4631              MOV      r1,r6                 ;1858
000072  6820              LDR      r0,[r4,#0]            ;1858
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  6820              LDR      r0,[r4,#0]            ;1861
00007a  6801              LDR      r1,[r0,#0]            ;1861
00007c  f0410101          ORR      r1,r1,#1              ;1861
000080  6001              STR      r1,[r0,#0]            ;1861
000082  2000              MOVS     r0,#0                 ;1864
000084  bd70              POP      {r4-r6,pc}
                  |L40.134|
000086  6aa1              LDR      r1,[r4,#0x28]         ;1824
000088  6288              STR      r0,[r1,#0x28]         ;1827
00008a  6aa0              LDR      r0,[r4,#0x28]         ;1827
00008c  6305              STR      r5,[r0,#0x30]         ;1830
00008e  6821              LDR      r1,[r4,#0]            ;1830
000090  6aa0              LDR      r0,[r4,#0x28]         ;1830
000092  313c              ADDS     r1,r1,#0x3c           ;1830
000094  f7fffffe          BL       HAL_DMA_Start_IT
000098  6820              LDR      r0,[r4,#0]            ;1833
00009a  68c1              LDR      r1,[r0,#0xc]          ;1833
00009c  f4416100          ORR      r1,r1,#0x800          ;1833
0000a0  e7e4              B        |L40.108|
                  |L40.162|
0000a2  6ae1              LDR      r1,[r4,#0x2c]         ;1840
0000a4  6288              STR      r0,[r1,#0x28]         ;1843
0000a6  6ae0              LDR      r0,[r4,#0x2c]         ;1843
0000a8  6305              STR      r5,[r0,#0x30]         ;1846
0000aa  6821              LDR      r1,[r4,#0]            ;1846
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1846
0000ae  3140              ADDS     r1,r1,#0x40           ;1846
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  6820              LDR      r0,[r4,#0]            ;1849
0000b6  68c1              LDR      r1,[r0,#0xc]          ;1849
0000b8  f4415180          ORR      r1,r1,#0x1000         ;1849
0000bc  e7d6              B        |L40.108|
;;;1866   
                          ENDP

0000be  0000              DCW      0x0000
                  |L40.192|
                          DCD      TIM_DMACaptureCplt
                  |L40.196|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1643   */
;;;1644   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1645   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L41.22|
;;;1646     /* Check the parameters */
;;;1647     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1648   
;;;1649     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L41.30|
00000c  2908              CMP      r1,#8
00000e  d015              BEQ      |L41.60|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L41.38|
000014  e016              B        |L41.68|
                  |L41.22|
;;;1650     {
;;;1651       case TIM_CHANNEL_1:
;;;1652       {
;;;1653         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1654         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1655       }
;;;1656       break;
00001c  e002              B        |L41.36|
                  |L41.30|
;;;1657   
;;;1658       case TIM_CHANNEL_2:
;;;1659       {
;;;1660         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1661         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L41.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1654
                  |L41.38|
;;;1662       }
;;;1663       break;
;;;1664   
;;;1665       case TIM_CHANNEL_3:
;;;1666       {
;;;1667         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1668         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1669       }
;;;1670       break;
;;;1671   
;;;1672       case TIM_CHANNEL_4:
;;;1673       {
;;;1674         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1675         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1676       }
;;;1677       break;
;;;1678   
;;;1679       default:
;;;1680       break;
;;;1681     }
;;;1682     /* Enable the Input Capture channel */
;;;1683     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1684   
;;;1685     /* Enable the Peripheral */
;;;1686     __HAL_TIM_ENABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6801              LDR      r1,[r0,#0]
000032  f0410101          ORR      r1,r1,#1
000036  6001              STR      r1,[r0,#0]
;;;1687   
;;;1688     /* Return function status */
;;;1689     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1690   }
00003a  bd10              POP      {r4,pc}
                  |L41.60|
00003c  68d0              LDR      r0,[r2,#0xc]          ;1668
00003e  f0400008          ORR      r0,r0,#8              ;1668
000042  e7ef              B        |L41.36|
                  |L41.68|
000044  68d0              LDR      r0,[r2,#0xc]          ;1675
000046  f0400010          ORR      r0,r0,#0x10           ;1675
00004a  e7eb              B        |L41.36|
;;;1691   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1617   */
;;;1618   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1619   {
000002  4604              MOV      r4,r0
;;;1620     /* Check the parameters */
;;;1621     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1622   
;;;1623     /* Disable the Input Capture channel */
;;;1624     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1625   
;;;1626     /* Disable the Peripheral */
;;;1627     __HAL_TIM_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4211              TST      r1,r2
000016  d107              BNE      |L42.40|
000018  6a01              LDR      r1,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4211              TST      r1,r2
00001e  d103              BNE      |L42.40|
000020  6801              LDR      r1,[r0,#0]
000022  f0210101          BIC      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
                  |L42.40|
;;;1628   
;;;1629     /* Return function status */
;;;1630     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1631   }
00002a  bd10              POP      {r4,pc}
;;;1632   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1877   */
;;;1878   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1879   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L43.22|
;;;1880     /* Check the parameters */
;;;1881     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1882     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1883   
;;;1884     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L43.30|
00000c  2908              CMP      r1,#8
00000e  d021              BEQ      |L43.84|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L43.38|
000014  e022              B        |L43.92|
                  |L43.22|
;;;1885     {
;;;1886       case TIM_CHANNEL_1:
;;;1887       {
;;;1888         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1889         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1890       }
;;;1891       break;
00001c  e002              B        |L43.36|
                  |L43.30|
;;;1892   
;;;1893       case TIM_CHANNEL_2:
;;;1894       {
;;;1895         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1896         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L43.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1889
                  |L43.38|
;;;1897       }
;;;1898       break;
;;;1899   
;;;1900       case TIM_CHANNEL_3:
;;;1901       {
;;;1902         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1903         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1904       }
;;;1905       break;
;;;1906   
;;;1907       case TIM_CHANNEL_4:
;;;1908       {
;;;1909         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1910         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1911       }
;;;1912       break;
;;;1913   
;;;1914       default:
;;;1915       break;
;;;1916     }
;;;1917   
;;;1918     /* Disable the Input Capture channel */
;;;1919     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1920   
;;;1921     /* Disable the Peripheral */
;;;1922     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4211              TST      r1,r2
000038  d107              BNE      |L43.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L43.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L43.74|
;;;1923   
;;;1924     /* Change the htim state */
;;;1925     htim->State = HAL_TIM_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f8840039          STRB     r0,[r4,#0x39]
;;;1926   
;;;1927     /* Return function status */
;;;1928     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1929   }
000052  bd10              POP      {r4,pc}
                  |L43.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;1903
000056  f4206000          BIC      r0,r0,#0x800          ;1903
00005a  e7e3              B        |L43.36|
                  |L43.92|
00005c  68d0              LDR      r0,[r2,#0xc]          ;1910
00005e  f4205080          BIC      r0,r0,#0x1000         ;1910
000062  e7df              B        |L43.36|
;;;1930   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1702   */
;;;1703   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1704   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L44.22|
;;;1705     /* Check the parameters */
;;;1706     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1707   
;;;1708     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L44.30|
00000c  2908              CMP      r1,#8
00000e  d01e              BEQ      |L44.78|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L44.38|
000014  e01f              B        |L44.86|
                  |L44.22|
;;;1709     {
;;;1710       case TIM_CHANNEL_1:
;;;1711       {
;;;1712         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1713         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1714       }
;;;1715       break;
00001c  e002              B        |L44.36|
                  |L44.30|
;;;1716   
;;;1717       case TIM_CHANNEL_2:
;;;1718       {
;;;1719         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1720         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L44.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1713
                  |L44.38|
;;;1721       }
;;;1722       break;
;;;1723   
;;;1724       case TIM_CHANNEL_3:
;;;1725       {
;;;1726         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1727         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1728       }
;;;1729       break;
;;;1730   
;;;1731       case TIM_CHANNEL_4:
;;;1732       {
;;;1733         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1734         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1735       }
;;;1736       break;
;;;1737   
;;;1738       default:
;;;1739       break;
;;;1740     }
;;;1741   
;;;1742     /* Disable the Input Capture channel */
;;;1743     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1744   
;;;1745     /* Disable the Peripheral */
;;;1746     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4211              TST      r1,r2
000038  d107              BNE      |L44.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L44.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L44.74|
;;;1747   
;;;1748     /* Return function status */
;;;1749     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1750   }
00004c  bd10              POP      {r4,pc}
                  |L44.78|
00004e  68d0              LDR      r0,[r2,#0xc]          ;1727
000050  f0200008          BIC      r0,r0,#8              ;1727
000054  e7e6              B        |L44.36|
                  |L44.86|
000056  68d0              LDR      r0,[r2,#0xc]          ;1734
000058  f0200010          BIC      r0,r0,#0x10           ;1734
00005c  e7e2              B        |L44.36|
;;;1751   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2751     */
;;;2752   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2753   {
000002  4604              MOV      r4,r0
;;;2754     /* Capture compare 1 event */
;;;2755     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  43c9              MVNS     r1,r1
00000e  0789              LSLS     r1,r1,#30
000010  d415              BMI      |L45.62|
;;;2756     {
;;;2757       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000012  68c1              LDR      r1,[r0,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d411              BMI      |L45.62|
;;;2758       {
;;;2759         {
;;;2760           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  1ee9              SUBS     r1,r5,#3
00001c  6101              STR      r1,[r0,#0x10]
;;;2761           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00001e  2001              MOVS     r0,#1
000020  7620              STRB     r0,[r4,#0x18]
;;;2762   
;;;2763           /* Input capture event */
;;;2764           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
000022  6820              LDR      r0,[r4,#0]
000024  6980              LDR      r0,[r0,#0x18]
000026  0780              LSLS     r0,r0,#30
;;;2765           {
;;;2766             HAL_TIM_IC_CaptureCallback(htim);
;;;2767           }
;;;2768           /* Output compare event */
;;;2769           else
;;;2770           {
;;;2771             HAL_TIM_OC_DelayElapsedCallback(htim);
000028  4620              MOV      r0,r4
00002a  d002              BEQ      |L45.50|
00002c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000030  e004              B        |L45.60|
                  |L45.50|
000032  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2772             HAL_TIM_PWM_PulseFinishedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.60|
;;;2773           }
;;;2774           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003c  7625              STRB     r5,[r4,#0x18]
                  |L45.62|
;;;2775         }
;;;2776       }
;;;2777     }
;;;2778     /* Capture compare 2 event */
;;;2779     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
00003e  6820              LDR      r0,[r4,#0]
000040  6901              LDR      r1,[r0,#0x10]
000042  43c9              MVNS     r1,r1
000044  0749              LSLS     r1,r1,#29
000046  d417              BMI      |L45.120|
;;;2780     {
;;;2781       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000048  68c1              LDR      r1,[r0,#0xc]
00004a  43c9              MVNS     r1,r1
00004c  0749              LSLS     r1,r1,#29
00004e  d413              BMI      |L45.120|
;;;2782       {
;;;2783         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000050  f06f0104          MVN      r1,#4
000054  6101              STR      r1,[r0,#0x10]
;;;2784         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000056  2002              MOVS     r0,#2
000058  7620              STRB     r0,[r4,#0x18]
;;;2785         /* Input capture event */
;;;2786         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
00005a  6820              LDR      r0,[r4,#0]
00005c  6980              LDR      r0,[r0,#0x18]
00005e  f4107f40          TST      r0,#0x300
;;;2787         {
;;;2788           HAL_TIM_IC_CaptureCallback(htim);
;;;2789         }
;;;2790         /* Output compare event */
;;;2791         else
;;;2792         {
;;;2793           HAL_TIM_OC_DelayElapsedCallback(htim);
000062  4620              MOV      r0,r4
000064  d002              BEQ      |L45.108|
000066  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006a  e004              B        |L45.118|
                  |L45.108|
00006c  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2794           HAL_TIM_PWM_PulseFinishedCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.118|
;;;2795         }
;;;2796         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000076  7625              STRB     r5,[r4,#0x18]
                  |L45.120|
;;;2797       }
;;;2798     }
;;;2799     /* Capture compare 3 event */
;;;2800     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000078  6820              LDR      r0,[r4,#0]
00007a  6901              LDR      r1,[r0,#0x10]
00007c  43c9              MVNS     r1,r1
00007e  0709              LSLS     r1,r1,#28
000080  d416              BMI      |L45.176|
;;;2801     {
;;;2802       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000082  68c1              LDR      r1,[r0,#0xc]
000084  43c9              MVNS     r1,r1
000086  0709              LSLS     r1,r1,#28
000088  d412              BMI      |L45.176|
;;;2803       {
;;;2804         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008a  f06f0108          MVN      r1,#8
00008e  6101              STR      r1,[r0,#0x10]
;;;2805         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000090  2004              MOVS     r0,#4
000092  7620              STRB     r0,[r4,#0x18]
;;;2806         /* Input capture event */
;;;2807         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
000094  6820              LDR      r0,[r4,#0]
000096  69c0              LDR      r0,[r0,#0x1c]
000098  0780              LSLS     r0,r0,#30
;;;2808         {
;;;2809           HAL_TIM_IC_CaptureCallback(htim);
;;;2810         }
;;;2811         /* Output compare event */
;;;2812         else
;;;2813         {
;;;2814           HAL_TIM_OC_DelayElapsedCallback(htim);
00009a  4620              MOV      r0,r4
00009c  d002              BEQ      |L45.164|
00009e  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a2  e004              B        |L45.174|
                  |L45.164|
0000a4  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2815           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.174|
;;;2816         }
;;;2817         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ae  7625              STRB     r5,[r4,#0x18]
                  |L45.176|
;;;2818       }
;;;2819     }
;;;2820     /* Capture compare 4 event */
;;;2821     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6901              LDR      r1,[r0,#0x10]
0000b4  43c9              MVNS     r1,r1
0000b6  06c9              LSLS     r1,r1,#27
0000b8  d417              BMI      |L45.234|
;;;2822     {
;;;2823       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000ba  68c1              LDR      r1,[r0,#0xc]
0000bc  43c9              MVNS     r1,r1
0000be  06c9              LSLS     r1,r1,#27
0000c0  d413              BMI      |L45.234|
;;;2824       {
;;;2825         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c2  f06f0110          MVN      r1,#0x10
0000c6  6101              STR      r1,[r0,#0x10]
;;;2826         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000c8  2008              MOVS     r0,#8
0000ca  7620              STRB     r0,[r4,#0x18]
;;;2827         /* Input capture event */
;;;2828         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0000cc  6820              LDR      r0,[r4,#0]
0000ce  69c0              LDR      r0,[r0,#0x1c]
0000d0  f4107f40          TST      r0,#0x300
;;;2829         {
;;;2830           HAL_TIM_IC_CaptureCallback(htim);
;;;2831         }
;;;2832         /* Output compare event */
;;;2833         else
;;;2834         {
;;;2835           HAL_TIM_OC_DelayElapsedCallback(htim);
0000d4  4620              MOV      r0,r4
0000d6  d002              BEQ      |L45.222|
0000d8  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000dc  e004              B        |L45.232|
                  |L45.222|
0000de  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2836           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.232|
;;;2837         }
;;;2838         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000e8  7625              STRB     r5,[r4,#0x18]
                  |L45.234|
;;;2839       }
;;;2840     }
;;;2841     /* TIM Update event */
;;;2842     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  6901              LDR      r1,[r0,#0x10]
0000ee  43c9              MVNS     r1,r1
0000f0  07c9              LSLS     r1,r1,#31
0000f2  d108              BNE      |L45.262|
;;;2843     {
;;;2844       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f4  68c1              LDR      r1,[r0,#0xc]
0000f6  43c9              MVNS     r1,r1
0000f8  07c9              LSLS     r1,r1,#31
0000fa  d104              BNE      |L45.262|
;;;2845       {
;;;2846         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
0000fc  1e89              SUBS     r1,r1,#2
0000fe  6101              STR      r1,[r0,#0x10]
;;;2847         HAL_TIM_PeriodElapsedCallback(htim);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.262|
;;;2848       }
;;;2849     }
;;;2850     /* TIM Break input event */
;;;2851     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
000106  6820              LDR      r0,[r4,#0]
000108  6901              LDR      r1,[r0,#0x10]
00010a  43c9              MVNS     r1,r1
00010c  0609              LSLS     r1,r1,#24
00010e  d409              BMI      |L45.292|
;;;2852     {
;;;2853       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000110  68c1              LDR      r1,[r0,#0xc]
000112  43c9              MVNS     r1,r1
000114  0609              LSLS     r1,r1,#24
000116  d405              BMI      |L45.292|
;;;2854       {
;;;2855         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000118  f06f0180          MVN      r1,#0x80
00011c  6101              STR      r1,[r0,#0x10]
;;;2856         HAL_TIMEx_BreakCallback(htim);
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.292|
;;;2857       }
;;;2858     }
;;;2859     /* TIM Trigger detection event */
;;;2860     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000124  6820              LDR      r0,[r4,#0]
000126  6901              LDR      r1,[r0,#0x10]
000128  43c9              MVNS     r1,r1
00012a  0649              LSLS     r1,r1,#25
00012c  d409              BMI      |L45.322|
;;;2861     {
;;;2862       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00012e  68c1              LDR      r1,[r0,#0xc]
000130  43c9              MVNS     r1,r1
000132  0649              LSLS     r1,r1,#25
000134  d405              BMI      |L45.322|
;;;2863       {
;;;2864         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000136  f06f0140          MVN      r1,#0x40
00013a  6101              STR      r1,[r0,#0x10]
;;;2865         HAL_TIM_TriggerCallback(htim);
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.322|
;;;2866       }
;;;2867     }
;;;2868     /* TIM commutation event */
;;;2869     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000142  6820              LDR      r0,[r4,#0]
000144  6901              LDR      r1,[r0,#0x10]
000146  43c9              MVNS     r1,r1
000148  0689              LSLS     r1,r1,#26
00014a  d40b              BMI      |L45.356|
;;;2870     {
;;;2871       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00014c  68c1              LDR      r1,[r0,#0xc]
00014e  43c9              MVNS     r1,r1
000150  0689              LSLS     r1,r1,#26
000152  d407              BMI      |L45.356|
;;;2872       {
;;;2873         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
000154  f06f0120          MVN      r1,#0x20
000158  6101              STR      r1,[r0,#0x10]
;;;2874         HAL_TIMEx_CommutationCallback(htim);
00015a  4620              MOV      r0,r4
00015c  e8bd4070          POP      {r4-r6,lr}
000160  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
                  |L45.356|
;;;2875       }
;;;2876     }
;;;2877   }
000164  bd70              POP      {r4-r6,pc}
;;;2878   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2914     */
;;;2915   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2916   {
000002  4604              MOV      r4,r0
;;;2917     /* Check the parameters */
;;;2918     assert_param(IS_TIM_CHANNELS(Channel));
;;;2919     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2920     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2921   
;;;2922     /* Check input state */
;;;2923     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d00d              BEQ      |L46.40|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;2924   
;;;2925     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
000018  b142              CBZ      r2,|L46.44|
;;;2926   
;;;2927     switch (Channel)
00001a  2a04              CMP      r2,#4
00001c  d00a              BEQ      |L46.52|
00001e  2a08              CMP      r2,#8
000020  d00c              BEQ      |L46.60|
000022  2a0c              CMP      r2,#0xc
000024  d111              BNE      |L46.74|
000026  e00d              B        |L46.68|
                  |L46.40|
000028  2002              MOVS     r0,#2                 ;2923
;;;2928     {
;;;2929       case TIM_CHANNEL_1:
;;;2930       {
;;;2931         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2932         /* Configure the TIM Channel 1 in Output Compare */
;;;2933         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2934       }
;;;2935       break;
;;;2936   
;;;2937       case TIM_CHANNEL_2:
;;;2938       {
;;;2939         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2940         /* Configure the TIM Channel 2 in Output Compare */
;;;2941         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2942       }
;;;2943       break;
;;;2944   
;;;2945       case TIM_CHANNEL_3:
;;;2946       {
;;;2947          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2948         /* Configure the TIM Channel 3 in Output Compare */
;;;2949         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2950       }
;;;2951       break;
;;;2952   
;;;2953       case TIM_CHANNEL_4:
;;;2954       {
;;;2955         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2956          /* Configure the TIM Channel 4 in Output Compare */
;;;2957          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2958       }
;;;2959       break;
;;;2960   
;;;2961       default:
;;;2962       break;
;;;2963     }
;;;2964     htim->State = HAL_TIM_STATE_READY;
;;;2965   
;;;2966     __HAL_UNLOCK(htim);
;;;2967   
;;;2968     return HAL_OK;
;;;2969   }
00002a  bd70              POP      {r4-r6,pc}
                  |L46.44|
00002c  6820              LDR      r0,[r4,#0]            ;2933
00002e  f7fffffe          BL       TIM_OC1_SetConfig
000032  e00a              B        |L46.74|
                  |L46.52|
000034  6820              LDR      r0,[r4,#0]            ;2941
000036  f7fffffe          BL       TIM_OC2_SetConfig
00003a  e006              B        |L46.74|
                  |L46.60|
00003c  6820              LDR      r0,[r4,#0]            ;2949
00003e  f7fffffe          BL       TIM_OC3_SetConfig
000042  e002              B        |L46.74|
                  |L46.68|
000044  6820              LDR      r0,[r4,#0]            ;2957
000046  f7fffffe          BL       TIM_OC4_SetConfig
                  |L46.74|
00004a  f8845039          STRB     r5,[r4,#0x39]         ;2964
00004e  2000              MOVS     r0,#0                 ;2966
000050  f8840038          STRB     r0,[r4,#0x38]         ;2966
000054  bd70              POP      {r4-r6,pc}
;;;2970   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522      /* Check the parameters */
;;;523      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;524    
;;;525       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;526    
;;;527      /* Disable the TIM Peripheral Clock */
;;;528      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L47.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L47.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L47.38|
;;;529    
;;;530      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;531      HAL_TIM_OC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;532    
;;;533      /* Change TIM state */
;;;534      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;535    
;;;536      /* Release Lock */
;;;537      __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;538    
;;;539      return HAL_OK;
;;;540    }
000036  bd10              POP      {r4,pc}
;;;541    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4284     */
;;;4285   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4286   {
;;;4287     /* Prevent unused argument(s) compilation warning */
;;;4288     UNUSED(htim);
;;;4289     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4290               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4291      */
;;;4292   }
;;;4293   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4382     */
;;;4383   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4384   {
;;;4385     return htim->State;
;;;4386   }
000004  4770              BX       lr
;;;4387   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;480      */
;;;481    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;482    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L50.14|
;;;483      /* Check the TIM handle allocation */
;;;484      if(htim == NULL)
;;;485      {
;;;486        return HAL_ERROR;
;;;487      }
;;;488    
;;;489      /* Check the parameters */
;;;490      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;491      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;492      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;493    
;;;494      if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L50.18|
00000c  e007              B        |L50.30|
                  |L50.14|
00000e  2001              MOVS     r0,#1                 ;486
;;;495      {
;;;496        /* Allocate lock resource and initialize it */
;;;497        htim->Lock = HAL_UNLOCKED;
;;;498        
;;;499        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;500        HAL_TIM_OC_MspInit(htim);
;;;501      }
;;;502    
;;;503      /* Set the TIM state */
;;;504      htim->State= HAL_TIM_STATE_BUSY;
;;;505    
;;;506      /* Init the base time for the Output Compare */
;;;507      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;508    
;;;509      /* Initialize the TIM state*/
;;;510      htim->State= HAL_TIM_STATE_READY;
;;;511    
;;;512      return HAL_OK;
;;;513    }
000010  bd10              POP      {r4,pc}
                  |L50.18|
000012  2000              MOVS     r0,#0                 ;497
000014  f8840038          STRB     r0,[r4,#0x38]         ;497
000018  4620              MOV      r0,r4                 ;500
00001a  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.30|
00001e  2002              MOVS     r0,#2                 ;504
000020  f8840039          STRB     r0,[r4,#0x39]         ;504
000024  1d21              ADDS     r1,r4,#4              ;507
000026  6820              LDR      r0,[r4,#0]            ;507
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;510
00002e  f8840039          STRB     r0,[r4,#0x39]         ;510
000032  2000              MOVS     r0,#0                 ;512
000034  bd10              POP      {r4,pc}
;;;514    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;560      */
;;;561    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;562    {
;;;563      /* Prevent unused argument(s) compilation warning */
;;;564      UNUSED(htim);
;;;565      /* NOTE : This function Should not be modified, when the callback is needed,
;;;566                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;567       */
;;;568    }
;;;569    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;546      */
;;;547    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;548    {
;;;549      /* Prevent unused argument(s) compilation warning */
;;;550      UNUSED(htim);
;;;551      /* NOTE : This function Should not be modified, when the callback is needed,
;;;552                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;553       */
;;;554    }
;;;555    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;580    */
;;;581    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;582    {
000002  4604              MOV      r4,r0
;;;583      /* Check the parameters */
;;;584      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;585    
;;;586      /* Enable the Output compare channel */
;;;587      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;588    
;;;589      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4907              LDR      r1,|L53.44|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d103              BNE      |L53.28|
;;;590      {
;;;591        /* Enable the main output */
;;;592        __HAL_TIM_MOE_ENABLE(htim);
000014  6c41              LDR      r1,[r0,#0x44]
000016  f4414100          ORR      r1,r1,#0x8000
00001a  6441              STR      r1,[r0,#0x44]
                  |L53.28|
;;;593      }
;;;594    
;;;595      /* Enable the Peripheral */
;;;596      __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410101          ORR      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
;;;597    
;;;598      /* Return function status */
;;;599      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;600    }
000028  bd10              POP      {r4,pc}
;;;601    
                          ENDP

00002a  0000              DCW      0x0000
                  |L53.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;778    */
;;;779    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;780    {
000002  4604              MOV      r4,r0
;;;781      /* Check the parameters */
;;;782      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;783    
;;;784      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;780
00000a  460d              MOV      r5,r1                 ;780
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L54.28|
;;;785      {
;;;786         return HAL_BUSY;
;;;787      }
;;;788      else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L54.36|
;;;789      {
;;;790        if(((uint32_t)pData == 0 ) && (Length > 0))
000018  b90e              CBNZ     r6,|L54.30|
00001a  b103              CBZ      r3,|L54.30|
                  |L54.28|
;;;791        {
;;;792          return HAL_ERROR;
;;;793        }
;;;794        else
;;;795        {
;;;796          htim->State = HAL_TIM_STATE_BUSY;
;;;797        }
;;;798      }
;;;799      switch (Channel)
;;;800      {
;;;801        case TIM_CHANNEL_1:
;;;802        {
;;;803          /* Set the DMA Period elapsed callback */
;;;804          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;805    
;;;806          /* Set the DMA error callback */
;;;807          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;808    
;;;809          /* Enable the DMA channel */
;;;810          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;811    
;;;812          /* Enable the TIM Capture/Compare 1 DMA request */
;;;813          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;814        }
;;;815        break;
;;;816    
;;;817        case TIM_CHANNEL_2:
;;;818        {
;;;819          /* Set the DMA Period elapsed callback */
;;;820          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;821    
;;;822          /* Set the DMA error callback */
;;;823          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;824    
;;;825          /* Enable the DMA channel */
;;;826          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;827    
;;;828          /* Enable the TIM Capture/Compare 2 DMA request */
;;;829          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;830        }
;;;831        break;
;;;832    
;;;833        case TIM_CHANNEL_3:
;;;834        {
;;;835          /* Set the DMA Period elapsed callback */
;;;836          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;837    
;;;838          /* Set the DMA error callback */
;;;839          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;840    
;;;841          /* Enable the DMA channel */
;;;842          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;843    
;;;844          /* Enable the TIM Capture/Compare 3 DMA request */
;;;845          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;846        }
;;;847        break;
;;;848    
;;;849        case TIM_CHANNEL_4:
;;;850        {
;;;851         /* Set the DMA Period elapsed callback */
;;;852          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;853    
;;;854          /* Set the DMA error callback */
;;;855          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;856    
;;;857          /* Enable the DMA channel */
;;;858          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;859    
;;;860          /* Enable the TIM Capture/Compare 4 DMA request */
;;;861          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;862        }
;;;863        break;
;;;864    
;;;865        default:
;;;866        break;
;;;867      }
;;;868    
;;;869      /* Enable the Output compare channel */
;;;870      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;871    
;;;872      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;873      {
;;;874        /* Enable the main output */
;;;875        __HAL_TIM_MOE_ENABLE(htim);
;;;876      }
;;;877    
;;;878      /* Enable the Peripheral */
;;;879      __HAL_TIM_ENABLE(htim);
;;;880    
;;;881      /* Return function status */
;;;882      return HAL_OK;
;;;883    }
00001c  bd70              POP      {r4-r6,pc}
                  |L54.30|
00001e  2002              MOVS     r0,#2                 ;796
000020  f8840039          STRB     r0,[r4,#0x39]         ;796
                  |L54.36|
000024  482c              LDR      r0,|L54.216|
000026  492d              LDR      r1,|L54.220|
000028  b135              CBZ      r5,|L54.56|
00002a  2d04              CMP      r5,#4                 ;799
00002c  d013              BEQ      |L54.86|
00002e  2d08              CMP      r5,#8                 ;799
000030  d034              BEQ      |L54.156|
000032  2d0c              CMP      r5,#0xc               ;799
000034  d11e              BNE      |L54.116|
000036  e040              B        |L54.186|
                  |L54.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;804
00003a  6290              STR      r0,[r2,#0x28]         ;807
00003c  6a20              LDR      r0,[r4,#0x20]         ;807
00003e  6301              STR      r1,[r0,#0x30]         ;810
000040  6822              LDR      r2,[r4,#0]            ;810
000042  4631              MOV      r1,r6                 ;810
000044  3234              ADDS     r2,r2,#0x34           ;810
000046  6a20              LDR      r0,[r4,#0x20]         ;810
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;813
00004e  68c1              LDR      r1,[r0,#0xc]          ;813
000050  f4417100          ORR      r1,r1,#0x200          ;813
000054  e00d              B        |L54.114|
                  |L54.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;820
000058  6290              STR      r0,[r2,#0x28]         ;823
00005a  6a60              LDR      r0,[r4,#0x24]         ;823
00005c  6301              STR      r1,[r0,#0x30]         ;826
00005e  6822              LDR      r2,[r4,#0]            ;826
000060  4631              MOV      r1,r6                 ;826
000062  3238              ADDS     r2,r2,#0x38           ;826
000064  6a60              LDR      r0,[r4,#0x24]         ;826
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;829
00006c  68c1              LDR      r1,[r0,#0xc]          ;829
00006e  f4416180          ORR      r1,r1,#0x400          ;829
                  |L54.114|
000072  60c1              STR      r1,[r0,#0xc]          ;813
                  |L54.116|
000074  2201              MOVS     r2,#1                 ;870
000076  4629              MOV      r1,r5                 ;870
000078  6820              LDR      r0,[r4,#0]            ;870
00007a  f7fffffe          BL       TIM_CCxChannelCmd
00007e  4918              LDR      r1,|L54.224|
000080  6820              LDR      r0,[r4,#0]            ;872
000082  4288              CMP      r0,r1                 ;872
000084  d103              BNE      |L54.142|
000086  6c41              LDR      r1,[r0,#0x44]         ;875
000088  f4414100          ORR      r1,r1,#0x8000         ;875
00008c  6441              STR      r1,[r0,#0x44]         ;875
                  |L54.142|
00008e  6820              LDR      r0,[r4,#0]            ;879
000090  6801              LDR      r1,[r0,#0]            ;879
000092  f0410101          ORR      r1,r1,#1              ;879
000096  6001              STR      r1,[r0,#0]            ;879
000098  2000              MOVS     r0,#0                 ;882
00009a  bd70              POP      {r4-r6,pc}
                  |L54.156|
00009c  6aa2              LDR      r2,[r4,#0x28]         ;836
00009e  6290              STR      r0,[r2,#0x28]         ;839
0000a0  6aa0              LDR      r0,[r4,#0x28]         ;839
0000a2  6301              STR      r1,[r0,#0x30]         ;842
0000a4  6822              LDR      r2,[r4,#0]            ;842
0000a6  4631              MOV      r1,r6                 ;842
0000a8  323c              ADDS     r2,r2,#0x3c           ;842
0000aa  6aa0              LDR      r0,[r4,#0x28]         ;842
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  6820              LDR      r0,[r4,#0]            ;845
0000b2  68c1              LDR      r1,[r0,#0xc]          ;845
0000b4  f4416100          ORR      r1,r1,#0x800          ;845
0000b8  e7db              B        |L54.114|
                  |L54.186|
0000ba  6ae2              LDR      r2,[r4,#0x2c]         ;852
0000bc  6290              STR      r0,[r2,#0x28]         ;855
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;855
0000c0  6301              STR      r1,[r0,#0x30]         ;858
0000c2  6822              LDR      r2,[r4,#0]            ;858
0000c4  4631              MOV      r1,r6                 ;858
0000c6  3240              ADDS     r2,r2,#0x40           ;858
0000c8  6ae0              LDR      r0,[r4,#0x2c]         ;858
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  6820              LDR      r0,[r4,#0]            ;861
0000d0  68c1              LDR      r1,[r0,#0xc]          ;861
0000d2  f4415180          ORR      r1,r1,#0x1000         ;861
0000d6  e7cc              B        |L54.114|
;;;884    
                          ENDP

                  |L54.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.220|
                          DCD      TIM_DMAError
                  |L54.224|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;644    */
;;;645    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;646    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L55.22|
;;;647      /* Check the parameters */
;;;648      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;649    
;;;650      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L55.30|
00000c  2908              CMP      r1,#8
00000e  d01d              BEQ      |L55.76|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L55.38|
000014  e01e              B        |L55.84|
                  |L55.22|
;;;651      {
;;;652        case TIM_CHANNEL_1:
;;;653        {
;;;654          /* Enable the TIM Capture/Compare 1 interrupt */
;;;655          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;656        }
;;;657        break;
00001c  e002              B        |L55.36|
                  |L55.30|
;;;658    
;;;659        case TIM_CHANNEL_2:
;;;660        {
;;;661          /* Enable the TIM Capture/Compare 2 interrupt */
;;;662          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L55.36|
000024  60d0              STR      r0,[r2,#0xc]          ;655
                  |L55.38|
;;;663        }
;;;664        break;
;;;665    
;;;666        case TIM_CHANNEL_3:
;;;667        {
;;;668          /* Enable the TIM Capture/Compare 3 interrupt */
;;;669          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;670        }
;;;671        break;
;;;672    
;;;673        case TIM_CHANNEL_4:
;;;674        {
;;;675          /* Enable the TIM Capture/Compare 4 interrupt */
;;;676          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;677        }
;;;678        break;
;;;679    
;;;680        default:
;;;681        break;
;;;682      }
;;;683    
;;;684      /* Enable the Output compare channel */
;;;685      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;686    
;;;687      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  490b              LDR      r1,|L55.92|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d103              BNE      |L55.62|
;;;688      {
;;;689        /* Enable the main output */
;;;690        __HAL_TIM_MOE_ENABLE(htim);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f4414100          ORR      r1,r1,#0x8000
00003c  6441              STR      r1,[r0,#0x44]
                  |L55.62|
;;;691      }
;;;692    
;;;693      /* Enable the Peripheral */
;;;694      __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;695    
;;;696      /* Return function status */
;;;697      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;698    }
00004a  bd10              POP      {r4,pc}
                  |L55.76|
00004c  68d0              LDR      r0,[r2,#0xc]          ;669
00004e  f0400008          ORR      r0,r0,#8              ;669
000052  e7e7              B        |L55.36|
                  |L55.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;676
000056  f0400010          ORR      r0,r0,#0x10           ;676
00005a  e7e3              B        |L55.36|
;;;699    
                          ENDP

                  |L55.92|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;612    */
;;;613    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;614    {
000002  4604              MOV      r4,r0
;;;615      /* Check the parameters */
;;;616      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;617    
;;;618      /* Disable the Output compare channel */
;;;619      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;620    
;;;621      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  480e              LDR      r0,|L56.72|
;;;622      {
;;;623        /* Disable the Main Ouput */
;;;624        __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411211          MOV      r2,#0x1111
000012  6821              LDR      r1,[r4,#0]            ;621
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;621
000018  d109              BNE      |L56.46|
00001a  6a08              LDR      r0,[r1,#0x20]
00001c  4210              TST      r0,r2
00001e  d106              BNE      |L56.46|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4218              TST      r0,r3
000024  d103              BNE      |L56.46|
000026  6c48              LDR      r0,[r1,#0x44]
000028  f4204000          BIC      r0,r0,#0x8000
00002c  6448              STR      r0,[r1,#0x44]
                  |L56.46|
;;;625      }
;;;626    
;;;627      /* Disable the Peripheral */
;;;628      __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d106              BNE      |L56.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4219              TST      r1,r3
00003a  d103              BNE      |L56.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L56.68|
;;;629    
;;;630      /* Return function status */
;;;631      return HAL_OK;
000044  2000              MOVS     r0,#0
;;;632    }
000046  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  |L56.72|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;895    */
;;;896    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;897    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L57.22|
;;;898      /* Check the parameters */
;;;899      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;900    
;;;901      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L57.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L57.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L57.38|
000014  e030              B        |L57.120|
                  |L57.22|
;;;902      {
;;;903        case TIM_CHANNEL_1:
;;;904        {
;;;905          /* Disable the TIM Capture/Compare 1 DMA request */
;;;906          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;907        }
;;;908        break;
00001c  e002              B        |L57.36|
                  |L57.30|
;;;909    
;;;910        case TIM_CHANNEL_2:
;;;911        {
;;;912          /* Disable the TIM Capture/Compare 2 DMA request */
;;;913          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L57.36|
000024  60d0              STR      r0,[r2,#0xc]          ;906
                  |L57.38|
;;;914        }
;;;915        break;
;;;916    
;;;917        case TIM_CHANNEL_3:
;;;918        {
;;;919          /* Disable the TIM Capture/Compare 3 DMA request */
;;;920          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;921        }
;;;922        break;
;;;923    
;;;924        case TIM_CHANNEL_4:
;;;925        {
;;;926          /* Disable the TIM Capture/Compare 4 interrupt */
;;;927          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;928        }
;;;929        break;
;;;930    
;;;931        default:
;;;932        break;
;;;933      }
;;;934    
;;;935      /* Disable the Output compare channel */
;;;936      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;937    
;;;938      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b14              LDR      r3,|L57.128|
;;;939      {
;;;940        /* Disable the Main Ouput */
;;;941        __HAL_TIM_MOE_DISABLE(htim);
000030  f2411111          MOV      r1,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;938
000036  108a              ASRS     r2,r1,#2
000038  4298              CMP      r0,r3                 ;938
00003a  d109              BNE      |L57.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  420b              TST      r3,r1
000040  d106              BNE      |L57.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  4213              TST      r3,r2
000046  d103              BNE      |L57.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L57.80|
;;;942      }
;;;943    
;;;944      /* Disable the Peripheral */
;;;945      __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  420b              TST      r3,r1
000056  d106              BNE      |L57.102|
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4211              TST      r1,r2
00005c  d103              BNE      |L57.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L57.102|
;;;946    
;;;947      /* Change the htim state */
;;;948      htim->State = HAL_TIM_STATE_READY;
000066  2001              MOVS     r0,#1
000068  f8840039          STRB     r0,[r4,#0x39]
;;;949    
;;;950      /* Return function status */
;;;951      return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;952    }
00006e  bd10              POP      {r4,pc}
                  |L57.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;920
000072  f4206000          BIC      r0,r0,#0x800          ;920
000076  e7d5              B        |L57.36|
                  |L57.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;927
00007a  f4205080          BIC      r0,r0,#0x1000         ;927
00007e  e7d1              B        |L57.36|
;;;953    
                          ENDP

                  |L57.128|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;710    */
;;;711    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;712    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L58.22|
;;;713      /* Check the parameters */
;;;714      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;715    
;;;716      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L58.30|
00000c  2908              CMP      r1,#8
00000e  d02c              BEQ      |L58.106|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L58.38|
000014  e02d              B        |L58.114|
                  |L58.22|
;;;717      {
;;;718        case TIM_CHANNEL_1:
;;;719        {
;;;720          /* Disable the TIM Capture/Compare 1 interrupt */
;;;721          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;722        }
;;;723        break;
00001c  e002              B        |L58.36|
                  |L58.30|
;;;724    
;;;725        case TIM_CHANNEL_2:
;;;726        {
;;;727          /* Disable the TIM Capture/Compare 2 interrupt */
;;;728          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L58.36|
000024  60d0              STR      r0,[r2,#0xc]          ;721
                  |L58.38|
;;;729        }
;;;730        break;
;;;731    
;;;732        case TIM_CHANNEL_3:
;;;733        {
;;;734          /* Disable the TIM Capture/Compare 3 interrupt */
;;;735          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;736        }
;;;737        break;
;;;738    
;;;739        case TIM_CHANNEL_4:
;;;740        {
;;;741          /* Disable the TIM Capture/Compare 4 interrupt */
;;;742          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;743        }
;;;744        break;
;;;745    
;;;746        default:
;;;747        break;
;;;748      }
;;;749    
;;;750      /* Disable the Output compare channel */
;;;751      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;752    
;;;753      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b13              LDR      r3,|L58.124|
;;;754      {
;;;755        /* Disable the Main Ouput */
;;;756        __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;753
000036  1091              ASRS     r1,r2,#2
000038  4298              CMP      r0,r3                 ;753
00003a  d109              BNE      |L58.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  4213              TST      r3,r2
000040  d106              BNE      |L58.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  420b              TST      r3,r1
000046  d103              BNE      |L58.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L58.80|
;;;757      }
;;;758    
;;;759      /* Disable the Peripheral */
;;;760      __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  4213              TST      r3,r2
000056  d106              BNE      |L58.102|
000058  6a02              LDR      r2,[r0,#0x20]
00005a  420a              TST      r2,r1
00005c  d103              BNE      |L58.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L58.102|
;;;761    
;;;762      /* Return function status */
;;;763      return HAL_OK;
000066  2000              MOVS     r0,#0
;;;764    }
000068  bd10              POP      {r4,pc}
                  |L58.106|
00006a  68d0              LDR      r0,[r2,#0xc]          ;735
00006c  f0200008          BIC      r0,r0,#8              ;735
000070  e7d8              B        |L58.36|
                  |L58.114|
000072  68d0              LDR      r0,[r2,#0xc]          ;742
000074  f0200010          BIC      r0,r0,#0x10           ;742
000078  e7d4              B        |L58.36|
;;;765    
                          ENDP

00007a  0000              DCW      0x0000
                  |L58.124|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3179     */
;;;3180   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3181   {
000002  461e              MOV      r6,r3
000004  b087              SUB      sp,sp,#0x1c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;3182     TIM_OC_InitTypeDef temp1;
;;;3183   
;;;3184     /* Check the parameters */
;;;3185     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3186     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3187   
;;;3188     if(OutputChannel != InputChannel)
00000a  42b2              CMP      r2,r6
00000c  d063              BEQ      |L59.214|
;;;3189     {
;;;3190     __HAL_LOCK(htim);
00000e  f8940038          LDRB     r0,[r4,#0x38]
000012  2801              CMP      r0,#1
000014  d015              BEQ      |L59.66|
000016  2701              MOVS     r7,#1
000018  f8847038          STRB     r7,[r4,#0x38]
;;;3191   
;;;3192     htim->State = HAL_TIM_STATE_BUSY;
00001c  2002              MOVS     r0,#2
00001e  f8840039          STRB     r0,[r4,#0x39]
;;;3193   
;;;3194     /* Extract the Ouput compare configuration from sConfig structure */
;;;3195     temp1.OCMode = sConfig->OCMode;
000022  6828              LDR      r0,[r5,#0]
;;;3196     temp1.Pulse = sConfig->Pulse;
000024  9000              STR      r0,[sp,#0]
000026  6868              LDR      r0,[r5,#4]
;;;3197     temp1.OCPolarity = sConfig->OCPolarity;
000028  9001              STR      r0,[sp,#4]
00002a  68a8              LDR      r0,[r5,#8]
;;;3198     temp1.OCNPolarity = sConfig->OCNPolarity;
00002c  9002              STR      r0,[sp,#8]
00002e  68e8              LDR      r0,[r5,#0xc]
;;;3199     temp1.OCIdleState = sConfig->OCIdleState;
000030  9003              STR      r0,[sp,#0xc]
000032  6928              LDR      r0,[r5,#0x10]
;;;3200     temp1.OCNIdleState = sConfig->OCNIdleState;
000034  9005              STR      r0,[sp,#0x14]
000036  6968              LDR      r0,[r5,#0x14]
000038  9006              STR      r0,[sp,#0x18]         ;3190
00003a  b12a              CBZ      r2,|L59.72|
;;;3201   
;;;3202       switch (OutputChannel)
00003c  2a04              CMP      r2,#4
00003e  d10c              BNE      |L59.90|
000040  e007              B        |L59.82|
                  |L59.66|
000042  2002              MOVS     r0,#2                 ;3190
                  |L59.68|
;;;3203     {
;;;3204       case TIM_CHANNEL_1:
;;;3205       {
;;;3206           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3207   
;;;3208         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3209       }
;;;3210       break;
;;;3211       case TIM_CHANNEL_2:
;;;3212       {
;;;3213           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3214   
;;;3215         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3216       }
;;;3217       break;
;;;3218       default:
;;;3219       break;
;;;3220     }
;;;3221     switch (InputChannel)
;;;3222     {
;;;3223       case TIM_CHANNEL_1:
;;;3224       {
;;;3225         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3226   
;;;3227         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3228                           sConfig->ICSelection, sConfig->ICFilter);
;;;3229   
;;;3230         /* Reset the IC1PSC Bits */
;;;3231       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3232   
;;;3233         /* Select the Trigger source */
;;;3234           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3235         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3236   
;;;3237         /* Select the Slave Mode */
;;;3238           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3239         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3240       }
;;;3241       break;
;;;3242       case TIM_CHANNEL_2:
;;;3243       {
;;;3244         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3245   
;;;3246         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3247                    sConfig->ICSelection, sConfig->ICFilter);
;;;3248   
;;;3249         /* Reset the IC2PSC Bits */
;;;3250           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3251   
;;;3252         /* Select the Trigger source */
;;;3253           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3254         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3255   
;;;3256         /* Select the Slave Mode */
;;;3257           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3258         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3259       }
;;;3260       break;
;;;3261   
;;;3262       default:
;;;3263       break;
;;;3264     }
;;;3265   
;;;3266     htim->State = HAL_TIM_STATE_READY;
;;;3267   
;;;3268     __HAL_UNLOCK(htim);
;;;3269   
;;;3270     return HAL_OK;
;;;3271   }
;;;3272     else
;;;3273     {
;;;3274       return HAL_ERROR;
;;;3275     }
;;;3276   }
000044  b007              ADD      sp,sp,#0x1c
000046  bdf0              POP      {r4-r7,pc}
                  |L59.72|
000048  4669              MOV      r1,sp                 ;3208
00004a  6820              LDR      r0,[r4,#0]            ;3208
00004c  f7fffffe          BL       TIM_OC1_SetConfig
000050  e003              B        |L59.90|
                  |L59.82|
000052  4669              MOV      r1,sp                 ;3215
000054  6820              LDR      r0,[r4,#0]            ;3215
000056  f7fffffe          BL       TIM_OC2_SetConfig
                  |L59.90|
00005a  b116              CBZ      r6,|L59.98|
00005c  2e04              CMP      r6,#4                 ;3221
00005e  d134              BNE      |L59.202|
000060  e014              B        |L59.140|
                  |L59.98|
000062  3518              ADDS     r5,r5,#0x18           ;3221
000064  6820              LDR      r0,[r4,#0]            ;3227
000066  e895000e          LDM      r5,{r1-r3}            ;3221
00006a  f7fffffe          BL       TIM_TI1_SetConfig
00006e  6820              LDR      r0,[r4,#0]            ;3231
000070  6981              LDR      r1,[r0,#0x18]         ;3231
000072  f021010c          BIC      r1,r1,#0xc            ;3231
000076  6181              STR      r1,[r0,#0x18]         ;3231
000078  6820              LDR      r0,[r4,#0]            ;3234
00007a  6881              LDR      r1,[r0,#8]            ;3234
00007c  f0210170          BIC      r1,r1,#0x70           ;3234
000080  6081              STR      r1,[r0,#8]            ;3234
000082  6820              LDR      r0,[r4,#0]            ;3235
000084  6881              LDR      r1,[r0,#8]            ;3235
000086  f0410150          ORR      r1,r1,#0x50           ;3235
00008a  e013              B        |L59.180|
                  |L59.140|
00008c  3518              ADDS     r5,r5,#0x18           ;3241
00008e  6820              LDR      r0,[r4,#0]            ;3246
000090  e895000e          LDM      r5,{r1-r3}            ;3241
000094  f7fffffe          BL       TIM_TI2_SetConfig
000098  6820              LDR      r0,[r4,#0]            ;3250
00009a  6981              LDR      r1,[r0,#0x18]         ;3250
00009c  f4216140          BIC      r1,r1,#0xc00          ;3250
0000a0  6181              STR      r1,[r0,#0x18]         ;3250
0000a2  6820              LDR      r0,[r4,#0]            ;3253
0000a4  6881              LDR      r1,[r0,#8]            ;3253
0000a6  f0210170          BIC      r1,r1,#0x70           ;3253
0000aa  6081              STR      r1,[r0,#8]            ;3253
0000ac  6820              LDR      r0,[r4,#0]            ;3254
0000ae  6881              LDR      r1,[r0,#8]            ;3254
0000b0  f0410160          ORR      r1,r1,#0x60           ;3254
                  |L59.180|
0000b4  6081              STR      r1,[r0,#8]            ;3235
0000b6  6820              LDR      r0,[r4,#0]            ;3238
0000b8  6881              LDR      r1,[r0,#8]            ;3238
0000ba  f0210107          BIC      r1,r1,#7              ;3238
0000be  6081              STR      r1,[r0,#8]            ;3238
0000c0  6820              LDR      r0,[r4,#0]            ;3239
0000c2  6881              LDR      r1,[r0,#8]            ;3239
0000c4  f0410106          ORR      r1,r1,#6              ;3239
0000c8  6081              STR      r1,[r0,#8]            ;3239
                  |L59.202|
0000ca  f8847039          STRB     r7,[r4,#0x39]         ;3266
0000ce  2000              MOVS     r0,#0                 ;3268
0000d0  f8840038          STRB     r0,[r4,#0x38]         ;3268
0000d4  e7b6              B        |L59.68|
                  |L59.214|
0000d6  2001              MOVS     r0,#1                 ;3274
0000d8  e7b4              B        |L59.68|
;;;3277   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2010     */
;;;2011   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2012   {
000002  4604              MOV      r4,r0
;;;2013     /* Check the parameters */
;;;2014     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2015   
;;;2016     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;2017   
;;;2018     /* Disable the TIM Peripheral Clock */
;;;2019     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L60.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L60.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L60.38|
;;;2020   
;;;2021     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2022     HAL_TIM_OnePulse_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2023   
;;;2024     /* Change TIM state */
;;;2025     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;2026   
;;;2027     /* Release Lock */
;;;2028     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;2029   
;;;2030     return HAL_OK;
;;;2031   }
000036  bd10              POP      {r4,pc}
;;;2032   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4412     */
;;;4413   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4414   {
;;;4415     return htim->State;
;;;4416   }
000004  4770              BX       lr
;;;4417   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1964     */
;;;1965   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1966   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d003              BEQ      |L62.16|
;;;1967     /* Check the TIM handle allocation */
;;;1968     if(htim == NULL)
;;;1969     {
;;;1970       return HAL_ERROR;
;;;1971     }
;;;1972   
;;;1973     /* Check the parameters */
;;;1974     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1975     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1976     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1977     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1978   
;;;1979     if(htim->State == HAL_TIM_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  b110              CBZ      r0,|L62.20|
00000e  e007              B        |L62.32|
                  |L62.16|
000010  2001              MOVS     r0,#1                 ;1970
;;;1980     {
;;;1981       /* Allocate lock resource and initialize it */
;;;1982       htim->Lock = HAL_UNLOCKED;
;;;1983       
;;;1984       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1985       HAL_TIM_OnePulse_MspInit(htim);
;;;1986     }
;;;1987   
;;;1988     /* Set the TIM state */
;;;1989     htim->State= HAL_TIM_STATE_BUSY;
;;;1990   
;;;1991     /* Configure the Time base in the One Pulse Mode */
;;;1992     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1993   
;;;1994     /* Reset the OPM Bit */
;;;1995     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;1996   
;;;1997     /* Configure the OPM Mode */
;;;1998     htim->Instance->CR1 |= OnePulseMode;
;;;1999   
;;;2000     /* Initialize the TIM state*/
;;;2001     htim->State= HAL_TIM_STATE_READY;
;;;2002   
;;;2003     return HAL_OK;
;;;2004   }
000012  bd70              POP      {r4-r6,pc}
                  |L62.20|
000014  2000              MOVS     r0,#0                 ;1982
000016  f8840038          STRB     r0,[r4,#0x38]         ;1982
00001a  4620              MOV      r0,r4                 ;1985
00001c  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.32|
000020  2002              MOVS     r0,#2                 ;1989
000022  f8840039          STRB     r0,[r4,#0x39]         ;1989
000026  1d21              ADDS     r1,r4,#4              ;1992
000028  6820              LDR      r0,[r4,#0]            ;1992
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;1995
000030  6801              LDR      r1,[r0,#0]            ;1995
000032  f0210108          BIC      r1,r1,#8              ;1995
000036  6001              STR      r1,[r0,#0]            ;1995
000038  6820              LDR      r0,[r4,#0]            ;1998
00003a  6801              LDR      r1,[r0,#0]            ;1998
00003c  4329              ORRS     r1,r1,r5              ;1998
00003e  6001              STR      r1,[r0,#0]            ;1998
000040  2001              MOVS     r0,#1                 ;2001
000042  f8840039          STRB     r0,[r4,#0x39]         ;2001
000046  2000              MOVS     r0,#0                 ;2003
000048  bd70              POP      {r4-r6,pc}
;;;2005   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2051     */
;;;2052   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2053   {
;;;2054     /* Prevent unused argument(s) compilation warning */
;;;2055     UNUSED(htim);
;;;2056     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2057               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2058      */
;;;2059   }
;;;2060   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2037     */
;;;2038   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2039   {
;;;2040     /* Prevent unused argument(s) compilation warning */
;;;2041     UNUSED(htim);
;;;2042     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2043               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2044      */
;;;2045   }
;;;2046   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2069   */
;;;2070   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2071   {
000002  4604              MOV      r4,r0
;;;2072     /* Enable the Capture compare and the Input Capture channels 
;;;2073       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2074       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2075       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2076       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2077   
;;;2078       No need to enable the counter, it's enabled automatically by hardware 
;;;2079       (the counter starts in response to a stimulus and generate a pulse */
;;;2080   
;;;2081     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2082     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2083   
;;;2084     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  4904              LDR      r1,|L65.44|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d103              BNE      |L65.40|
;;;2085     {
;;;2086       /* Enable the main output */
;;;2087       __HAL_TIM_MOE_ENABLE(htim);
000020  6c41              LDR      r1,[r0,#0x44]
000022  f4414100          ORR      r1,r1,#0x8000
000026  6441              STR      r1,[r0,#0x44]
                  |L65.40|
;;;2088     }
;;;2089   
;;;2090     /* Return function status */
;;;2091     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;2092   }
00002a  bd10              POP      {r4,pc}
;;;2093   
                          ENDP

                  |L65.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2135   */
;;;2136   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2137   {
000002  4604              MOV      r4,r0
;;;2138     /* Enable the Capture compare and the Input Capture channels 
;;;2139       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2140       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2141       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2142       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2143   
;;;2144       No need to enable the counter, it's enabled automatically by hardware 
;;;2145       (the counter starts in response to a stimulus and generate a pulse */
;;;2146   
;;;2147     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2148     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2149   
;;;2150     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2151     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0410104          ORR      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2152   
;;;2153     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000018  2201              MOVS     r2,#1
00001a  2100              MOVS     r1,#0
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2154     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000022  2201              MOVS     r2,#1
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2155   
;;;2156     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4904              LDR      r1,|L66.64|
00002e  6820              LDR      r0,[r4,#0]
000030  4288              CMP      r0,r1
000032  d103              BNE      |L66.60|
;;;2157     {
;;;2158       /* Enable the main output */
;;;2159       __HAL_TIM_MOE_ENABLE(htim);
000034  6c41              LDR      r1,[r0,#0x44]
000036  f4414100          ORR      r1,r1,#0x8000
00003a  6441              STR      r1,[r0,#0x44]
                  |L66.60|
;;;2160     }
;;;2161   
;;;2162     /* Return function status */
;;;2163     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2164   }
00003e  bd10              POP      {r4,pc}
;;;2165   
                          ENDP

                  |L66.64|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2102   */
;;;2103   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2104   {
000002  4604              MOV      r4,r0
;;;2105     /* Disable the Capture compare and the Input Capture channels
;;;2106     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2107     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2108     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2109     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2110   
;;;2111     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2112     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2113   
;;;2114     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  4b0e              LDR      r3,|L67.84|
;;;2115     {
;;;2116       /* Disable the Main Ouput */
;;;2117       __HAL_TIM_MOE_DISABLE(htim);
00001a  f2411111          MOV      r1,#0x1111
00001e  6820              LDR      r0,[r4,#0]            ;2114
000020  108a              ASRS     r2,r1,#2
000022  4298              CMP      r0,r3                 ;2114
000024  d109              BNE      |L67.58|
000026  6a03              LDR      r3,[r0,#0x20]
000028  420b              TST      r3,r1
00002a  d106              BNE      |L67.58|
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  4213              TST      r3,r2
000030  d103              BNE      |L67.58|
000032  6c43              LDR      r3,[r0,#0x44]
000034  f4234300          BIC      r3,r3,#0x8000
000038  6443              STR      r3,[r0,#0x44]
                  |L67.58|
;;;2118     }
;;;2119   
;;;2120     /* Disable the Peripheral */
;;;2121     __HAL_TIM_DISABLE(htim);
00003a  6820              LDR      r0,[r4,#0]
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  420b              TST      r3,r1
000040  d106              BNE      |L67.80|
000042  6a01              LDR      r1,[r0,#0x20]
000044  4211              TST      r1,r2
000046  d103              BNE      |L67.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L67.80|
;;;2122   
;;;2123     /* Return function status */
;;;2124     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;2125   }
000052  bd10              POP      {r4,pc}
;;;2126   
                          ENDP

                  |L67.84|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2174   */
;;;2175   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2176   {
000002  4604              MOV      r4,r0
;;;2177     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2178     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0210102          BIC      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2179   
;;;2180     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2181     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210104          BIC      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2182   
;;;2183     /* Disable the Capture compare and the Input Capture channels 
;;;2184     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2185     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2186     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2187     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2188     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2189     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000022  2200              MOVS     r2,#0
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2190   
;;;2191     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4b0e              LDR      r3,|L68.104|
;;;2192     {
;;;2193       /* Disable the Main Ouput */
;;;2194       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411111          MOV      r1,#0x1111
000032  6820              LDR      r0,[r4,#0]            ;2191
000034  108a              ASRS     r2,r1,#2
000036  4298              CMP      r0,r3                 ;2191
000038  d109              BNE      |L68.78|
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  420b              TST      r3,r1
00003e  d106              BNE      |L68.78|
000040  6a03              LDR      r3,[r0,#0x20]
000042  4213              TST      r3,r2
000044  d103              BNE      |L68.78|
000046  6c43              LDR      r3,[r0,#0x44]
000048  f4234300          BIC      r3,r3,#0x8000
00004c  6443              STR      r3,[r0,#0x44]
                  |L68.78|
;;;2195     }
;;;2196   
;;;2197     /* Disable the Peripheral */
;;;2198      __HAL_TIM_DISABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6a03              LDR      r3,[r0,#0x20]
000052  420b              TST      r3,r1
000054  d106              BNE      |L68.100|
000056  6a01              LDR      r1,[r0,#0x20]
000058  4211              TST      r1,r2
00005a  d103              BNE      |L68.100|
00005c  6801              LDR      r1,[r0,#0]
00005e  f0210101          BIC      r1,r1,#1
000062  6001              STR      r1,[r0,#0]
                  |L68.100|
;;;2199   
;;;2200     /* Return function status */
;;;2201     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2202   }
000066  bd10              POP      {r4,pc}
;;;2203   
                          ENDP

                  |L68.104|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3079     */
;;;3080   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3081   {
000002  4604              MOV      r4,r0
;;;3082     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  460d              MOV      r5,r1                 ;3081
00000a  2801              CMP      r0,#1
00000c  d00d              BEQ      |L69.42|
00000e  2601              MOVS     r6,#1
000010  f8846038          STRB     r6,[r4,#0x38]
;;;3083   
;;;3084     /* Check the parameters */
;;;3085     assert_param(IS_TIM_CHANNELS(Channel));
;;;3086     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3087     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3088     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3089   
;;;3090     htim->State = HAL_TIM_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f8840039          STRB     r0,[r4,#0x39]
00001a  b142              CBZ      r2,|L69.46|
;;;3091   
;;;3092     switch (Channel)
00001c  2a04              CMP      r2,#4
00001e  d018              BEQ      |L69.82|
000020  2a08              CMP      r2,#8
000022  d02a              BEQ      |L69.122|
000024  2a0c              CMP      r2,#0xc
000026  d14d              BNE      |L69.196|
000028  e039              B        |L69.158|
                  |L69.42|
00002a  2002              MOVS     r0,#2                 ;3082
;;;3093     {
;;;3094       case TIM_CHANNEL_1:
;;;3095       {
;;;3096         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3097         /* Configure the Channel 1 in PWM mode */
;;;3098         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3099   
;;;3100         /* Set the Preload enable bit for channel1 */
;;;3101         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3102   
;;;3103         /* Configure the Output Fast mode */
;;;3104         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3105         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3106       }
;;;3107       break;
;;;3108   
;;;3109       case TIM_CHANNEL_2:
;;;3110       {
;;;3111         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3112         /* Configure the Channel 2 in PWM mode */
;;;3113         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3114   
;;;3115         /* Set the Preload enable bit for channel2 */
;;;3116         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3117   
;;;3118         /* Configure the Output Fast mode */
;;;3119         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3120         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3121       }
;;;3122       break;
;;;3123   
;;;3124       case TIM_CHANNEL_3:
;;;3125       {
;;;3126         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3127         /* Configure the Channel 3 in PWM mode */
;;;3128         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3129   
;;;3130         /* Set the Preload enable bit for channel3 */
;;;3131         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3132   
;;;3133        /* Configure the Output Fast mode */
;;;3134         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3135         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3136       }
;;;3137       break;
;;;3138   
;;;3139       case TIM_CHANNEL_4:
;;;3140       {
;;;3141         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3142         /* Configure the Channel 4 in PWM mode */
;;;3143         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3144   
;;;3145         /* Set the Preload enable bit for channel4 */
;;;3146         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3147   
;;;3148        /* Configure the Output Fast mode */
;;;3149         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3150         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
;;;3151       }
;;;3152       break;
;;;3153   
;;;3154       default:
;;;3155       break;
;;;3156     }
;;;3157   
;;;3158     htim->State = HAL_TIM_STATE_READY;
;;;3159   
;;;3160     __HAL_UNLOCK(htim);
;;;3161   
;;;3162     return HAL_OK;
;;;3163   }
00002c  bd70              POP      {r4-r6,pc}
                  |L69.46|
00002e  6820              LDR      r0,[r4,#0]            ;3098
000030  f7fffffe          BL       TIM_OC1_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;3101
000036  6981              LDR      r1,[r0,#0x18]         ;3101
000038  f0410108          ORR      r1,r1,#8              ;3101
00003c  6181              STR      r1,[r0,#0x18]         ;3101
00003e  6820              LDR      r0,[r4,#0]            ;3104
000040  6981              LDR      r1,[r0,#0x18]         ;3104
000042  f0210104          BIC      r1,r1,#4              ;3104
000046  6181              STR      r1,[r0,#0x18]         ;3104
000048  6820              LDR      r0,[r4,#0]            ;3105
00004a  6981              LDR      r1,[r0,#0x18]         ;3105
00004c  692a              LDR      r2,[r5,#0x10]         ;3105
00004e  4311              ORRS     r1,r1,r2              ;3105
000050  e011              B        |L69.118|
                  |L69.82|
000052  6820              LDR      r0,[r4,#0]            ;3113
000054  f7fffffe          BL       TIM_OC2_SetConfig
000058  6820              LDR      r0,[r4,#0]            ;3116
00005a  6981              LDR      r1,[r0,#0x18]         ;3116
00005c  f4416100          ORR      r1,r1,#0x800          ;3116
000060  6181              STR      r1,[r0,#0x18]         ;3116
000062  6820              LDR      r0,[r4,#0]            ;3119
000064  6981              LDR      r1,[r0,#0x18]         ;3119
000066  f4216180          BIC      r1,r1,#0x400          ;3119
00006a  6181              STR      r1,[r0,#0x18]         ;3119
00006c  6820              LDR      r0,[r4,#0]            ;3120
00006e  6981              LDR      r1,[r0,#0x18]         ;3120
000070  692a              LDR      r2,[r5,#0x10]         ;3120
000072  ea412102          ORR      r1,r1,r2,LSL #8       ;3120
                  |L69.118|
000076  6181              STR      r1,[r0,#0x18]         ;3105
000078  e024              B        |L69.196|
                  |L69.122|
00007a  6820              LDR      r0,[r4,#0]            ;3128
00007c  f7fffffe          BL       TIM_OC3_SetConfig
000080  6820              LDR      r0,[r4,#0]            ;3131
000082  69c1              LDR      r1,[r0,#0x1c]         ;3131
000084  f0410108          ORR      r1,r1,#8              ;3131
000088  61c1              STR      r1,[r0,#0x1c]         ;3131
00008a  6820              LDR      r0,[r4,#0]            ;3134
00008c  69c1              LDR      r1,[r0,#0x1c]         ;3134
00008e  f0210104          BIC      r1,r1,#4              ;3134
000092  61c1              STR      r1,[r0,#0x1c]         ;3134
000094  6820              LDR      r0,[r4,#0]            ;3135
000096  69c1              LDR      r1,[r0,#0x1c]         ;3135
000098  692a              LDR      r2,[r5,#0x10]         ;3135
00009a  4311              ORRS     r1,r1,r2              ;3135
00009c  e011              B        |L69.194|
                  |L69.158|
00009e  6820              LDR      r0,[r4,#0]            ;3143
0000a0  f7fffffe          BL       TIM_OC4_SetConfig
0000a4  6820              LDR      r0,[r4,#0]            ;3146
0000a6  69c1              LDR      r1,[r0,#0x1c]         ;3146
0000a8  f4416100          ORR      r1,r1,#0x800          ;3146
0000ac  61c1              STR      r1,[r0,#0x1c]         ;3146
0000ae  6820              LDR      r0,[r4,#0]            ;3149
0000b0  69c1              LDR      r1,[r0,#0x1c]         ;3149
0000b2  f4216180          BIC      r1,r1,#0x400          ;3149
0000b6  61c1              STR      r1,[r0,#0x1c]         ;3149
0000b8  6820              LDR      r0,[r4,#0]            ;3150
0000ba  69c1              LDR      r1,[r0,#0x1c]         ;3150
0000bc  692a              LDR      r2,[r5,#0x10]         ;3150
0000be  ea412102          ORR      r1,r1,r2,LSL #8       ;3150
                  |L69.194|
0000c2  61c1              STR      r1,[r0,#0x1c]         ;3135
                  |L69.196|
0000c4  f8846039          STRB     r6,[r4,#0x39]         ;3158
0000c8  2000              MOVS     r0,#0                 ;3160
0000ca  f8840038          STRB     r0,[r4,#0x38]         ;3160
0000ce  bd70              POP      {r4-r6,pc}
;;;3164   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1023     */
;;;1024   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1025   {
000002  4604              MOV      r4,r0
;;;1026     /* Check the parameters */
;;;1027     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1028   
;;;1029     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1030   
;;;1031     /* Disable the TIM Peripheral Clock */
;;;1032     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L70.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L70.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L70.38|
;;;1033   
;;;1034     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1035     HAL_TIM_PWM_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1036   
;;;1037     /* Change TIM state */
;;;1038     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;1039   
;;;1040     /* Release Lock */
;;;1041     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;1042   
;;;1043     return HAL_OK;
;;;1044   }
000036  bd10              POP      {r4,pc}
;;;1045   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4392     */
;;;4393   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4394   {
;;;4395     return htim->State;
;;;4396   }
000004  4770              BX       lr
;;;4397   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;984      */
;;;985    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;986    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L72.14|
;;;987      /* Check the TIM handle allocation */
;;;988      if(htim == NULL)
;;;989      {
;;;990        return HAL_ERROR;
;;;991      }
;;;992    
;;;993      /* Check the parameters */
;;;994      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;995      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;996      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;997    
;;;998      if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L72.18|
00000c  e007              B        |L72.30|
                  |L72.14|
00000e  2001              MOVS     r0,#1                 ;990
;;;999      {
;;;1000       /* Allocate lock resource and initialize it */
;;;1001       htim->Lock = HAL_UNLOCKED;
;;;1002       
;;;1003       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1004       HAL_TIM_PWM_MspInit(htim);
;;;1005     }
;;;1006   
;;;1007     /* Set the TIM state */
;;;1008     htim->State= HAL_TIM_STATE_BUSY;
;;;1009   
;;;1010     /* Init the base time for the PWM */
;;;1011     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1012   
;;;1013     /* Initialize the TIM state*/
;;;1014     htim->State= HAL_TIM_STATE_READY;
;;;1015   
;;;1016     return HAL_OK;
;;;1017   }
000010  bd10              POP      {r4,pc}
                  |L72.18|
000012  2000              MOVS     r0,#0                 ;1001
000014  f8840038          STRB     r0,[r4,#0x38]         ;1001
000018  4620              MOV      r0,r4                 ;1004
00001a  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.30|
00001e  2002              MOVS     r0,#2                 ;1008
000020  f8840039          STRB     r0,[r4,#0x39]         ;1008
000024  1d21              ADDS     r1,r4,#4              ;1011
000026  6820              LDR      r0,[r4,#0]            ;1011
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  2001              MOVS     r0,#1                 ;1014
00002e  f8840039          STRB     r0,[r4,#0x39]         ;1014
000032  2000              MOVS     r0,#0                 ;1016
000034  bd10              POP      {r4,pc}
;;;1018   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1064     */
;;;1065   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1066   {
;;;1067     /* Prevent unused argument(s) compilation warning */
;;;1068     UNUSED(htim);
;;;1069     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1070               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1071      */
;;;1072   }
;;;1073   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1050     */
;;;1051   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1052   {
;;;1053     /* Prevent unused argument(s) compilation warning */
;;;1054     UNUSED(htim);
;;;1055     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1056               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1057      */
;;;1058   }
;;;1059   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4311     */
;;;4312   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4313   {
;;;4314     /* Prevent unused argument(s) compilation warning */
;;;4315     UNUSED(htim);
;;;4316     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4317               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4318      */
;;;4319   }
;;;4320   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1084   */
;;;1085   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1086   {
000002  4604              MOV      r4,r0
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1089   
;;;1090     /* Enable the Capture compare channel */
;;;1091     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1092   
;;;1093     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4907              LDR      r1,|L76.44|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d103              BNE      |L76.28|
;;;1094     {
;;;1095       /* Enable the main output */
;;;1096       __HAL_TIM_MOE_ENABLE(htim);
000014  6c41              LDR      r1,[r0,#0x44]
000016  f4414100          ORR      r1,r1,#0x8000
00001a  6441              STR      r1,[r0,#0x44]
                  |L76.28|
;;;1097     }
;;;1098   
;;;1099     /* Enable the Peripheral */
;;;1100     __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410101          ORR      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
;;;1101   
;;;1102     /* Return function status */
;;;1103     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;1104   }
000028  bd10              POP      {r4,pc}
;;;1105   
                          ENDP

00002a  0000              DCW      0x0000
                  |L76.44|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1285   */
;;;1286   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1287   {
000002  4604              MOV      r4,r0
;;;1288     /* Check the parameters */
;;;1289     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1290   
;;;1291     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;1287
00000a  460d              MOV      r5,r1                 ;1287
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L77.28|
;;;1292     {
;;;1293        return HAL_BUSY;
;;;1294     }
;;;1295     else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L77.36|
;;;1296     {
;;;1297       if(((uint32_t)pData == 0 ) && (Length > 0))
000018  b90e              CBNZ     r6,|L77.30|
00001a  b103              CBZ      r3,|L77.30|
                  |L77.28|
;;;1298       {
;;;1299         return HAL_ERROR;
;;;1300       }
;;;1301       else
;;;1302       {
;;;1303         htim->State = HAL_TIM_STATE_BUSY;
;;;1304       }
;;;1305     }
;;;1306     switch (Channel)
;;;1307     {
;;;1308       case TIM_CHANNEL_1:
;;;1309       {
;;;1310         /* Set the DMA Period elapsed callback */
;;;1311         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1312   
;;;1313         /* Set the DMA error callback */
;;;1314         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1315   
;;;1316         /* Enable the DMA channel */
;;;1317         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1318   
;;;1319         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1320         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1321       }
;;;1322       break;
;;;1323   
;;;1324       case TIM_CHANNEL_2:
;;;1325       {
;;;1326         /* Set the DMA Period elapsed callback */
;;;1327         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1328   
;;;1329         /* Set the DMA error callback */
;;;1330         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1331   
;;;1332         /* Enable the DMA channel */
;;;1333         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1334   
;;;1335         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1336         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1337       }
;;;1338       break;
;;;1339   
;;;1340       case TIM_CHANNEL_3:
;;;1341       {
;;;1342         /* Set the DMA Period elapsed callback */
;;;1343         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1344   
;;;1345         /* Set the DMA error callback */
;;;1346         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1347   
;;;1348         /* Enable the DMA channel */
;;;1349         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1350   
;;;1351         /* Enable the TIM Output Capture/Compare 3 request */
;;;1352         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1353       }
;;;1354       break;
;;;1355   
;;;1356       case TIM_CHANNEL_4:
;;;1357       {
;;;1358        /* Set the DMA Period elapsed callback */
;;;1359         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1360   
;;;1361         /* Set the DMA error callback */
;;;1362         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1363   
;;;1364         /* Enable the DMA channel */
;;;1365         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1366   
;;;1367         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1368         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1369       }
;;;1370       break;
;;;1371   
;;;1372       default:
;;;1373       break;
;;;1374     }
;;;1375   
;;;1376     /* Enable the Capture compare channel */
;;;1377     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1378   
;;;1379     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1380     {
;;;1381       /* Enable the main output */
;;;1382       __HAL_TIM_MOE_ENABLE(htim);
;;;1383     }
;;;1384   
;;;1385     /* Enable the Peripheral */
;;;1386     __HAL_TIM_ENABLE(htim);
;;;1387   
;;;1388     /* Return function status */
;;;1389     return HAL_OK;
;;;1390   }
00001c  bd70              POP      {r4-r6,pc}
                  |L77.30|
00001e  2002              MOVS     r0,#2                 ;1303
000020  f8840039          STRB     r0,[r4,#0x39]         ;1303
                  |L77.36|
000024  482c              LDR      r0,|L77.216|
000026  492d              LDR      r1,|L77.220|
000028  b135              CBZ      r5,|L77.56|
00002a  2d04              CMP      r5,#4                 ;1306
00002c  d013              BEQ      |L77.86|
00002e  2d08              CMP      r5,#8                 ;1306
000030  d034              BEQ      |L77.156|
000032  2d0c              CMP      r5,#0xc               ;1306
000034  d11e              BNE      |L77.116|
000036  e040              B        |L77.186|
                  |L77.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;1311
00003a  6290              STR      r0,[r2,#0x28]         ;1314
00003c  6a20              LDR      r0,[r4,#0x20]         ;1314
00003e  6301              STR      r1,[r0,#0x30]         ;1317
000040  6822              LDR      r2,[r4,#0]            ;1317
000042  4631              MOV      r1,r6                 ;1317
000044  3234              ADDS     r2,r2,#0x34           ;1317
000046  6a20              LDR      r0,[r4,#0x20]         ;1317
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1320
00004e  68c1              LDR      r1,[r0,#0xc]          ;1320
000050  f4417100          ORR      r1,r1,#0x200          ;1320
000054  e00d              B        |L77.114|
                  |L77.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;1327
000058  6290              STR      r0,[r2,#0x28]         ;1330
00005a  6a60              LDR      r0,[r4,#0x24]         ;1330
00005c  6301              STR      r1,[r0,#0x30]         ;1333
00005e  6822              LDR      r2,[r4,#0]            ;1333
000060  4631              MOV      r1,r6                 ;1333
000062  3238              ADDS     r2,r2,#0x38           ;1333
000064  6a60              LDR      r0,[r4,#0x24]         ;1333
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;1336
00006c  68c1              LDR      r1,[r0,#0xc]          ;1336
00006e  f4416180          ORR      r1,r1,#0x400          ;1336
                  |L77.114|
000072  60c1              STR      r1,[r0,#0xc]          ;1320
                  |L77.116|
000074  2201              MOVS     r2,#1                 ;1377
000076  4629              MOV      r1,r5                 ;1377
000078  6820              LDR      r0,[r4,#0]            ;1377
00007a  f7fffffe          BL       TIM_CCxChannelCmd
00007e  4918              LDR      r1,|L77.224|
000080  6820              LDR      r0,[r4,#0]            ;1379
000082  4288              CMP      r0,r1                 ;1379
000084  d103              BNE      |L77.142|
000086  6c41              LDR      r1,[r0,#0x44]         ;1382
000088  f4414100          ORR      r1,r1,#0x8000         ;1382
00008c  6441              STR      r1,[r0,#0x44]         ;1382
                  |L77.142|
00008e  6820              LDR      r0,[r4,#0]            ;1386
000090  6801              LDR      r1,[r0,#0]            ;1386
000092  f0410101          ORR      r1,r1,#1              ;1386
000096  6001              STR      r1,[r0,#0]            ;1386
000098  2000              MOVS     r0,#0                 ;1389
00009a  bd70              POP      {r4-r6,pc}
                  |L77.156|
00009c  6aa2              LDR      r2,[r4,#0x28]         ;1343
00009e  6290              STR      r0,[r2,#0x28]         ;1346
0000a0  6aa0              LDR      r0,[r4,#0x28]         ;1346
0000a2  6301              STR      r1,[r0,#0x30]         ;1349
0000a4  6822              LDR      r2,[r4,#0]            ;1349
0000a6  4631              MOV      r1,r6                 ;1349
0000a8  323c              ADDS     r2,r2,#0x3c           ;1349
0000aa  6aa0              LDR      r0,[r4,#0x28]         ;1349
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  6820              LDR      r0,[r4,#0]            ;1352
0000b2  68c1              LDR      r1,[r0,#0xc]          ;1352
0000b4  f4416100          ORR      r1,r1,#0x800          ;1352
0000b8  e7db              B        |L77.114|
                  |L77.186|
0000ba  6ae2              LDR      r2,[r4,#0x2c]         ;1359
0000bc  6290              STR      r0,[r2,#0x28]         ;1362
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;1362
0000c0  6301              STR      r1,[r0,#0x30]         ;1365
0000c2  6822              LDR      r2,[r4,#0]            ;1365
0000c4  4631              MOV      r1,r6                 ;1365
0000c6  3240              ADDS     r2,r2,#0x40           ;1365
0000c8  6ae0              LDR      r0,[r4,#0x2c]         ;1365
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  6820              LDR      r0,[r4,#0]            ;1368
0000d0  68c1              LDR      r1,[r0,#0xc]          ;1368
0000d2  f4415180          ORR      r1,r1,#0x1000         ;1368
0000d6  e7cc              B        |L77.114|
;;;1391   
                          ENDP

                  |L77.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.220|
                          DCD      TIM_DMAError
                  |L77.224|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1151   */
;;;1152   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1153   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L78.22|
;;;1154     /* Check the parameters */
;;;1155     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1156   
;;;1157     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L78.30|
00000c  2908              CMP      r1,#8
00000e  d01d              BEQ      |L78.76|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L78.38|
000014  e01e              B        |L78.84|
                  |L78.22|
;;;1158     {
;;;1159       case TIM_CHANNEL_1:
;;;1160       {
;;;1161         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1162         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1163       }
;;;1164       break;
00001c  e002              B        |L78.36|
                  |L78.30|
;;;1165   
;;;1166       case TIM_CHANNEL_2:
;;;1167       {
;;;1168         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1169         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L78.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1162
                  |L78.38|
;;;1170       }
;;;1171       break;
;;;1172   
;;;1173       case TIM_CHANNEL_3:
;;;1174       {
;;;1175         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1176         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1177       }
;;;1178       break;
;;;1179   
;;;1180       case TIM_CHANNEL_4:
;;;1181       {
;;;1182         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1183         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1184       }
;;;1185       break;
;;;1186   
;;;1187       default:
;;;1188       break;
;;;1189     }
;;;1190   
;;;1191     /* Enable the Capture compare channel */
;;;1192     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1193   
;;;1194     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  490b              LDR      r1,|L78.92|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d103              BNE      |L78.62|
;;;1195     {
;;;1196       /* Enable the main output */
;;;1197       __HAL_TIM_MOE_ENABLE(htim);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f4414100          ORR      r1,r1,#0x8000
00003c  6441              STR      r1,[r0,#0x44]
                  |L78.62|
;;;1198     }
;;;1199   
;;;1200     /* Enable the Peripheral */
;;;1201     __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;1202   
;;;1203     /* Return function status */
;;;1204     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;1205   }
00004a  bd10              POP      {r4,pc}
                  |L78.76|
00004c  68d0              LDR      r0,[r2,#0xc]          ;1176
00004e  f0400008          ORR      r0,r0,#8              ;1176
000052  e7e7              B        |L78.36|
                  |L78.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;1183
000056  f0400010          ORR      r0,r0,#0x10           ;1183
00005a  e7e3              B        |L78.36|
;;;1206   
                          ENDP

                  |L78.92|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1116   */
;;;1117   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1118   {
000002  4604              MOV      r4,r0
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1121   
;;;1122     /* Disable the Capture compare channel */
;;;1123     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1124   
;;;1125     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00000c  4b10              LDR      r3,|L79.80|
;;;1126     {
;;;1127       /* Disable the Main Ouput */
;;;1128       __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411111          MOV      r1,#0x1111
000012  6820              LDR      r0,[r4,#0]            ;1125
000014  108a              ASRS     r2,r1,#2
000016  4298              CMP      r0,r3                 ;1125
000018  d109              BNE      |L79.46|
00001a  6a03              LDR      r3,[r0,#0x20]
00001c  420b              TST      r3,r1
00001e  d106              BNE      |L79.46|
000020  6a03              LDR      r3,[r0,#0x20]
000022  4213              TST      r3,r2
000024  d103              BNE      |L79.46|
000026  6c43              LDR      r3,[r0,#0x44]
000028  f4234300          BIC      r3,r3,#0x8000
00002c  6443              STR      r3,[r0,#0x44]
                  |L79.46|
;;;1129     }
;;;1130   
;;;1131     /* Disable the Peripheral */
;;;1132     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  420b              TST      r3,r1
000034  d106              BNE      |L79.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d103              BNE      |L79.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L79.68|
;;;1133   
;;;1134     /* Change the htim state */
;;;1135     htim->State = HAL_TIM_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f8840039          STRB     r0,[r4,#0x39]
;;;1136   
;;;1137     /* Return function status */
;;;1138     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1139   }
00004c  bd10              POP      {r4,pc}
;;;1140   
                          ENDP

00004e  0000              DCW      0x0000
                  |L79.80|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1402   */
;;;1403   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1404   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L80.22|
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1407   
;;;1408     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L80.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L80.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L80.38|
000014  e030              B        |L80.120|
                  |L80.22|
;;;1409     {
;;;1410       case TIM_CHANNEL_1:
;;;1411       {
;;;1412         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1413         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1414       }
;;;1415       break;
00001c  e002              B        |L80.36|
                  |L80.30|
;;;1416   
;;;1417       case TIM_CHANNEL_2:
;;;1418       {
;;;1419         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1420         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L80.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1413
                  |L80.38|
;;;1421       }
;;;1422       break;
;;;1423   
;;;1424       case TIM_CHANNEL_3:
;;;1425       {
;;;1426         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1427         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1428       }
;;;1429       break;
;;;1430   
;;;1431       case TIM_CHANNEL_4:
;;;1432       {
;;;1433         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1434         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1435       }
;;;1436       break;
;;;1437   
;;;1438       default:
;;;1439       break;
;;;1440     }
;;;1441   
;;;1442     /* Disable the Capture compare channel */
;;;1443     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1444   
;;;1445     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b14              LDR      r3,|L80.128|
;;;1446     {
;;;1447       /* Disable the Main Ouput */
;;;1448       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411111          MOV      r1,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;1445
000036  108a              ASRS     r2,r1,#2
000038  4298              CMP      r0,r3                 ;1445
00003a  d109              BNE      |L80.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  420b              TST      r3,r1
000040  d106              BNE      |L80.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  4213              TST      r3,r2
000046  d103              BNE      |L80.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L80.80|
;;;1449     }
;;;1450   
;;;1451     /* Disable the Peripheral */
;;;1452     __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  420b              TST      r3,r1
000056  d106              BNE      |L80.102|
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4211              TST      r1,r2
00005c  d103              BNE      |L80.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L80.102|
;;;1453   
;;;1454     /* Change the htim state */
;;;1455     htim->State = HAL_TIM_STATE_READY;
000066  2001              MOVS     r0,#1
000068  f8840039          STRB     r0,[r4,#0x39]
;;;1456   
;;;1457     /* Return function status */
;;;1458     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1459   }
00006e  bd10              POP      {r4,pc}
                  |L80.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1427
000072  f4206000          BIC      r0,r0,#0x800          ;1427
000076  e7d5              B        |L80.36|
                  |L80.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;1434
00007a  f4205080          BIC      r0,r0,#0x1000         ;1434
00007e  e7d1              B        |L80.36|
;;;1460   
                          ENDP

                  |L80.128|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1217   */
;;;1218   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1219   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L81.22|
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1222   
;;;1223     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L81.30|
00000c  2908              CMP      r1,#8
00000e  d02c              BEQ      |L81.106|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L81.38|
000014  e02d              B        |L81.114|
                  |L81.22|
;;;1224     {
;;;1225       case TIM_CHANNEL_1:
;;;1226       {
;;;1227         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1228         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1229       }
;;;1230       break;
00001c  e002              B        |L81.36|
                  |L81.30|
;;;1231   
;;;1232       case TIM_CHANNEL_2:
;;;1233       {
;;;1234         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1235         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L81.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1228
                  |L81.38|
;;;1236       }
;;;1237       break;
;;;1238   
;;;1239       case TIM_CHANNEL_3:
;;;1240       {
;;;1241         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1242         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1243       }
;;;1244       break;
;;;1245   
;;;1246       case TIM_CHANNEL_4:
;;;1247       {
;;;1248         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1249         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1250       }
;;;1251       break;
;;;1252   
;;;1253       default:
;;;1254       break;
;;;1255     }
;;;1256   
;;;1257     /* Disable the Capture compare channel */
;;;1258     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1259   
;;;1260     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002e  4b13              LDR      r3,|L81.124|
;;;1261     {
;;;1262       /* Disable the Main Ouput */
;;;1263       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;1260
000036  1091              ASRS     r1,r2,#2
000038  4298              CMP      r0,r3                 ;1260
00003a  d109              BNE      |L81.80|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  4213              TST      r3,r2
000040  d106              BNE      |L81.80|
000042  6a03              LDR      r3,[r0,#0x20]
000044  420b              TST      r3,r1
000046  d103              BNE      |L81.80|
000048  6c43              LDR      r3,[r0,#0x44]
00004a  f4234300          BIC      r3,r3,#0x8000
00004e  6443              STR      r3,[r0,#0x44]
                  |L81.80|
;;;1264     }
;;;1265   
;;;1266     /* Disable the Peripheral */
;;;1267     __HAL_TIM_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  4213              TST      r3,r2
000056  d106              BNE      |L81.102|
000058  6a02              LDR      r2,[r0,#0x20]
00005a  420a              TST      r2,r1
00005c  d103              BNE      |L81.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L81.102|
;;;1268   
;;;1269     /* Return function status */
;;;1270     return HAL_OK;
000066  2000              MOVS     r0,#0
;;;1271   }
000068  bd10              POP      {r4,pc}
                  |L81.106|
00006a  68d0              LDR      r0,[r2,#0xc]          ;1242
00006c  f0200008          BIC      r0,r0,#8              ;1242
000070  e7d8              B        |L81.36|
                  |L81.114|
000072  68d0              LDR      r0,[r2,#0xc]          ;1249
000074  f0200010          BIC      r0,r0,#0x10           ;1249
000078  e7d4              B        |L81.36|
;;;1272   
                          ENDP

00007a  0000              DCW      0x0000
                  |L81.124|
                          DCD      0x40012c00

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4270     */
;;;4271   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4272   {
;;;4273     /* Prevent unused argument(s) compilation warning */
;;;4274     UNUSED(htim);
;;;4275     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4276               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4277      */
;;;4278   
;;;4279   }
;;;4280   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4183     */
;;;4184   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f8903038          LDRB     r3,[r0,#0x38]
;;;4185   {
;;;4186     uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;4187   
;;;4188     __HAL_LOCK(htim);
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L83.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L83.36|
;;;4189   
;;;4190     switch (Channel)
000012  2904              CMP      r1,#4
000014  d009              BEQ      |L83.42|
000016  2908              CMP      r1,#8
000018  d00a              BEQ      |L83.48|
00001a  290c              CMP      r1,#0xc
00001c  d10d              BNE      |L83.58|
00001e  e00a              B        |L83.54|
                  |L83.32|
000020  2002              MOVS     r0,#2                 ;4188
;;;4191     {
;;;4192     case TIM_CHANNEL_1:
;;;4193       {
;;;4194         /* Check the parameters */
;;;4195         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4196   
;;;4197         /* Return the capture 1 value */
;;;4198         tmpreg =  htim->Instance->CCR1;
;;;4199   
;;;4200         break;
;;;4201       }
;;;4202     case TIM_CHANNEL_2:
;;;4203       {
;;;4204         /* Check the parameters */
;;;4205         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4206   
;;;4207         /* Return the capture 2 value */
;;;4208         tmpreg =   htim->Instance->CCR2;
;;;4209   
;;;4210         break;
;;;4211       }
;;;4212   
;;;4213     case TIM_CHANNEL_3:
;;;4214       {
;;;4215         /* Check the parameters */
;;;4216         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4217   
;;;4218         /* Return the capture 3 value */
;;;4219         tmpreg =   htim->Instance->CCR3;
;;;4220   
;;;4221         break;
;;;4222       }
;;;4223   
;;;4224     case TIM_CHANNEL_4:
;;;4225       {
;;;4226         /* Check the parameters */
;;;4227         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4228   
;;;4229         /* Return the capture 4 value */
;;;4230         tmpreg =   htim->Instance->CCR4;
;;;4231   
;;;4232         break;
;;;4233       }
;;;4234   
;;;4235     default:
;;;4236       break;
;;;4237     }
;;;4238   
;;;4239     __HAL_UNLOCK(htim);
;;;4240     return tmpreg;
;;;4241   }
000022  4770              BX       lr
                  |L83.36|
000024  6801              LDR      r1,[r0,#0]            ;4198
000026  6b4a              LDR      r2,[r1,#0x34]         ;4198
000028  e007              B        |L83.58|
                  |L83.42|
00002a  6801              LDR      r1,[r0,#0]            ;4208
00002c  6b8a              LDR      r2,[r1,#0x38]         ;4208
00002e  e004              B        |L83.58|
                  |L83.48|
000030  6801              LDR      r1,[r0,#0]            ;4219
000032  6bca              LDR      r2,[r1,#0x3c]         ;4219
000034  e001              B        |L83.58|
                  |L83.54|
000036  6801              LDR      r1,[r0,#0]            ;4230
000038  6c0a              LDR      r2,[r1,#0x40]         ;4230
                  |L83.58|
00003a  2100              MOVS     r1,#0                 ;4239
00003c  f8801038          STRB     r1,[r0,#0x38]         ;4239
000040  4610              MOV      r0,r2                 ;4240
000042  4770              BX       lr
;;;4242   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4110     */
;;;4111   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4112   {
000002  4604              MOV      r4,r0
;;;4113     /* Check the parameters */
;;;4114     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4115     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4116     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4117   
;;;4118     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d018              BEQ      |L84.62|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;4119   
;;;4120     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
;;;4121   
;;;4122     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4123   
;;;4124     /* Disable Trigger Interrupt */
;;;4125     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
00001e  6820              LDR      r0,[r4,#0]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0210140          BIC      r1,r1,#0x40
000026  60c1              STR      r1,[r0,#0xc]
;;;4126   
;;;4127     /* Disable Trigger DMA request */
;;;4128     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4214180          BIC      r1,r1,#0x4000
000030  60c1              STR      r1,[r0,#0xc]
;;;4129   
;;;4130     htim->State = HAL_TIM_STATE_READY;
000032  f8845039          STRB     r5,[r4,#0x39]
;;;4131   
;;;4132     __HAL_UNLOCK(htim);
000036  2000              MOVS     r0,#0
000038  f8840038          STRB     r0,[r4,#0x38]
;;;4133   
;;;4134     return HAL_OK;
;;;4135       }
00003c  bd70              POP      {r4-r6,pc}
                  |L84.62|
00003e  2002              MOVS     r0,#2                 ;4118
000040  bd70              POP      {r4-r6,pc}
;;;4136   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4145     */
;;;4146   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4147                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4148       {
000002  4604              MOV      r4,r0
;;;4149         /* Check the parameters */
;;;4150     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4151     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4152     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4153   
;;;4154     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d018              BEQ      |L85.62|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;4155   
;;;4156     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
;;;4157   
;;;4158     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4159   
;;;4160     /* Enable Trigger Interrupt */
;;;4161     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
00001e  6820              LDR      r0,[r4,#0]
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0410140          ORR      r1,r1,#0x40
000026  60c1              STR      r1,[r0,#0xc]
;;;4162   
;;;4163     /* Disable Trigger DMA request */
;;;4164     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4214180          BIC      r1,r1,#0x4000
000030  60c1              STR      r1,[r0,#0xc]
;;;4165   
;;;4166     htim->State = HAL_TIM_STATE_READY;
000032  f8845039          STRB     r5,[r4,#0x39]
;;;4167   
;;;4168     __HAL_UNLOCK(htim);
000036  2000              MOVS     r0,#0
000038  f8840038          STRB     r0,[r4,#0x38]
;;;4169   
;;;4170     return HAL_OK;
;;;4171   }
00003c  bd70              POP      {r4-r6,pc}
                  |L85.62|
00003e  2002              MOVS     r0,#2                 ;4154
000040  bd70              POP      {r4-r6,pc}
;;;4172   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4325     */
;;;4326   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4327   {
;;;4328     /* Prevent unused argument(s) compilation warning */
;;;4329     UNUSED(htim);
;;;4330     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4331               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4332      */
;;;4333   }
;;;4334   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4552     */
;;;4553   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b570              PUSH     {r4-r6,lr}
;;;4554   {
;;;4555     uint32_t tmpcr1 = 0;
;;;4556     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4557   
;;;4558     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4559     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  4b11              LDR      r3,|L87.76|
000006  4c12              LDR      r4,|L87.80|
000008  f04f4680          MOV      r6,#0x40000000
00000c  4298              CMP      r0,r3
00000e  d003              BEQ      |L87.24|
000010  42b0              CMP      r0,r6
000012  d001              BEQ      |L87.24|
000014  42a0              CMP      r0,r4
000016  d103              BNE      |L87.32|
                  |L87.24|
;;;4560     {
;;;4561       /* Select the Counter Mode */
;;;4562       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000018  f0220570          BIC      r5,r2,#0x70
;;;4563       tmpcr1 |= Structure->CounterMode;
00001c  684a              LDR      r2,[r1,#4]
00001e  432a              ORRS     r2,r2,r5
                  |L87.32|
;;;4564     }
;;;4565   
;;;4566     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
000020  4298              CMP      r0,r3
000022  d003              BEQ      |L87.44|
000024  42b0              CMP      r0,r6
000026  d001              BEQ      |L87.44|
000028  42a0              CMP      r0,r4
00002a  d103              BNE      |L87.52|
                  |L87.44|
;;;4567     {
;;;4568       /* Set the clock division */
;;;4569       tmpcr1 &= ~TIM_CR1_CKD;
00002c  f4227440          BIC      r4,r2,#0x300
;;;4570       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000030  68ca              LDR      r2,[r1,#0xc]
000032  4322              ORRS     r2,r2,r4
                  |L87.52|
;;;4571     }
;;;4572   
;;;4573     TIMx->CR1 = tmpcr1;
000034  6002              STR      r2,[r0,#0]
;;;4574   
;;;4575     /* Set the Autoreload value */
;;;4576     TIMx->ARR = (uint32_t)Structure->Period ;
000036  688a              LDR      r2,[r1,#8]
000038  62c2              STR      r2,[r0,#0x2c]
;;;4577   
;;;4578     /* Set the Prescaler value */
;;;4579     TIMx->PSC = (uint32_t)Structure->Prescaler;
00003a  680a              LDR      r2,[r1,#0]
00003c  6282              STR      r2,[r0,#0x28]
;;;4580   
;;;4581     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
00003e  4298              CMP      r0,r3
000040  d101              BNE      |L87.70|
;;;4582     {
;;;4583       /* Set the Repetition Counter value */
;;;4584       TIMx->RCR = Structure->RepetitionCounter;
000042  6909              LDR      r1,[r1,#0x10]
000044  6301              STR      r1,[r0,#0x30]
                  |L87.70|
;;;4585     }
;;;4586   
;;;4587     /* Generate an update event to reload the Prescaler 
;;;4588        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4589     TIMx->EGR = TIM_EGR_UG;
000046  2101              MOVS     r1,#1
000048  6141              STR      r1,[r0,#0x14]
;;;4590   }
00004a  bd70              POP      {r4-r6,pc}
;;;4591   
                          ENDP

                  |L87.76|
                          DCD      0x40012c00
                  |L87.80|
                          DCD      0x40000400

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5349     */
;;;5350   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b510              PUSH     {r4,lr}
;;;5351   {
;;;5352     uint32_t tmp = 0;
;;;5353   
;;;5354     /* Check the parameters */
;;;5355     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5356     assert_param(IS_TIM_CHANNELS(Channel));
;;;5357   
;;;5358     tmp = TIM_CCER_CC1E << Channel;
000002  2301              MOVS     r3,#1
;;;5359   
;;;5360     /* Reset the CCxE Bit */
;;;5361     TIMx->CCER &= ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;5358
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;5362   
;;;5363     /* Set or reset the CCxE Bit */
;;;5364     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;5365   }
000014  bd10              POP      {r4,pc}
;;;5366   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4490     */
;;;4491   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4492   {
;;;4493     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4494   
;;;4495     htim->State= HAL_TIM_STATE_READY;
000002  6a44              LDR      r4,[r0,#0x24]
000004  2101              MOVS     r1,#1
000006  f8841039          STRB     r1,[r4,#0x39]
;;;4496   
;;;4497     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a22              LDR      r2,[r4,#0x20]
00000c  4282              CMP      r2,r0
00000e  d101              BNE      |L89.20|
;;;4498     {
;;;4499       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  7621              STRB     r1,[r4,#0x18]
000012  e00e              B        |L89.50|
                  |L89.20|
;;;4500     }
;;;4501     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6a61              LDR      r1,[r4,#0x24]
000016  4281              CMP      r1,r0
000018  d101              BNE      |L89.30|
;;;4502     {
;;;4503       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  e008              B        |L89.48|
                  |L89.30|
;;;4504     }
;;;4505     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6aa1              LDR      r1,[r4,#0x28]
000020  4281              CMP      r1,r0
000022  d101              BNE      |L89.40|
;;;4506     {
;;;4507       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000024  2004              MOVS     r0,#4
000026  e003              B        |L89.48|
                  |L89.40|
;;;4508     }
;;;4509     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6ae1              LDR      r1,[r4,#0x2c]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L89.50|
;;;4510     {
;;;4511       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
                  |L89.48|
000030  7620              STRB     r0,[r4,#0x18]
                  |L89.50|
;;;4512     }
;;;4513   
;;;4514     HAL_TIM_IC_CaptureCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4515   
;;;4516     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7620              STRB     r0,[r4,#0x18]
;;;4517   }
00003c  bd10              POP      {r4,pc}
;;;4518   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4458     */
;;;4459   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4460   {
;;;4461     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4462   
;;;4463     htim->State= HAL_TIM_STATE_READY;
000002  6a44              LDR      r4,[r0,#0x24]
000004  2101              MOVS     r1,#1
000006  f8841039          STRB     r1,[r4,#0x39]
;;;4464   
;;;4465     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a22              LDR      r2,[r4,#0x20]
00000c  4282              CMP      r2,r0
00000e  d101              BNE      |L90.20|
;;;4466     {
;;;4467       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  7621              STRB     r1,[r4,#0x18]
000012  e00e              B        |L90.50|
                  |L90.20|
;;;4468     }
;;;4469     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6a61              LDR      r1,[r4,#0x24]
000016  4281              CMP      r1,r0
000018  d101              BNE      |L90.30|
;;;4470     {
;;;4471       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  e008              B        |L90.48|
                  |L90.30|
;;;4472     }
;;;4473     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6aa1              LDR      r1,[r4,#0x28]
000020  4281              CMP      r1,r0
000022  d101              BNE      |L90.40|
;;;4474     {
;;;4475       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000024  2004              MOVS     r0,#4
000026  e003              B        |L90.48|
                  |L90.40|
;;;4476     }
;;;4477     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6ae1              LDR      r1,[r4,#0x2c]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L90.50|
;;;4478     {
;;;4479       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
                  |L90.48|
000030  7620              STRB     r0,[r4,#0x18]
                  |L90.50|
;;;4480     }
;;;4481   
;;;4482     HAL_TIM_PWM_PulseFinishedCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4483   
;;;4484     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7620              STRB     r0,[r4,#0x18]
;;;4485   }
00003c  bd10              POP      {r4,pc}
;;;4486   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4444     */
;;;4445   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4446   {
;;;4447     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4448   
;;;4449     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4450   
;;;4451     HAL_TIM_ErrorCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4452   }
00000e  bd10              POP      {r4,pc}
;;;4453   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4523     */
;;;4524   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4525   {
;;;4526     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4527   
;;;4528     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4529   
;;;4530     HAL_TIM_PeriodElapsedCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4531   }
00000e  bd10              POP      {r4,pc}
;;;4532   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4537     */
;;;4538   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4539   {
;;;4540     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;4541   
;;;4542     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4543   
;;;4544     HAL_TIM_TriggerCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4545   }
00000e  bd10              POP      {r4,pc}
;;;4546   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5319     */
;;;5320   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;5321                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5322   {
;;;5323     uint32_t tmpsmcr = 0;
;;;5324   
;;;5325     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;5326   
;;;5327     /* Reset the ETR Bits */
;;;5328     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;5329   
;;;5330     /* Set the Prescaler, the Filter value and the Polarity */
;;;5331     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
000004  ea422203          ORR      r2,r2,r3,LSL #8
000008  f424447f          BIC      r4,r4,#0xff00         ;5328
00000c  430a              ORRS     r2,r2,r1
00000e  4322              ORRS     r2,r2,r4
;;;5332   
;;;5333     /* Write to TIMx SMCR */
;;;5334     TIMx->SMCR = tmpsmcr;
000010  6082              STR      r2,[r0,#8]
;;;5335   }
000012  bd10              POP      {r4,pc}
;;;5336   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;5289     */
;;;5290   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
000000  6882              LDR      r2,[r0,#8]
;;;5291   {
;;;5292     uint32_t tmpsmcr = 0;
;;;5293   
;;;5294      /* Get the TIMx SMCR register value */
;;;5295      tmpsmcr = TIMx->SMCR;
;;;5296      /* Reset the TS Bits */
;;;5297      tmpsmcr &= ~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;5298      /* Set the Input Trigger source and the slave mode*/
;;;5299      tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
000006  430a              ORRS     r2,r2,r1
000008  f0420107          ORR      r1,r2,#7
;;;5300      /* Write to TIMx SMCR */
;;;5301      TIMx->SMCR = tmpsmcr;
00000c  6081              STR      r1,[r0,#8]
;;;5302   }
00000e  4770              BX       lr
;;;5303   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4597     */
;;;4598   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4599   {
;;;4600     uint32_t tmpccmrx = 0;
;;;4601     uint32_t tmpccer = 0;
;;;4602     uint32_t tmpcr2 = 0;
;;;4603   
;;;4604      /* Disable the Channel 1: Reset the CC1E Bit */
;;;4605     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  6202              STR      r2,[r0,#0x20]
;;;4606   
;;;4607     /* Get the TIMx CCER register value */
;;;4608     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4609     /* Get the TIMx CR2 register value */
;;;4610     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4611   
;;;4612     /* Get the TIMx CCMR1 register value */
;;;4613     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4614   
;;;4615     /* Reset the Output Compare Mode Bits */
;;;4616     tmpccmrx &= ~TIM_CCMR1_OC1M;
;;;4617     tmpccmrx &= ~TIM_CCMR1_CC1S;
000010  f0240573          BIC      r5,r4,#0x73
;;;4618     /* Select the Output Compare Mode */
;;;4619     tmpccmrx |= OC_Config->OCMode;
000014  680c              LDR      r4,[r1,#0]
000016  432c              ORRS     r4,r4,r5
;;;4620   
;;;4621     /* Reset the Output Polarity level */
;;;4622     tmpccer &= ~TIM_CCER_CC1P;
000018  f0220502          BIC      r5,r2,#2
;;;4623     /* Set the Output Compare Polarity */
;;;4624     tmpccer |= OC_Config->OCPolarity;
00001c  688a              LDR      r2,[r1,#8]
00001e  432a              ORRS     r2,r2,r5
;;;4625   
;;;4626     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000020  4d0a              LDR      r5,|L96.76|
000022  42a8              CMP      r0,r5
000024  d10b              BNE      |L96.62|
;;;4627     {
;;;4628       /* Check parameters */
;;;4629       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4630   
;;;4631       /* Reset the Output N Polarity level */
;;;4632       tmpccer &= ~TIM_CCER_CC1NP;
000026  f0220508          BIC      r5,r2,#8
;;;4633       /* Set the Output N Polarity */
;;;4634       tmpccer |= OC_Config->OCNPolarity;
00002a  68ca              LDR      r2,[r1,#0xc]
;;;4635       /* Reset the Output N State */
;;;4636       tmpccer &= ~TIM_CCER_CC1NE;
;;;4637     }
;;;4638   
;;;4639     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4640     {
;;;4641       /* Check parameters */
;;;4642       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4643       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4644   
;;;4645       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4646       tmpcr2 &= ~TIM_CR2_OIS1;
;;;4647       tmpcr2 &= ~TIM_CR2_OIS1N;
00002c  f4237340          BIC      r3,r3,#0x300
000030  432a              ORRS     r2,r2,r5              ;4634
;;;4648       /* Set the Output Idle state */
;;;4649       tmpcr2 |= OC_Config->OCIdleState;
000032  694d              LDR      r5,[r1,#0x14]
000034  f0220204          BIC      r2,r2,#4              ;4636
000038  431d              ORRS     r5,r5,r3
;;;4650       /* Set the Output N Idle state */
;;;4651       tmpcr2 |= OC_Config->OCNIdleState;
00003a  698b              LDR      r3,[r1,#0x18]
00003c  432b              ORRS     r3,r3,r5
                  |L96.62|
;;;4652     }
;;;4653     /* Write to TIMx CR2 */
;;;4654     TIMx->CR2 = tmpcr2;
00003e  6043              STR      r3,[r0,#4]
;;;4655   
;;;4656     /* Write to TIMx CCMR1 */
;;;4657     TIMx->CCMR1 = tmpccmrx;
000040  6184              STR      r4,[r0,#0x18]
;;;4658   
;;;4659     /* Set the Capture Compare Register value */
;;;4660     TIMx->CCR1 = OC_Config->Pulse;
000042  6849              LDR      r1,[r1,#4]
000044  6341              STR      r1,[r0,#0x34]
;;;4661   
;;;4662     /* Write to TIMx CCER */
;;;4663     TIMx->CCER = tmpccer;
000046  6202              STR      r2,[r0,#0x20]
;;;4664   }
000048  bd30              POP      {r4,r5,pc}
;;;4665   
                          ENDP

00004a  0000              DCW      0x0000
                  |L96.76|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4671     */
;;;4672   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4673   {
;;;4674     uint32_t tmpccmrx = 0;
;;;4675     uint32_t tmpccer = 0;
;;;4676     uint32_t tmpcr2 = 0;
;;;4677   
;;;4678     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4679     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;4680   
;;;4681     /* Get the TIMx CCER register value */
;;;4682     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4683     /* Get the TIMx CR2 register value */
;;;4684     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4685   
;;;4686     /* Get the TIMx CCMR1 register value */
;;;4687     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4688   
;;;4689     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4690     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;4691     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;4692   
;;;4693     /* Select the Output Compare Mode */
;;;4694     tmpccmrx |= (OC_Config->OCMode << 8);
000010  680d              LDR      r5,[r1,#0]
000012  f42444e6          BIC      r4,r4,#0x7300         ;4691
000016  ea442405          ORR      r4,r4,r5,LSL #8
;;;4695   
;;;4696     /* Reset the Output Polarity level */
;;;4697     tmpccer &= ~TIM_CCER_CC2P;
;;;4698     /* Set the Output Compare Polarity */
;;;4699     tmpccer |= (OC_Config->OCPolarity << 4);
00001a  688d              LDR      r5,[r1,#8]
00001c  f0220220          BIC      r2,r2,#0x20           ;4697
000020  ea421205          ORR      r2,r2,r5,LSL #4
;;;4700   
;;;4701     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000024  4d0b              LDR      r5,|L97.84|
000026  42a8              CMP      r0,r5
000028  d10e              BNE      |L97.72|
;;;4702     {
;;;4703       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4704   
;;;4705       /* Reset the Output N Polarity level */
;;;4706       tmpccer &= ~TIM_CCER_CC2NP;
;;;4707       /* Set the Output N Polarity */
;;;4708       tmpccer |= (OC_Config->OCNPolarity << 4);
00002a  68cd              LDR      r5,[r1,#0xc]
00002c  f0220280          BIC      r2,r2,#0x80           ;4706
000030  ea421205          ORR      r2,r2,r5,LSL #4
;;;4709       /* Reset the Output N State */
;;;4710       tmpccer &= ~TIM_CCER_CC2NE;
;;;4711   
;;;4712     }
;;;4713   
;;;4714     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4715     {
;;;4716       /* Check parameters */
;;;4717       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4718       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4719   
;;;4720       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4721       tmpcr2 &= ~TIM_CR2_OIS2;
;;;4722       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4723       /* Set the Output Idle state */
;;;4724       tmpcr2 |= (OC_Config->OCIdleState << 2);
000034  694d              LDR      r5,[r1,#0x14]
000036  f4236340          BIC      r3,r3,#0xc00          ;4722
00003a  ea430385          ORR      r3,r3,r5,LSL #2
;;;4725       /* Set the Output N Idle state */
;;;4726       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00003e  698d              LDR      r5,[r1,#0x18]
000040  f0220240          BIC      r2,r2,#0x40           ;4710
000044  ea430385          ORR      r3,r3,r5,LSL #2
                  |L97.72|
;;;4727     }
;;;4728   
;;;4729     /* Write to TIMx CR2 */
;;;4730     TIMx->CR2 = tmpcr2;
000048  6043              STR      r3,[r0,#4]
;;;4731   
;;;4732     /* Write to TIMx CCMR1 */
;;;4733     TIMx->CCMR1 = tmpccmrx;
00004a  6184              STR      r4,[r0,#0x18]
;;;4734   
;;;4735     /* Set the Capture Compare Register value */
;;;4736     TIMx->CCR2 = OC_Config->Pulse;
00004c  6849              LDR      r1,[r1,#4]
00004e  6381              STR      r1,[r0,#0x38]
;;;4737   
;;;4738     /* Write to TIMx CCER */
;;;4739     TIMx->CCER = tmpccer;
000050  6202              STR      r2,[r0,#0x20]
;;;4740   }
000052  bd30              POP      {r4,r5,pc}
;;;4741   
                          ENDP

                  |L97.84|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4747     */
;;;4748   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4749   {
;;;4750     uint32_t tmpccmrx = 0;
;;;4751     uint32_t tmpccer = 0;
;;;4752     uint32_t tmpcr2 = 0;
;;;4753   
;;;4754     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4755     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  6202              STR      r2,[r0,#0x20]
;;;4756   
;;;4757     /* Get the TIMx CCER register value */
;;;4758     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4759     /* Get the TIMx CR2 register value */
;;;4760     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4761   
;;;4762     /* Get the TIMx CCMR2 register value */
;;;4763     tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;4764   
;;;4765     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4766     tmpccmrx &= ~TIM_CCMR2_OC3M;
;;;4767     tmpccmrx &= ~TIM_CCMR2_CC3S;
;;;4768     /* Select the Output Compare Mode */
;;;4769     tmpccmrx |= OC_Config->OCMode;
;;;4770   
;;;4771     /* Reset the Output Polarity level */
;;;4772     tmpccer &= ~TIM_CCER_CC3P;
000010  f4237300          BIC      r3,r3,#0x200
000014  f0240573          BIC      r5,r4,#0x73           ;4767
000018  680c              LDR      r4,[r1,#0]            ;4769
00001a  432c              ORRS     r4,r4,r5              ;4769
;;;4773     /* Set the Output Compare Polarity */
;;;4774     tmpccer |= (OC_Config->OCPolarity << 8);
00001c  688d              LDR      r5,[r1,#8]
00001e  ea432305          ORR      r3,r3,r5,LSL #8
;;;4775   
;;;4776     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
000022  4d0c              LDR      r5,|L98.84|
000024  42a8              CMP      r0,r5
000026  d10e              BNE      |L98.70|
;;;4777     {
;;;4778       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4779   
;;;4780       /* Reset the Output N Polarity level */
;;;4781       tmpccer &= ~TIM_CCER_CC3NP;
;;;4782       /* Set the Output N Polarity */
;;;4783       tmpccer |= (OC_Config->OCNPolarity << 8);
000028  68cd              LDR      r5,[r1,#0xc]
00002a  f4236300          BIC      r3,r3,#0x800          ;4781
00002e  ea432305          ORR      r3,r3,r5,LSL #8
;;;4784       /* Reset the Output N State */
;;;4785       tmpccer &= ~TIM_CCER_CC3NE;
;;;4786     }
;;;4787   
;;;4788     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4789     {
;;;4790       /* Check parameters */
;;;4791       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4792       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4793   
;;;4794       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4795       tmpcr2 &= ~TIM_CR2_OIS3;
;;;4796       tmpcr2 &= ~TIM_CR2_OIS3N;
;;;4797       /* Set the Output Idle state */
;;;4798       tmpcr2 |= (OC_Config->OCIdleState << 4);
000032  694d              LDR      r5,[r1,#0x14]
000034  f4225240          BIC      r2,r2,#0x3000         ;4796
000038  ea421205          ORR      r2,r2,r5,LSL #4
;;;4799       /* Set the Output N Idle state */
;;;4800       tmpcr2 |= (OC_Config->OCNIdleState << 4);
00003c  698d              LDR      r5,[r1,#0x18]
00003e  f4236380          BIC      r3,r3,#0x400          ;4785
000042  ea421205          ORR      r2,r2,r5,LSL #4
                  |L98.70|
;;;4801     }
;;;4802   
;;;4803     /* Write to TIMx CR2 */
;;;4804     TIMx->CR2 = tmpcr2;
000046  6042              STR      r2,[r0,#4]
;;;4805   
;;;4806     /* Write to TIMx CCMR2 */
;;;4807     TIMx->CCMR2 = tmpccmrx;
000048  61c4              STR      r4,[r0,#0x1c]
;;;4808   
;;;4809     /* Set the Capture Compare Register value */
;;;4810     TIMx->CCR3 = OC_Config->Pulse;
00004a  6849              LDR      r1,[r1,#4]
00004c  63c1              STR      r1,[r0,#0x3c]
;;;4811   
;;;4812     /* Write to TIMx CCER */
;;;4813     TIMx->CCER = tmpccer;
00004e  6203              STR      r3,[r0,#0x20]
;;;4814   }
000050  bd30              POP      {r4,r5,pc}
;;;4815   
                          ENDP

000052  0000              DCW      0x0000
                  |L98.84|
                          DCD      0x40012c00

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4821     */
;;;4822   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4823   {
;;;4824     uint32_t tmpccmrx = 0;
;;;4825     uint32_t tmpccer = 0;
;;;4826     uint32_t tmpcr2 = 0;
;;;4827   
;;;4828     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4829     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  6202              STR      r2,[r0,#0x20]
;;;4830   
;;;4831     /* Get the TIMx CCER register value */
;;;4832     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;4833     /* Get the TIMx CR2 register value */
;;;4834     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4835   
;;;4836     /* Get the TIMx CCMR2 register value */
;;;4837     tmpccmrx = TIMx->CCMR2;
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;4838   
;;;4839     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4840     tmpccmrx &= ~TIM_CCMR2_OC4M;
;;;4841     tmpccmrx &= ~TIM_CCMR2_CC4S;
;;;4842   
;;;4843     /* Select the Output Compare Mode */
;;;4844     tmpccmrx |= (OC_Config->OCMode << 8);
000010  680d              LDR      r5,[r1,#0]
000012  f42343e6          BIC      r3,r3,#0x7300         ;4841
000016  ea432305          ORR      r3,r3,r5,LSL #8
;;;4845   
;;;4846     /* Reset the Output Polarity level */
;;;4847     tmpccer &= ~TIM_CCER_CC4P;
;;;4848     /* Set the Output Compare Polarity */
;;;4849     tmpccer |= (OC_Config->OCPolarity << 12);
00001a  688d              LDR      r5,[r1,#8]
00001c  f4245400          BIC      r4,r4,#0x2000         ;4847
000020  ea443405          ORR      r4,r4,r5,LSL #12
;;;4850   
;;;4851     if(IS_TIM_BREAK_INSTANCE(TIMx))
000024  4d06              LDR      r5,|L99.64|
000026  42a8              CMP      r0,r5
000028  d104              BNE      |L99.52|
;;;4852     {
;;;4853       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4854   
;;;4855      /* Reset the Output Compare IDLE State */
;;;4856       tmpcr2 &= ~TIM_CR2_OIS4;
;;;4857       /* Set the Output Idle state */
;;;4858       tmpcr2 |= (OC_Config->OCIdleState << 6);
00002a  694d              LDR      r5,[r1,#0x14]
00002c  f4224280          BIC      r2,r2,#0x4000         ;4856
000030  ea421285          ORR      r2,r2,r5,LSL #6
                  |L99.52|
;;;4859     }
;;;4860   
;;;4861     /* Write to TIMx CR2 */
;;;4862     TIMx->CR2 = tmpcr2;
000034  6042              STR      r2,[r0,#4]
;;;4863   
;;;4864     /* Write to TIMx CCMR2 */
;;;4865     TIMx->CCMR2 = tmpccmrx;
000036  61c3              STR      r3,[r0,#0x1c]
;;;4866   
;;;4867     /* Set the Capture Compare Register value */
;;;4868     TIMx->CCR4 = OC_Config->Pulse;
000038  6849              LDR      r1,[r1,#4]
00003a  6401              STR      r1,[r0,#0x40]
;;;4869   
;;;4870     /* Write to TIMx CCER */
;;;4871     TIMx->CCER = tmpccer;
00003c  6204              STR      r4,[r0,#0x20]
;;;4872   }
00003e  bd30              POP      {r4,r5,pc}
;;;4873   
                          ENDP

                  |L99.64|
                          DCD      0x40012c00

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4881     */
;;;4882   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b430              PUSH     {r4,r5}
;;;4883                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4884   {
;;;4885     uint32_t tmpsmcr = 0;
;;;4886     uint32_t tmpccmr1 = 0;
;;;4887     uint32_t tmpccer = 0;
;;;4888   
;;;4889     /* Get the TIMx SMCR register value */
;;;4890     tmpsmcr = htim->Instance->SMCR;
000002  6803              LDR      r3,[r0,#0]
000004  689a              LDR      r2,[r3,#8]
;;;4891   
;;;4892     /* Reset the Trigger Selection Bits */
;;;4893     tmpsmcr &= ~TIM_SMCR_TS;
000006  f0220470          BIC      r4,r2,#0x70
;;;4894     /* Set the Input Trigger source */
;;;4895     tmpsmcr |= sSlaveConfig->InputTrigger;
00000a  684a              LDR      r2,[r1,#4]
00000c  4322              ORRS     r2,r2,r4
;;;4896   
;;;4897     /* Reset the slave mode Bits */
;;;4898     tmpsmcr &= ~TIM_SMCR_SMS;
00000e  f0220407          BIC      r4,r2,#7
;;;4899     /* Set the slave mode */
;;;4900     tmpsmcr |= sSlaveConfig->SlaveMode;
000012  680a              LDR      r2,[r1,#0]
000014  4322              ORRS     r2,r2,r4
;;;4901   
;;;4902     /* Write to TIMx SMCR */
;;;4903     htim->Instance->SMCR = tmpsmcr;
000016  609a              STR      r2,[r3,#8]
;;;4904   
;;;4905     /* Configure the trigger prescaler, filter, and polarity */
;;;4906     switch (sSlaveConfig->InputTrigger)
000018  684a              LDR      r2,[r1,#4]
00001a  f0120f0f          TST      r2,#0xf
00001e  d11f              BNE      |L100.96|
000020  1112              ASRS     r2,r2,#4
000022  2a08              CMP      r2,#8
000024  d21c              BCS      |L100.96|
000026  e8dff002          TBB      [pc,r2]
00002a  1b1b              DCB      0x1b,0x1b
00002c  1b1b0b1d          DCB      0x1b,0x1b,0x0b,0x1d
000030  2304              DCB      0x23,0x04
;;;4907     {
;;;4908     case TIM_TS_ETRF:
;;;4909       {
;;;4910         /* Check the parameters */
;;;4911         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4912         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4913         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4914         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4915         /* Configure the ETR Trigger source */
;;;4916         TIM_ETR_SetConfig(htim->Instance,
000032  690b              LDR      r3,[r1,#0x10]
000034  e9d12102          LDRD     r2,r1,[r1,#8]
000038  6800              LDR      r0,[r0,#0]
00003a  bc30              POP      {r4,r5}
00003c  f7ffbffe          B.W      TIM_ETR_SetConfig
;;;4917                           sSlaveConfig->TriggerPrescaler,
;;;4918                           sSlaveConfig->TriggerPolarity,
;;;4919                           sSlaveConfig->TriggerFilter);
;;;4920       }
;;;4921       break;
;;;4922   
;;;4923     case TIM_TS_TI1F_ED:
;;;4924       {
;;;4925         /* Check the parameters */
;;;4926         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4927         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4928   
;;;4929         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4930         tmpccer = htim->Instance->CCER;
000040  6802              LDR      r2,[r0,#0]
000042  6a13              LDR      r3,[r2,#0x20]
;;;4931         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000044  6a14              LDR      r4,[r2,#0x20]
000046  f0240401          BIC      r4,r4,#1
00004a  6214              STR      r4,[r2,#0x20]
;;;4932         tmpccmr1 = htim->Instance->CCMR1;
00004c  6802              LDR      r2,[r0,#0]
00004e  6994              LDR      r4,[r2,#0x18]
;;;4933   
;;;4934         /* Set the filter */
;;;4935         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4936         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
000050  6909              LDR      r1,[r1,#0x10]
000052  f02404f0          BIC      r4,r4,#0xf0           ;4935
000056  ea441101          ORR      r1,r4,r1,LSL #4
;;;4937   
;;;4938         /* Write to TIMx CCMR1 and CCER registers */
;;;4939         htim->Instance->CCMR1 = tmpccmr1;
00005a  6191              STR      r1,[r2,#0x18]
;;;4940         htim->Instance->CCER = tmpccer;
00005c  6800              LDR      r0,[r0,#0]
00005e  6203              STR      r3,[r0,#0x20]
                  |L100.96|
;;;4941   
;;;4942       }
;;;4943       break;
;;;4944   
;;;4945     case TIM_TS_TI1FP1:
;;;4946       {
;;;4947         /* Check the parameters */
;;;4948         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4949         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4950         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4951   
;;;4952         /* Configure TI1 Filter and Polarity */
;;;4953         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4954                                  sSlaveConfig->TriggerPolarity,
;;;4955                                  sSlaveConfig->TriggerFilter);
;;;4956       }
;;;4957       break;
;;;4958   
;;;4959     case TIM_TS_TI2FP2:
;;;4960       {
;;;4961         /* Check the parameters */
;;;4962         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4963         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4964         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4965   
;;;4966         /* Configure TI2 Filter and Polarity */
;;;4967         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4968                                   sSlaveConfig->TriggerPolarity,
;;;4969                                   sSlaveConfig->TriggerFilter);
;;;4970       }
;;;4971       break;
;;;4972   
;;;4973     case TIM_TS_ITR0:
;;;4974       {
;;;4975         /* Check the parameter */
;;;4976         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4977       }
;;;4978       break;
;;;4979   
;;;4980     case TIM_TS_ITR1:
;;;4981       {
;;;4982         /* Check the parameter */
;;;4983         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4984       }
;;;4985       break;
;;;4986   
;;;4987     case TIM_TS_ITR2:
;;;4988       {
;;;4989         /* Check the parameter */
;;;4990         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4991       }
;;;4992       break;
;;;4993   
;;;4994     case TIM_TS_ITR3:
;;;4995       {
;;;4996         /* Check the parameter */
;;;4997         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4998       }
;;;4999       break;
;;;5000   
;;;5001     default:
;;;5002       break;
;;;5003     }
;;;5004   }
000060  bc30              POP      {r4,r5}
000062  4770              BX       lr
000064  690a              LDR      r2,[r1,#0x10]         ;4953
000066  6889              LDR      r1,[r1,#8]            ;4953
000068  6800              LDR      r0,[r0,#0]            ;4953
00006a  bc30              POP      {r4,r5}               ;4953
00006c  f7ffbffe          B.W      TIM_TI1_ConfigInputStage
000070  690a              LDR      r2,[r1,#0x10]         ;4967
000072  6889              LDR      r1,[r1,#8]            ;4967
000074  6800              LDR      r0,[r0,#0]            ;4967
000076  bc30              POP      {r4,r5}               ;4967
000078  f7ffbffe          B.W      TIM_TI2_ConfigInputStage
;;;5005   
                          ENDP


                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5072     */
;;;5073   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5074   {
;;;5075     uint32_t tmpccmr1 = 0;
;;;5076     uint32_t tmpccer = 0;
;;;5077   
;;;5078     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5079     tmpccer = TIMx->CCER;
000002  6a03              LDR      r3,[r0,#0x20]
;;;5080     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a04              LDR      r4,[r0,#0x20]
000006  f0240401          BIC      r4,r4,#1
00000a  6204              STR      r4,[r0,#0x20]
;;;5081     tmpccmr1 = TIMx->CCMR1;
00000c  6984              LDR      r4,[r0,#0x18]
;;;5082   
;;;5083     /* Set the filter */
;;;5084     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00000e  f02404f0          BIC      r4,r4,#0xf0
;;;5085     tmpccmr1 |= (TIM_ICFilter << 4);
000012  ea441402          ORR      r4,r4,r2,LSL #4
;;;5086   
;;;5087     /* Select the Polarity and set the CC1E Bit */
;;;5088     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000016  f023020a          BIC      r2,r3,#0xa
;;;5089     tmpccer |= TIM_ICPolarity;
00001a  430a              ORRS     r2,r2,r1
;;;5090   
;;;5091     /* Write to TIMx CCMR1 and CCER registers */
;;;5092     TIMx->CCMR1 = tmpccmr1;
00001c  6184              STR      r4,[r0,#0x18]
;;;5093     TIMx->CCER = tmpccer;
00001e  6202              STR      r2,[r0,#0x20]
;;;5094   }
000020  bd10              POP      {r4,pc}
;;;5095   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5025     */
;;;5026   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5027                          uint32_t TIM_ICFilter)
;;;5028   {
;;;5029     uint32_t tmpccmr1 = 0;
;;;5030     uint32_t tmpccer = 0;
;;;5031   
;;;5032     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5033     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;5034     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5035     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5036   
;;;5037     /* Select the Input */
;;;5038     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
00000e  4e0e              LDR      r6,|L102.72|
000010  42b0              CMP      r0,r6
000012  d005              BEQ      |L102.32|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d002              BEQ      |L102.32|
00001a  4e0c              LDR      r6,|L102.76|
00001c  42b0              CMP      r0,r6
00001e  d103              BNE      |L102.40|
                  |L102.32|
;;;5039     {
;;;5040       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000020  f0240403          BIC      r4,r4,#3
;;;5041       tmpccmr1 |= TIM_ICSelection;
000024  4314              ORRS     r4,r4,r2
000026  e001              B        |L102.44|
                  |L102.40|
;;;5042     }
;;;5043     else
;;;5044     {
;;;5045       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000028  f0440401          ORR      r4,r4,#1
                  |L102.44|
;;;5046     }
;;;5047   
;;;5048     /* Set the filter */
;;;5049     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00002c  071a              LSLS     r2,r3,#28
00002e  f02404f0          BIC      r4,r4,#0xf0
;;;5050     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
000032  ea446212          ORR      r2,r4,r2,LSR #24
;;;5051   
;;;5052     /* Select the Polarity and set the CC1E Bit */
;;;5053     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000036  f025030a          BIC      r3,r5,#0xa
;;;5054     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00003a  f001010a          AND      r1,r1,#0xa
00003e  4319              ORRS     r1,r1,r3
;;;5055   
;;;5056     /* Write to TIMx CCMR1 and CCER registers */
;;;5057     TIMx->CCMR1 = tmpccmr1;
000040  6182              STR      r2,[r0,#0x18]
;;;5058     TIMx->CCER = tmpccer;
000042  6201              STR      r1,[r0,#0x20]
;;;5059   }
000044  bd70              POP      {r4-r6,pc}
;;;5060   
                          ENDP

000046  0000              DCW      0x0000
                  |L102.72|
                          DCD      0x40012c00
                  |L102.76|
                          DCD      0x40000400

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;5155     */
;;;5156   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5157   {
;;;5158     uint32_t tmpccmr1 = 0;
;;;5159     uint32_t tmpccer = 0;
;;;5160   
;;;5161     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5162     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a03              LDR      r3,[r0,#0x20]
000004  f0230310          BIC      r3,r3,#0x10
000008  6203              STR      r3,[r0,#0x20]
;;;5163     tmpccmr1 = TIMx->CCMR1;
00000a  6983              LDR      r3,[r0,#0x18]
;;;5164     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;5165   
;;;5166     /* Set the filter */
;;;5167     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00000e  f4234370          BIC      r3,r3,#0xf000
;;;5168     tmpccmr1 |= (TIM_ICFilter << 12);
000012  ea433202          ORR      r2,r3,r2,LSL #12
;;;5169   
;;;5170     /* Select the Polarity and set the CC2E Bit */
;;;5171     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000016  f02403a0          BIC      r3,r4,#0xa0
;;;5172     tmpccer |= (TIM_ICPolarity << 4);
00001a  ea431101          ORR      r1,r3,r1,LSL #4
;;;5173   
;;;5174     /* Write to TIMx CCMR1 and CCER registers */
;;;5175     TIMx->CCMR1 = tmpccmr1 ;
00001e  6182              STR      r2,[r0,#0x18]
;;;5176     TIMx->CCER = tmpccer;
000020  6201              STR      r1,[r0,#0x20]
;;;5177   }
000022  bd10              POP      {r4,pc}
;;;5178   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5115     */
;;;5116   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;5117                          uint32_t TIM_ICFilter)
;;;5118   {
;;;5119     uint32_t tmpccmr1 = 0;
;;;5120     uint32_t tmpccer = 0;
;;;5121   
;;;5122     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5123     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  6204              STR      r4,[r0,#0x20]
;;;5124     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5125     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5126   
;;;5127     /* Select the Input */
;;;5128     tmpccmr1 &= ~TIM_CCMR1_CC2S;
00000e  f4247440          BIC      r4,r4,#0x300
;;;5129     tmpccmr1 |= (TIM_ICSelection << 8);
000012  ea442202          ORR      r2,r4,r2,LSL #8
;;;5130   
;;;5131     /* Set the filter */
;;;5132     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4224470          BIC      r4,r2,#0xf000
;;;5133     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
00001a  f64f72ff          MOV      r2,#0xffff
00001e  ea023203          AND      r2,r2,r3,LSL #12
000022  4322              ORRS     r2,r2,r4
;;;5134   
;;;5135     /* Select the Polarity and set the CC2E Bit */
;;;5136     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
;;;5137     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000024  24a0              MOVS     r4,#0xa0
000026  f02503a0          BIC      r3,r5,#0xa0           ;5136
00002a  ea041101          AND      r1,r4,r1,LSL #4
00002e  4319              ORRS     r1,r1,r3
;;;5138   
;;;5139     /* Write to TIMx CCMR1 and CCER registers */
;;;5140     TIMx->CCMR1 = tmpccmr1 ;
000030  6182              STR      r2,[r0,#0x18]
;;;5141     TIMx->CCER = tmpccer;
000032  6201              STR      r1,[r0,#0x20]
;;;5142   }
000034  bd30              POP      {r4,r5,pc}
;;;5143   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
