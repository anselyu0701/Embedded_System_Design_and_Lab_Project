; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\port.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\port.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\port.crf ..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c]
                          THUMB

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;234    
;;;235    static void prvTaskExitError( void )
000000  4804              LDR      r0,|L1.20|
;;;236    {
;;;237    	/* A function that implements a task must not exit or attempt to return to
;;;238    	its caller as there is nothing to return to.  If a task wants to exit it
;;;239    	should instead call vTaskDelete( NULL ).
;;;240    
;;;241    	Artificially force an assert() to be triggered if configASSERT() is
;;;242    	defined, then stop here so application writers can catch the error. */
;;;243    	configASSERT( uxCriticalNesting == ~0UL );
000002  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
000006  d002              BEQ      |L1.14|
000008  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.12|
00000c  e7fe              B        |L1.12|
                  |L1.14|
;;;244    	portDISABLE_INTERRUPTS();
00000e  f7fffffe          BL       ulPortSetInterruptMask
                  |L1.18|
;;;245    	for( ;; );
000012  e7fe              B        |L1.18|
;;;246    }
;;;247    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.20|
                          DCD      ||.data||

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;215     */
;;;216    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218    	/* Simulate the stack frame as it would be created by a context switch
;;;219    	interrupt. */
;;;220    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
000002  1f03              SUBS     r3,r0,#4
;;;221    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000004  f04f7480          MOV      r4,#0x1000000
;;;222    	pxTopOfStack--;
;;;223    	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
;;;224    	pxTopOfStack--;
;;;225    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
;;;226    
;;;227    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;228    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
;;;229    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
;;;230    
;;;231    	return pxTopOfStack;
000008  601c              STR      r4,[r3,#0]
00000a  1f1b              SUBS     r3,r3,#4
00000c  6019              STR      r1,[r3,#0]
00000e  1f19              SUBS     r1,r3,#4
000010  4b02              LDR      r3,|L2.28|
000012  600b              STR      r3,[r1,#0]
000014  3914              SUBS     r1,r1,#0x14
000016  3840              SUBS     r0,r0,#0x40           ;228
000018  600a              STR      r2,[r1,#0]            ;228
;;;232    }
00001a  bd10              POP      {r4,pc}
;;;233    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.28|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;356    
;;;357    void vPortEndScheduler( void )
000000  4804              LDR      r0,|L3.20|
;;;358    {
000002  b510              PUSH     {r4,lr}
;;;359    	/* Not implemented in ports where there is nothing to return to.
;;;360    	Artificially force an assert. */
;;;361    	configASSERT( uxCriticalNesting == 1000UL );
000004  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000006  f5b07f7a          CMP      r0,#0x3e8
00000a  d002              BEQ      |L3.18|
00000c  f7fffffe          BL       ulPortSetInterruptMask
                  |L3.16|
000010  e7fe              B        |L3.16|
                  |L3.18|
;;;362    }
000012  bd10              POP      {r4,pc}
;;;363    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;376    
;;;377    void vPortEnterCritical( void )
000000  b510              PUSH     {r4,lr}
;;;378    {
;;;379    	portDISABLE_INTERRUPTS();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;380    	uxCriticalNesting++;
000006  480a              LDR      r0,|L4.48|
000008  6841              LDR      r1,[r0,#4]  ; uxCriticalNesting
00000a  1c49              ADDS     r1,r1,#1
;;;381    	__dsb( portSY_FULL_READ_WRITE );
00000c  6041              STR      r1,[r0,#4]  ; uxCriticalNesting
00000e  f3bf8f4f          DSB      
;;;382    	__isb( portSY_FULL_READ_WRITE );
000012  f3bf8f6f          ISB      
;;;383    
;;;384    	/* This is not the interrupt safe version of the enter critical function so
;;;385    	assert() if it is being called from an interrupt context.  Only API
;;;386    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;387    	the critical nesting count is 1 to protect against recursive calls if the
;;;388    	assert function also uses a critical section. */
;;;389    	if( uxCriticalNesting == 1 )
000016  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000018  2801              CMP      r0,#1
00001a  d107              BNE      |L4.44|
;;;390    	{
;;;391    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
00001c  4805              LDR      r0,|L4.52|
00001e  6800              LDR      r0,[r0,#0]
000020  f0100fff          TST      r0,#0xff
000024  d002              BEQ      |L4.44|
000026  f7fffffe          BL       ulPortSetInterruptMask
                  |L4.42|
00002a  e7fe              B        |L4.42|
                  |L4.44|
;;;392    	}
;;;393    }
00002c  bd10              POP      {r4,pc}
;;;394    /*-----------------------------------------------------------*/
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      ||.data||
                  |L4.52|
                          DCD      0xe000ed04

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;395    
;;;396    void vPortExitCritical( void )
000000  4907              LDR      r1,|L5.32|
;;;397    {
000002  b510              PUSH     {r4,lr}
000004  6848              LDR      r0,[r1,#4]  ; uxCriticalNesting
000006  b130              CBZ      r0,|L5.22|
000008  1e40              SUBS     r0,r0,#1
;;;398    	configASSERT( uxCriticalNesting );
;;;399    	uxCriticalNesting--;
;;;400    	if( uxCriticalNesting == 0 )
00000a  6048              STR      r0,[r1,#4]  ; uxCriticalNesting
00000c  d106              BNE      |L5.28|
;;;401    	{
;;;402    		portENABLE_INTERRUPTS();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      vPortClearInterruptMask
                  |L5.22|
000016  f7fffffe          BL       ulPortSetInterruptMask
                  |L5.26|
00001a  e7fe              B        |L5.26|
                  |L5.28|
;;;403    	}
;;;404    }
00001c  bd10              POP      {r4,pc}
;;;405    /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      ||.data||

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;620    
;;;621    	void vPortSetupTimerInterrupt( void )
000000  4806              LDR      r0,|L6.28|
;;;622    	{
;;;623    		/* Calculate the constants required to configure the tick interrupt. */
;;;624    		#if configUSE_TICKLESS_IDLE == 1
;;;625    		{
;;;626    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;627    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;628    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;629    		}
;;;630    		#endif /* configUSE_TICKLESS_IDLE */
;;;631    
;;;632    		/* Configure SysTick to interrupt at the requested rate. */
;;;633    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
000002  f44f717a          MOV      r1,#0x3e8
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  fbb0f1f1          UDIV     r1,r0,r1
00000c  f04f20e0          MOV      r0,#0xe000e000
000010  1e49              SUBS     r1,r1,#1
000012  6141              STR      r1,[r0,#0x14]
;;;634    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
000014  2107              MOVS     r1,#7
000016  6101              STR      r1,[r0,#0x10]
;;;635    	}
000018  4770              BX       lr
;;;636    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      SystemCoreClock

                          AREA ||i.vPortValidateInterruptPriority||, CODE, READONLY, ALIGN=2

                  vPortValidateInterruptPriority PROC
;;;670    
;;;671    	void vPortValidateInterruptPriority( void )
000000  b510              PUSH     {r4,lr}
;;;672    	{
;;;673    	uint32_t ulCurrentInterrupt;
;;;674    	uint8_t ucCurrentPriority;
;;;675    
;;;676    		/* Obtain the number of the currently executing interrupt. */
;;;677    		ulCurrentInterrupt = vPortGetIPSR();
000002  f7fffffe          BL       vPortGetIPSR
;;;678    
;;;679    		/* Is the interrupt number a user defined interrupt? */
;;;680    		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
;;;681    		{
;;;682    			/* Look up the interrupt's priority. */
;;;683    			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
;;;684    
;;;685    			/* The following assertion will fail if a service routine (ISR) for
;;;686    			an interrupt that has been assigned a priority above
;;;687    			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
;;;688    			function.  ISR safe FreeRTOS API functions must *only* be called
;;;689    			from interrupts that have been assigned a priority at or below
;;;690    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;691    
;;;692    			Numerically low interrupt priority numbers represent logically high
;;;693    			interrupt priorities, therefore the priority of the interrupt must
;;;694    			be set to a value equal to or numerically *higher* than
;;;695    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;696    
;;;697    			Interrupts that	use the FreeRTOS API must not be left at their
;;;698    			default priority of	zero as that is the highest possible priority,
;;;699    			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
;;;700    			and	therefore also guaranteed to be invalid.
;;;701    
;;;702    			FreeRTOS maintains separate thread and ISR API functions to ensure
;;;703    			interrupt entry is as fast and simple as possible.
;;;704    
;;;705    			The following links provide detailed information:
;;;706    			http://www.freertos.org/RTOS-Cortex-M3-M4.html
;;;707    			http://www.freertos.org/FAQHelp.html */
;;;708    			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
000006  490c              LDR      r1,|L7.56|
000008  2810              CMP      r0,#0x10              ;680
00000a  d309              BCC      |L7.32|
00000c  f10020e0          ADD      r0,r0,#0xe000e000     ;680
000010  f89003f0          LDRB     r0,[r0,#0x3f0]        ;683
000014  780a              LDRB     r2,[r1,#0]  ; ucMaxSysCallPriority
000016  4290              CMP      r0,r2
000018  d202              BCS      |L7.32|
00001a  f7fffffe          BL       ulPortSetInterruptMask
                  |L7.30|
00001e  e7fe              B        |L7.30|
                  |L7.32|
;;;709    		}
;;;710    
;;;711    		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
;;;712    		that define each interrupt's priority to be split between bits that
;;;713    		define the interrupt's pre-emption priority bits and bits that define
;;;714    		the interrupt's sub-priority.  For simplicity all bits must be defined
;;;715    		to be pre-emption priority bits.  The following assertion will fail if
;;;716    		this is not the case (if some bits represent a sub-priority).
;;;717    
;;;718    		If the application only uses CMSIS libraries for interrupt
;;;719    		configuration then the correct setting can be achieved on all Cortex-M
;;;720    		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
;;;721    		scheduler.  Note however that some vendor specific peripheral libraries
;;;722    		assume a non-zero priority group setting, in which cases using a value
;;;723    		of zero will result in unpredicable behaviour. */
;;;724    		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
000020  4806              LDR      r0,|L7.60|
000022  6800              LDR      r0,[r0,#0]
000024  6889              LDR      r1,[r1,#8]  ; ulMaxPRIGROUPValue
000026  f40060e0          AND      r0,r0,#0x700
00002a  4288              CMP      r0,r1
00002c  d902              BLS      |L7.52|
00002e  f7fffffe          BL       ulPortSetInterruptMask
                  |L7.50|
000032  e7fe              B        |L7.50|
                  |L7.52|
;;;725    	}
000034  bd10              POP      {r4,pc}
;;;726    
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      ||.data||
                  |L7.60|
                          DCD      0xe000ed0c

                          AREA ||i.vPortYield||, CODE, READONLY, ALIGN=2

                  vPortYield PROC
;;;364    
;;;365    void vPortYield( void )
000000  4904              LDR      r1,|L8.20|
;;;366    {
;;;367    	/* Set a PendSV to request a context switch. */
;;;368    	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000002  f04f5080          MOV      r0,#0x10000000
000006  6008              STR      r0,[r1,#0]
;;;369    
;;;370    	/* Barriers are normally not required but do ensure the code is completely
;;;371    	within the specified behaviour for the architecture. */
;;;372    	__dsb( portSY_FULL_READ_WRITE );
000008  f3bf8f4f          DSB      
;;;373    	__isb( portSY_FULL_READ_WRITE );
00000c  f3bf8f6f          ISB      
;;;374    }
000010  4770              BX       lr
;;;375    /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0xe000ed04

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;291     */
;;;292    BaseType_t xPortStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;293    {
;;;294    	#if( configASSERT_DEFINED == 1 )
;;;295    	{
;;;296    		volatile uint32_t ulOriginalPriority;
;;;297    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
000002  4919              LDR      r1,|L9.104|
;;;298    		volatile uint8_t ucMaxPriorityValue;
;;;299    
;;;300    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;301    		functions can be called.  ISR safe functions are those that end in
;;;302    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;303    		ensure interrupt entry is as fast and simple as possible.
;;;304    
;;;305    		Save the interrupt priority value that is about to be clobbered. */
;;;306    		ulOriginalPriority = *pucFirstUserPriorityRegister;
000004  7808              LDRB     r0,[r1,#0]
;;;307    
;;;308    		/* Determine the number of priority bits available.  First write to all
;;;309    		possible bits. */
;;;310    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
000006  9001              STR      r0,[sp,#4]
000008  20ff              MOVS     r0,#0xff
00000a  7008              STRB     r0,[r1,#0]
;;;311    
;;;312    		/* Read the value back to see how many bits stuck. */
;;;313    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
00000c  7808              LDRB     r0,[r1,#0]
00000e  f88d0000          STRB     r0,[sp,#0]
;;;314    
;;;315    		/* Use the same mask on the maximum system call priority. */
;;;316    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
000012  f89d0000          LDRB     r0,[sp,#0]
000016  4a15              LDR      r2,|L9.108|
000018  f0000050          AND      r0,r0,#0x50
00001c  7010              STRB     r0,[r2,#0]
;;;317    
;;;318    		/* Calculate the maximum acceptable priority group value for the number
;;;319    		of bits read back. */
;;;320    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
00001e  2007              MOVS     r0,#7
000020  6090              STR      r0,[r2,#8]            ;293  ; ulMaxPRIGROUPValue
000022  e005              B        |L9.48|
                  |L9.36|
;;;321    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;322    		{
;;;323    			ulMaxPRIGROUPValue--;
;;;324    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
000024  f89d3000          LDRB     r3,[sp,#0]
000028  005b              LSLS     r3,r3,#1
00002a  f88d3000          STRB     r3,[sp,#0]
00002e  1e40              SUBS     r0,r0,#1
                  |L9.48|
000030  f89d3000          LDRB     r3,[sp,#0]            ;321
000034  061b              LSLS     r3,r3,#24             ;321
000036  d4f5              BMI      |L9.36|
;;;325    		}
;;;326    
;;;327    		/* Shift the priority group value back to its position within the AIRCR
;;;328    		register. */
;;;329    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
000038  0200              LSLS     r0,r0,#8
;;;330    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
00003a  f40060e0          AND      r0,r0,#0x700
;;;331    
;;;332    		/* Restore the clobbered interrupt priority register to its original
;;;333    		value. */
;;;334    		*pucFirstUserPriorityRegister = ulOriginalPriority;
00003e  6090              STR      r0,[r2,#8]  ; ulMaxPRIGROUPValue
000040  9801              LDR      r0,[sp,#4]
000042  7008              STRB     r0,[r1,#0]
;;;335    	}
;;;336    	#endif /* conifgASSERT_DEFINED */
;;;337    
;;;338    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;339    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000044  480a              LDR      r0,|L9.112|
000046  6801              LDR      r1,[r0,#0]
000048  f4410170          ORR      r1,r1,#0xf00000
00004c  6001              STR      r1,[r0,#0]
;;;340    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00004e  6801              LDR      r1,[r0,#0]
000050  f0414170          ORR      r1,r1,#0xf0000000
000054  6001              STR      r1,[r0,#0]
;;;341    
;;;342    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;343    	here already. */
;;;344    	vPortSetupTimerInterrupt();
000056  f7fffffe          BL       vPortSetupTimerInterrupt
;;;345    
;;;346    	/* Initialise the critical nesting count ready for the first task. */
;;;347    	uxCriticalNesting = 0;
00005a  2000              MOVS     r0,#0
;;;348    
;;;349    	/* Start the first task. */
;;;350    	prvStartFirstTask();
00005c  6050              STR      r0,[r2,#4]  ; uxCriticalNesting
00005e  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;351    
;;;352    	/* Should not get here! */
;;;353    	return 0;
000062  2000              MOVS     r0,#0
;;;354    }
000064  bd1c              POP      {r2-r4,pc}
;;;355    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      0xe000e400
                  |L9.108|
                          DCD      ||.data||
                  |L9.112|
                          DCD      0xe000ed20

                          AREA ||i.xPortSysTickHandler||, CODE, READONLY, ALIGN=2

                  xPortSysTickHandler PROC
;;;441    
;;;442    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;443    {
;;;444    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;445    	executes all interrupts must be unmasked.  There is therefore no need to
;;;446    	save and then restore the interrupt mask value as its value is already
;;;447    	known. */
;;;448    	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;449    	{
;;;450    		/* Increment the RTOS tick. */
;;;451    		if( xTaskIncrementTick() != pdFALSE )
000006  f7fffffe          BL       xTaskIncrementTick
00000a  b118              CBZ      r0,|L10.20|
;;;452    		{
;;;453    			/* A context switch is required.  Context switching is performed in
;;;454    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;455    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
00000c  4904              LDR      r1,|L10.32|
00000e  f04f5080          MOV      r0,#0x10000000
000012  6008              STR      r0,[r1,#0]
                  |L10.20|
;;;456    		}
;;;457    	}
;;;458    	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
000014  e8bd4010          POP      {r4,lr}
000018  2000              MOVS     r0,#0
00001a  f7ffbffe          B.W      vPortClearInterruptMask
;;;459    }
;;;460    /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0xe000ed04

                          AREA ||.data||, DATA, ALIGN=2

                  ucMaxSysCallPriority
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  uxCriticalNesting
                          DCD      0xaaaaaaaa
                  ulMaxPRIGROUPValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM3\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 249
|SVC_Handler| PROC
#line 250

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 isb
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 266
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 267

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]

 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 407
|PendSV_Handler| PROC
#line 408

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #( 5 << (8 - 4) )
 msr basepri, r0
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 isb
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |ulPortSetInterruptMask|
#line 640
|ulPortSetInterruptMask| PROC
#line 641

 PRESERVE8

 mrs r0, basepri
 mov r1, #( 5 << (8 - 4) )
 msr basepri, r1
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortClearInterruptMask|
#line 651
|vPortClearInterruptMask| PROC
#line 652

 PRESERVE8

 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 660
|vPortGetIPSR| PROC
#line 661

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
