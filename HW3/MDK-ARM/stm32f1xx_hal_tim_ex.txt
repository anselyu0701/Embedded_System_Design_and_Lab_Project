; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\stm32f1xx_hal_tim_ex.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\stm32f1xx_hal_tim_ex.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\stm32f1xx_hal_tim_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1739     */
;;;1740   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1741   {
;;;1742     /* Prevent unused argument(s) compilation warning */
;;;1743     UNUSED(htim);
;;;1744     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1745               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1746      */
;;;1747   }
;;;1748   
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutationCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutationCallback PROC
;;;1725     */
;;;1726   __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1727   {
;;;1728     /* Prevent unused argument(s) compilation warning */
;;;1729     UNUSED(htim);
;;;1730     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1731               the HAL_TIMEx_CommutationCallback could be implemented in the user file
;;;1732      */
;;;1733   }
;;;1734   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1624     */
;;;1625   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
000000  b530              PUSH     {r4,r5,lr}
;;;1626                                                   TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
;;;1627   {
;;;1628     /* Check the parameters */
;;;1629     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1630     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1631     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1632     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1633     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1634     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1635     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1636     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1637   
;;;1638     /* Process Locked */
;;;1639     __HAL_LOCK(htim);
000002  f8902038          LDRB     r2,[r0,#0x38]
000006  2a01              CMP      r2,#1
000008  d019              BEQ      |L3.62|
00000a  2201              MOVS     r2,#1
00000c  f8002f38          STRB     r2,[r0,#0x38]!
;;;1640   
;;;1641     htim->State = HAL_TIM_STATE_BUSY;
000010  2302              MOVS     r3,#2
000012  7043              STRB     r3,[r0,#1]
000014  e9d13400          LDRD     r3,r4,[r1,#0]
;;;1642   
;;;1643     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1644        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1645     htim->Instance->BDTR = (uint32_t)sBreakDeadTimeConfig->OffStateRunMode  |
000018  4323              ORRS     r3,r3,r4
00001a  e9d14502          LDRD     r4,r5,[r1,#8]
00001e  432c              ORRS     r4,r4,r5
000020  4323              ORRS     r3,r3,r4
000022  690c              LDR      r4,[r1,#0x10]
000024  4323              ORRS     r3,r3,r4
000026  694c              LDR      r4,[r1,#0x14]
000028  6989              LDR      r1,[r1,#0x18]
00002a  4323              ORRS     r3,r3,r4
00002c  430b              ORRS     r3,r3,r1
00002e  f8501c38          LDR      r1,[r0,#-0x38]
000032  644b              STR      r3,[r1,#0x44]
;;;1646                                      sBreakDeadTimeConfig->OffStateIDLEMode |
;;;1647                                      sBreakDeadTimeConfig->LockLevel        |
;;;1648                                      sBreakDeadTimeConfig->DeadTime         |
;;;1649                                      sBreakDeadTimeConfig->BreakState       |
;;;1650                                      sBreakDeadTimeConfig->BreakPolarity    |
;;;1651                                      sBreakDeadTimeConfig->AutomaticOutput;
;;;1652   
;;;1653   
;;;1654     htim->State = HAL_TIM_STATE_READY;
000034  7042              STRB     r2,[r0,#1]
;;;1655   
;;;1656     __HAL_UNLOCK(htim);
000036  2100              MOVS     r1,#0
000038  7001              STRB     r1,[r0,#0]
;;;1657   
;;;1658     return HAL_OK;
00003a  4608              MOV      r0,r1
;;;1659   }
00003c  bd30              POP      {r4,r5,pc}
                  |L3.62|
00003e  2002              MOVS     r0,#2                 ;1639
000040  bd30              POP      {r4,r5,pc}
;;;1660   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent PROC
;;;1478     */
;;;1479   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1480   {
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1483     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1484   
;;;1485     __HAL_LOCK(htim);
000002  f8903038          LDRB     r3,[r0,#0x38]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L4.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L4.36|
;;;1486   
;;;1487     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L4.36|
;;;1488         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L4.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L4.36|
00001e  e00a              B        |L4.54|
                  |L4.32|
000020  2002              MOVS     r0,#2                 ;1485
;;;1489     {
;;;1490       /* Select the Input trigger */
;;;1491       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1492       htim->Instance->SMCR |= InputTrigger;
;;;1493     }
;;;1494   
;;;1495     /* Select the Capture Compare preload feature */
;;;1496     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1497     /* Select the Commutation event source */
;;;1498     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1499     htim->Instance->CR2 |= CommutationSource;
;;;1500   
;;;1501     __HAL_UNLOCK(htim);
;;;1502   
;;;1503     return HAL_OK;
;;;1504   }
000022  bd10              POP      {r4,pc}
                  |L4.36|
000024  6803              LDR      r3,[r0,#0]            ;1491
000026  689c              LDR      r4,[r3,#8]            ;1491
000028  f0240470          BIC      r4,r4,#0x70           ;1491
00002c  609c              STR      r4,[r3,#8]            ;1491
00002e  6803              LDR      r3,[r0,#0]            ;1492
000030  689c              LDR      r4,[r3,#8]            ;1492
000032  430c              ORRS     r4,r4,r1              ;1492
000034  609c              STR      r4,[r3,#8]            ;1492
                  |L4.54|
000036  6801              LDR      r1,[r0,#0]            ;1496
000038  684b              LDR      r3,[r1,#4]            ;1496
00003a  f0430301          ORR      r3,r3,#1              ;1496
00003e  604b              STR      r3,[r1,#4]            ;1496
000040  6801              LDR      r1,[r0,#0]            ;1498
000042  684b              LDR      r3,[r1,#4]            ;1498
000044  f0230304          BIC      r3,r3,#4              ;1498
000048  604b              STR      r3,[r1,#4]            ;1498
00004a  6801              LDR      r1,[r0,#0]            ;1499
00004c  684b              LDR      r3,[r1,#4]            ;1499
00004e  4313              ORRS     r3,r3,r2              ;1499
000050  604b              STR      r3,[r1,#4]            ;1499
000052  2100              MOVS     r1,#0                 ;1501
000054  f8801038          STRB     r1,[r0,#0x38]         ;1501
000058  4608              MOV      r0,r1                 ;1503
00005a  bd10              POP      {r4,pc}
;;;1505   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutationEvent_DMA PROC
;;;1580     */
;;;1581   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1582   {
;;;1583     /* Check the parameters */
;;;1584     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1585     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1586   
;;;1587     __HAL_LOCK(htim);
000002  f8903038          LDRB     r3,[r0,#0x38]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L5.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L5.36|
;;;1588   
;;;1589     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L5.36|
;;;1590         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L5.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L5.36|
00001e  e00a              B        |L5.54|
                  |L5.32|
000020  2002              MOVS     r0,#2                 ;1587
;;;1591     {
;;;1592       /* Select the Input trigger */
;;;1593       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1594       htim->Instance->SMCR |= InputTrigger;
;;;1595     }
;;;1596   
;;;1597     /* Select the Capture Compare preload feature */
;;;1598     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1599     /* Select the Commutation event source */
;;;1600     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1601     htim->Instance->CR2 |= CommutationSource;
;;;1602   
;;;1603     /* Enable the Commutation DMA Request */
;;;1604     /* Set the DMA Commutation Callback */
;;;1605     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;1606     /* Set the DMA error callback */
;;;1607     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
;;;1608   
;;;1609     /* Enable the Commutation DMA Request */
;;;1610     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1611   
;;;1612     __HAL_UNLOCK(htim);
;;;1613   
;;;1614     return HAL_OK;
;;;1615   }
000022  bd10              POP      {r4,pc}
                  |L5.36|
000024  6803              LDR      r3,[r0,#0]            ;1593
000026  689c              LDR      r4,[r3,#8]            ;1593
000028  f0240470          BIC      r4,r4,#0x70           ;1593
00002c  609c              STR      r4,[r3,#8]            ;1593
00002e  6803              LDR      r3,[r0,#0]            ;1594
000030  689c              LDR      r4,[r3,#8]            ;1594
000032  430c              ORRS     r4,r4,r1              ;1594
000034  609c              STR      r4,[r3,#8]            ;1594
                  |L5.54|
000036  6801              LDR      r1,[r0,#0]            ;1598
000038  684b              LDR      r3,[r1,#4]            ;1598
00003a  f0430301          ORR      r3,r3,#1              ;1598
00003e  604b              STR      r3,[r1,#4]            ;1598
000040  6801              LDR      r1,[r0,#0]            ;1600
000042  684b              LDR      r3,[r1,#4]            ;1600
000044  f0230304          BIC      r3,r3,#4              ;1600
000048  604b              STR      r3,[r1,#4]            ;1600
00004a  6801              LDR      r1,[r0,#0]            ;1601
00004c  684b              LDR      r3,[r1,#4]            ;1601
00004e  4313              ORRS     r3,r3,r2              ;1601
000050  604b              STR      r3,[r1,#4]            ;1601
000052  6b02              LDR      r2,[r0,#0x30]         ;1605
000054  4907              LDR      r1,|L5.116|
000056  6291              STR      r1,[r2,#0x28]         ;1607
000058  6b02              LDR      r2,[r0,#0x30]         ;1607
00005a  4907              LDR      r1,|L5.120|
00005c  6311              STR      r1,[r2,#0x30]         ;1610
00005e  6801              LDR      r1,[r0,#0]            ;1610
000060  68ca              LDR      r2,[r1,#0xc]          ;1610
000062  f4425200          ORR      r2,r2,#0x2000         ;1610
000066  60ca              STR      r2,[r1,#0xc]          ;1610
000068  2100              MOVS     r1,#0                 ;1612
00006a  f8801038          STRB     r1,[r0,#0x38]         ;1612
00006e  4608              MOV      r0,r1                 ;1614
000070  bd10              POP      {r4,pc}
;;;1616   
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      TIMEx_DMACommutationCplt
                  |L5.120|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent_IT PROC
;;;1527     */
;;;1528   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1529   {
;;;1530     /* Check the parameters */
;;;1531     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1532     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1533   
;;;1534     __HAL_LOCK(htim);
000002  f8903038          LDRB     r3,[r0,#0x38]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L6.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L6.36|
;;;1535   
;;;1536     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L6.36|
;;;1537         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L6.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L6.36|
00001e  e00a              B        |L6.54|
                  |L6.32|
000020  2002              MOVS     r0,#2                 ;1534
;;;1538     {
;;;1539       /* Select the Input trigger */
;;;1540       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1541       htim->Instance->SMCR |= InputTrigger;
;;;1542     }
;;;1543   
;;;1544     /* Select the Capture Compare preload feature */
;;;1545     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1546     /* Select the Commutation event source */
;;;1547     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1548     htim->Instance->CR2 |= CommutationSource;
;;;1549   
;;;1550     /* Enable the Commutation Interrupt Request */
;;;1551     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1552   
;;;1553     __HAL_UNLOCK(htim);
;;;1554   
;;;1555     return HAL_OK;
;;;1556   }
000022  bd10              POP      {r4,pc}
                  |L6.36|
000024  6803              LDR      r3,[r0,#0]            ;1540
000026  689c              LDR      r4,[r3,#8]            ;1540
000028  f0240470          BIC      r4,r4,#0x70           ;1540
00002c  609c              STR      r4,[r3,#8]            ;1540
00002e  6803              LDR      r3,[r0,#0]            ;1541
000030  689c              LDR      r4,[r3,#8]            ;1541
000032  430c              ORRS     r4,r4,r1              ;1541
000034  609c              STR      r4,[r3,#8]            ;1541
                  |L6.54|
000036  6801              LDR      r1,[r0,#0]            ;1545
000038  684b              LDR      r3,[r1,#4]            ;1545
00003a  f0430301          ORR      r3,r3,#1              ;1545
00003e  604b              STR      r3,[r1,#4]            ;1545
000040  6801              LDR      r1,[r0,#0]            ;1547
000042  684b              LDR      r3,[r1,#4]            ;1547
000044  f0230304          BIC      r3,r3,#4              ;1547
000048  604b              STR      r3,[r1,#4]            ;1547
00004a  6801              LDR      r1,[r0,#0]            ;1548
00004c  684b              LDR      r3,[r1,#4]            ;1548
00004e  4313              ORRS     r3,r3,r2              ;1548
000050  604b              STR      r3,[r1,#4]            ;1548
000052  6801              LDR      r1,[r0,#0]            ;1551
000054  68ca              LDR      r2,[r1,#0xc]          ;1551
000056  f0420220          ORR      r2,r2,#0x20           ;1551
00005a  60ca              STR      r2,[r1,#0xc]          ;1551
00005c  2100              MOVS     r1,#0                 ;1553
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1553
000062  4608              MOV      r0,r1                 ;1555
000064  bd10              POP      {r4,pc}
;;;1557   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;244      */
;;;245    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247      /* Check the parameters */
;;;248      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;249    
;;;250      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;251    
;;;252      /* Disable the TIM Peripheral Clock */
;;;253      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L7.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L7.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L7.38|
;;;254    
;;;255      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;256      HAL_TIMEx_HallSensor_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;257    
;;;258      /* Change TIM state */
;;;259      htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;260    
;;;261      /* Release Lock */
;;;262      __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;263    
;;;264      return HAL_OK;
;;;265    }
000036  bd10              POP      {r4,pc}
;;;266    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;1790     */
;;;1791   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;1792   {
;;;1793     return htim->State;
;;;1794   }
000004  4770              BX       lr
;;;1795   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Init PROC
;;;166      */
;;;167    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  b088              SUB      sp,sp,#0x20
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d004              BEQ      |L9.20|
;;;169      TIM_OC_InitTypeDef OC_Config;
;;;170    
;;;171      /* Check the TIM handle allocation */
;;;172      if(htim == NULL)
;;;173      {
;;;174        return HAL_ERROR;
;;;175      }
;;;176    
;;;177      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;178      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;179      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;180      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;181      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;182      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;183    
;;;184      if(htim->State == HAL_TIM_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  2500              MOVS     r5,#0
000010  b118              CBZ      r0,|L9.26|
000012  e007              B        |L9.36|
                  |L9.20|
000014  2001              MOVS     r0,#1                 ;174
                  |L9.22|
;;;185      {
;;;186        /* Allocate lock resource and initialize it */
;;;187        htim->Lock = HAL_UNLOCKED;
;;;188        
;;;189        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;190        HAL_TIMEx_HallSensor_MspInit(htim);
;;;191      }
;;;192    
;;;193      /* Set the TIM state */
;;;194      htim->State= HAL_TIM_STATE_BUSY;
;;;195    
;;;196      /* Configure the Time base in the Encoder Mode */
;;;197      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;198    
;;;199      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;200      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;201    
;;;202      /* Reset the IC1PSC Bits */
;;;203      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;204      /* Set the IC1PSC value */
;;;205      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;206    
;;;207      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;208      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;209    
;;;210      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;211      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;212      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;213    
;;;214      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
;;;215      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;216      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;217    
;;;218      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;219      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;220      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;221      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;222      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;223      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;224      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;225      OC_Config.Pulse = sConfig->Commutation_Delay;
;;;226    
;;;227      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;228    
;;;229      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;230        register to 101 */
;;;231      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;232      htim->Instance->CR2 |= TIM_TRGO_OC2REF;
;;;233    
;;;234      /* Initialize the TIM state*/
;;;235      htim->State= HAL_TIM_STATE_READY;
;;;236    
;;;237      return HAL_OK;
;;;238    }
000016  b008              ADD      sp,sp,#0x20
000018  bd70              POP      {r4-r6,pc}
                  |L9.26|
00001a  f8845038          STRB     r5,[r4,#0x38]         ;187
00001e  4620              MOV      r0,r4                 ;190
000020  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
                  |L9.36|
000024  2002              MOVS     r0,#2                 ;194
000026  f8840039          STRB     r0,[r4,#0x39]         ;194
00002a  1d21              ADDS     r1,r4,#4              ;197
00002c  6820              LDR      r0,[r4,#0]            ;197
00002e  f7fffffe          BL       TIM_Base_SetConfig
000032  68b3              LDR      r3,[r6,#8]            ;200
000034  6831              LDR      r1,[r6,#0]            ;200
000036  2203              MOVS     r2,#3                 ;200
000038  6820              LDR      r0,[r4,#0]            ;200
00003a  f7fffffe          BL       TIM_TI1_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;203
000040  6981              LDR      r1,[r0,#0x18]         ;203
000042  f021010c          BIC      r1,r1,#0xc            ;203
000046  6181              STR      r1,[r0,#0x18]         ;203
000048  6820              LDR      r0,[r4,#0]            ;205
00004a  6981              LDR      r1,[r0,#0x18]         ;205
00004c  6872              LDR      r2,[r6,#4]            ;205
00004e  4311              ORRS     r1,r1,r2              ;205
000050  6181              STR      r1,[r0,#0x18]         ;205
000052  6820              LDR      r0,[r4,#0]            ;208
000054  6841              LDR      r1,[r0,#4]            ;208
000056  f0410180          ORR      r1,r1,#0x80           ;208
00005a  6041              STR      r1,[r0,#4]            ;208
00005c  6820              LDR      r0,[r4,#0]            ;211
00005e  6881              LDR      r1,[r0,#8]            ;211
000060  f0210170          BIC      r1,r1,#0x70           ;211
000064  6081              STR      r1,[r0,#8]            ;211
000066  6820              LDR      r0,[r4,#0]            ;212
000068  6881              LDR      r1,[r0,#8]            ;212
00006a  f0410140          ORR      r1,r1,#0x40           ;212
00006e  6081              STR      r1,[r0,#8]            ;212
000070  6820              LDR      r0,[r4,#0]            ;215
000072  6881              LDR      r1,[r0,#8]            ;215
000074  f0210107          BIC      r1,r1,#7              ;215
000078  6081              STR      r1,[r0,#8]            ;215
00007a  6820              LDR      r0,[r4,#0]            ;216
00007c  6881              LDR      r1,[r0,#8]            ;216
00007e  f0410104          ORR      r1,r1,#4              ;216
000082  6081              STR      r1,[r0,#8]            ;216
000084  2070              MOVS     r0,#0x70              ;221
000086  9505              STR      r5,[sp,#0x14]         ;222
000088  9504              STR      r5,[sp,#0x10]         ;220
00008a  9506              STR      r5,[sp,#0x18]         ;223
00008c  9503              STR      r5,[sp,#0xc]          ;224
00008e  9502              STR      r5,[sp,#8]            ;225
000090  9000              STR      r0,[sp,#0]            ;225
000092  68f0              LDR      r0,[r6,#0xc]          ;225
000094  9001              STR      r0,[sp,#4]            ;227
000096  4669              MOV      r1,sp                 ;227
000098  6820              LDR      r0,[r4,#0]            ;227
00009a  f7fffffe          BL       TIM_OC2_SetConfig
00009e  6820              LDR      r0,[r4,#0]            ;231
0000a0  6841              LDR      r1,[r0,#4]            ;231
0000a2  f0210170          BIC      r1,r1,#0x70           ;231
0000a6  6041              STR      r1,[r0,#4]            ;231
0000a8  6820              LDR      r0,[r4,#0]            ;232
0000aa  6841              LDR      r1,[r0,#4]            ;232
0000ac  f0410150          ORR      r1,r1,#0x50           ;232
0000b0  6041              STR      r1,[r0,#4]            ;232
0000b2  2001              MOVS     r0,#1                 ;235
0000b4  f8840039          STRB     r0,[r4,#0x39]         ;235
0000b8  2000              MOVS     r0,#0                 ;237
0000ba  e7ac              B        |L9.22|
;;;239    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;285      */
;;;286    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;287    {
;;;288      /* Prevent unused argument(s) compilation warning */
;;;289      UNUSED(htim);
;;;290      /* NOTE : This function Should not be modified, when the callback is needed,
;;;291                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;292       */
;;;293    }
;;;294    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;271      */
;;;272    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;273    {
;;;274      /* Prevent unused argument(s) compilation warning */
;;;275      UNUSED(htim);
;;;276      /* NOTE : This function Should not be modified, when the callback is needed,
;;;277                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;278       */
;;;279    }
;;;280    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;299      */
;;;300    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;301    {
000002  4604              MOV      r4,r0
;;;302      /* Check the parameters */
;;;303      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;304    
;;;305      /* Enable the Input Capture channel 1
;;;306        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;307      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;308    
;;;309      /* Enable the Peripheral */
;;;310      __HAL_TIM_ENABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0410101          ORR      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;311    
;;;312      /* Return function status */
;;;313      return HAL_OK;
000018  2000              MOVS     r0,#0
;;;314    }
00001a  bd10              POP      {r4,pc}
;;;315    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;393    {
000002  4604              MOV      r4,r0
;;;394      /* Check the parameters */
;;;395      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;396    
;;;397       if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4615              MOV      r5,r2                 ;393
00000a  460e              MOV      r6,r1                 ;393
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L13.28|
;;;398      {
;;;399         return HAL_BUSY;
;;;400      }
;;;401      else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L13.36|
;;;402      {
;;;403        if(((uint32_t)pData == 0 ) && (Length > 0))
000018  b90e              CBNZ     r6,|L13.30|
00001a  b105              CBZ      r5,|L13.30|
                  |L13.28|
;;;404        {
;;;405          return HAL_ERROR;
;;;406        }
;;;407        else
;;;408        {
;;;409          htim->State = HAL_TIM_STATE_BUSY;
;;;410        }
;;;411      }
;;;412      /* Enable the Input Capture channel 1
;;;413        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;414      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;415    
;;;416      /* Set the DMA Input Capture 1 Callback */
;;;417      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;418      /* Set the DMA error callback */
;;;419      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;420    
;;;421      /* Enable the DMA channel for Capture 1*/
;;;422      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;423    
;;;424      /* Enable the capture compare 1 Interrupt */
;;;425      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;426    
;;;427      /* Enable the Peripheral */
;;;428      __HAL_TIM_ENABLE(htim);
;;;429    
;;;430      /* Return function status */
;;;431      return HAL_OK;
;;;432    }
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  2002              MOVS     r0,#2                 ;409
000020  f8840039          STRB     r0,[r4,#0x39]         ;409
                  |L13.36|
000024  2201              MOVS     r2,#1                 ;414
000026  2100              MOVS     r1,#0                 ;414
000028  6820              LDR      r0,[r4,#0]            ;414
00002a  f7fffffe          BL       TIM_CCxChannelCmd
00002e  6a21              LDR      r1,[r4,#0x20]         ;417
000030  480b              LDR      r0,|L13.96|
000032  462b              MOV      r3,r5                 ;422
000034  6288              STR      r0,[r1,#0x28]         ;419
000036  6a21              LDR      r1,[r4,#0x20]         ;419
000038  480a              LDR      r0,|L13.100|
00003a  4632              MOV      r2,r6                 ;422
00003c  6308              STR      r0,[r1,#0x30]         ;422
00003e  6821              LDR      r1,[r4,#0]            ;422
000040  6a20              LDR      r0,[r4,#0x20]         ;422
000042  3134              ADDS     r1,r1,#0x34           ;422
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;425
00004a  68c1              LDR      r1,[r0,#0xc]          ;425
00004c  f4417100          ORR      r1,r1,#0x200          ;425
000050  60c1              STR      r1,[r0,#0xc]          ;425
000052  6820              LDR      r0,[r4,#0]            ;428
000054  6801              LDR      r1,[r0,#0]            ;428
000056  f0410101          ORR      r1,r1,#1              ;428
00005a  6001              STR      r1,[r0,#0]            ;428
00005c  2000              MOVS     r0,#0                 ;431
00005e  bd70              POP      {r4-r6,pc}
;;;433    
                          ENDP

                  |L13.96|
                          DCD      TIM_DMACaptureCplt
                  |L13.100|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;341      */
;;;342    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;343    {
000002  4604              MOV      r4,r0
;;;344      /* Check the parameters */
;;;345      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;346    
;;;347      /* Enable the capture compare Interrupts 1 event */
;;;348      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;349    
;;;350      /* Enable the Input Capture channel 1
;;;351        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;352      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;353    
;;;354      /* Enable the Peripheral */
;;;355      __HAL_TIM_ENABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410101          ORR      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
;;;356    
;;;357      /* Return function status */
;;;358      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;359    }
000024  bd10              POP      {r4,pc}
;;;360    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;320      */
;;;321    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;322    {
000002  4604              MOV      r4,r0
;;;323      /* Check the parameters */
;;;324      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;325    
;;;326      /* Disable the Input Capture channel 1
;;;327        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;328      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;329    
;;;330      /* Disable the Peripheral */
;;;331      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  f2411211          MOV      r2,#0x1111
000016  4211              TST      r1,r2
000018  d107              BNE      |L15.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L15.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L15.42|
;;;332    
;;;333      /* Return function status */
;;;334      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;335    }
00002c  bd10              POP      {r4,pc}
;;;336    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;440    {
000002  4604              MOV      r4,r0
;;;441      /* Check the parameters */
;;;442      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;443    
;;;444      /* Disable the Input Capture channel 1
;;;445        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;446      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;447    
;;;448    
;;;449      /* Disable the capture compare Interrupts 1 event */
;;;450      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4217100          BIC      r1,r1,#0x200
000016  60c1              STR      r1,[r0,#0xc]
;;;451    
;;;452      /* Disable the Peripheral */
;;;453      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L16.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L16.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L16.52|
;;;454    
;;;455      /* Return function status */
;;;456      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;457    }
000036  bd10              POP      {r4,pc}
;;;458    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;365      */
;;;366    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;367    {
000002  4604              MOV      r4,r0
;;;368      /* Check the parameters */
;;;369      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;370    
;;;371      /* Disable the Input Capture channel 1
;;;372        (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;373      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;374    
;;;375      /* Disable the capture compare Interrupts event */
;;;376      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210102          BIC      r1,r1,#2
000016  60c1              STR      r1,[r0,#0xc]
;;;377    
;;;378      /* Disable the Peripheral */
;;;379      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L17.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L17.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L17.52|
;;;380    
;;;381      /* Return function status */
;;;382      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;383    }
000036  bd10              POP      {r4,pc}
;;;384    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1672     */
;;;1673   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;1674   {
;;;1675     /* Check the parameters */
;;;1676     assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
;;;1677     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1678     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1679   
;;;1680     __HAL_LOCK(htim);
000002  f8902038          LDRB     r2,[r0,#0x38]
000006  2a01              CMP      r2,#1
000008  d020              BEQ      |L18.76|
00000a  2201              MOVS     r2,#1
00000c  f8802038          STRB     r2,[r0,#0x38]
;;;1681   
;;;1682     htim->State = HAL_TIM_STATE_BUSY;
000010  2302              MOVS     r3,#2
000012  f8803039          STRB     r3,[r0,#0x39]
;;;1683   
;;;1684     /* Reset the MMS Bits */
;;;1685     htim->Instance->CR2 &= ~TIM_CR2_MMS;
000016  6803              LDR      r3,[r0,#0]
000018  685c              LDR      r4,[r3,#4]
00001a  f0240470          BIC      r4,r4,#0x70
00001e  605c              STR      r4,[r3,#4]
;;;1686     /* Select the TRGO source */
;;;1687     htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
000020  6803              LDR      r3,[r0,#0]
000022  685c              LDR      r4,[r3,#4]
000024  680d              LDR      r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
000028  605c              STR      r4,[r3,#4]
;;;1688   
;;;1689     /* Reset the MSM Bit */
;;;1690     htim->Instance->SMCR &= ~TIM_SMCR_MSM;
00002a  6803              LDR      r3,[r0,#0]
00002c  689c              LDR      r4,[r3,#8]
00002e  f0240480          BIC      r4,r4,#0x80
000032  609c              STR      r4,[r3,#8]
;;;1691     /* Set or Reset the MSM Bit */
;;;1692     htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
000034  6803              LDR      r3,[r0,#0]
000036  689c              LDR      r4,[r3,#8]
000038  6849              LDR      r1,[r1,#4]
00003a  430c              ORRS     r4,r4,r1
00003c  609c              STR      r4,[r3,#8]
;;;1693   
;;;1694     htim->State = HAL_TIM_STATE_READY;
00003e  f8802039          STRB     r2,[r0,#0x39]
;;;1695   
;;;1696     __HAL_UNLOCK(htim);
000042  2100              MOVS     r1,#0
000044  f8801038          STRB     r1,[r0,#0x38]
;;;1697   
;;;1698     return HAL_OK;
000048  4608              MOV      r0,r1
;;;1699   }
00004a  bd30              POP      {r4,r5,pc}
                  |L18.76|
00004c  2002              MOVS     r0,#2                 ;1680
00004e  bd30              POP      {r4,r5,pc}
;;;1700   
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;498      */
;;;499    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;500    {
000002  4604              MOV      r4,r0
;;;501      /* Check the parameters */
;;;502      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;503    
;;;504      /* Enable the Capture compare channel N */
;;;505      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;506    
;;;507      /* Enable the Main Ouput */
;;;508      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;509    
;;;510      /* Enable the Peripheral */
;;;511      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;512    
;;;513      /* Return function status */
;;;514      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;515    }
000022  bd10              POP      {r4,pc}
;;;516    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;700      */
;;;701    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;702    {
000002  4604              MOV      r4,r0
;;;703      /* Check the parameters */
;;;704      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;705    
;;;706      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;702
00000a  460d              MOV      r5,r1                 ;702
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L20.28|
;;;707      {
;;;708         return HAL_BUSY;
;;;709      }
;;;710      else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L20.36|
;;;711      {
;;;712        if(((uint32_t)pData == 0 ) && (Length > 0))
000018  b90e              CBNZ     r6,|L20.30|
00001a  b103              CBZ      r3,|L20.30|
                  |L20.28|
;;;713        {
;;;714          return HAL_ERROR;
;;;715        }
;;;716        else
;;;717        {
;;;718          htim->State = HAL_TIM_STATE_BUSY;
;;;719        }
;;;720      }
;;;721      switch (Channel)
;;;722      {
;;;723        case TIM_CHANNEL_1:
;;;724        {
;;;725          /* Set the DMA Period elapsed callback */
;;;726          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;727    
;;;728          /* Set the DMA error callback */
;;;729          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;730    
;;;731          /* Enable the DMA channel */
;;;732          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;733    
;;;734          /* Enable the TIM Output Compare DMA request */
;;;735          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;736        }
;;;737        break;
;;;738    
;;;739        case TIM_CHANNEL_2:
;;;740        {
;;;741          /* Set the DMA Period elapsed callback */
;;;742          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;743    
;;;744          /* Set the DMA error callback */
;;;745          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;746    
;;;747          /* Enable the DMA channel */
;;;748          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;749    
;;;750          /* Enable the TIM Output Compare DMA request */
;;;751          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;752        }
;;;753        break;
;;;754    
;;;755        case TIM_CHANNEL_3:
;;;756    {
;;;757          /* Set the DMA Period elapsed callback */
;;;758          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;759    
;;;760          /* Set the DMA error callback */
;;;761          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;762    
;;;763          /* Enable the DMA channel */
;;;764          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;765    
;;;766          /* Enable the TIM Output Compare DMA request */
;;;767          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;768        }
;;;769        break;
;;;770    
;;;771        case TIM_CHANNEL_4:
;;;772        {
;;;773         /* Set the DMA Period elapsed callback */
;;;774          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;775    
;;;776          /* Set the DMA error callback */
;;;777          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;778    
;;;779          /* Enable the DMA channel */
;;;780          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;781    
;;;782          /* Enable the TIM Output Compare DMA request */
;;;783          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;784        }
;;;785        break;
;;;786    
;;;787        default:
;;;788        break;
;;;789      }
;;;790    
;;;791      /* Enable the Capture compare channel N */
;;;792      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;793    
;;;794      /* Enable the Main Ouput */
;;;795      __HAL_TIM_MOE_ENABLE(htim);
;;;796    
;;;797      /* Enable the Peripheral */
;;;798      __HAL_TIM_ENABLE(htim);
;;;799    
;;;800      /* Return function status */
;;;801      return HAL_OK;
;;;802    }
00001c  bd70              POP      {r4-r6,pc}
                  |L20.30|
00001e  2002              MOVS     r0,#2                 ;718
000020  f8840039          STRB     r0,[r4,#0x39]         ;718
                  |L20.36|
000024  482b              LDR      r0,|L20.212|
000026  492c              LDR      r1,|L20.216|
000028  b135              CBZ      r5,|L20.56|
00002a  2d04              CMP      r5,#4                 ;721
00002c  d013              BEQ      |L20.86|
00002e  2d08              CMP      r5,#8                 ;721
000030  d031              BEQ      |L20.150|
000032  2d0c              CMP      r5,#0xc               ;721
000034  d11e              BNE      |L20.116|
000036  e03d              B        |L20.180|
                  |L20.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;726
00003a  6290              STR      r0,[r2,#0x28]         ;729
00003c  6a20              LDR      r0,[r4,#0x20]         ;729
00003e  6301              STR      r1,[r0,#0x30]         ;732
000040  6822              LDR      r2,[r4,#0]            ;732
000042  4631              MOV      r1,r6                 ;732
000044  3234              ADDS     r2,r2,#0x34           ;732
000046  6a20              LDR      r0,[r4,#0x20]         ;732
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;735
00004e  68c1              LDR      r1,[r0,#0xc]          ;735
000050  f4417100          ORR      r1,r1,#0x200          ;735
000054  e00d              B        |L20.114|
                  |L20.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;742
000058  6290              STR      r0,[r2,#0x28]         ;745
00005a  6a60              LDR      r0,[r4,#0x24]         ;745
00005c  6301              STR      r1,[r0,#0x30]         ;748
00005e  6822              LDR      r2,[r4,#0]            ;748
000060  4631              MOV      r1,r6                 ;748
000062  3238              ADDS     r2,r2,#0x38           ;748
000064  6a60              LDR      r0,[r4,#0x24]         ;748
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;751
00006c  68c1              LDR      r1,[r0,#0xc]          ;751
00006e  f4416180          ORR      r1,r1,#0x400          ;751
                  |L20.114|
000072  60c1              STR      r1,[r0,#0xc]          ;735
                  |L20.116|
000074  2204              MOVS     r2,#4                 ;792
000076  4629              MOV      r1,r5                 ;792
000078  6820              LDR      r0,[r4,#0]            ;792
00007a  f7fffffe          BL       TIM_CCxNChannelCmd
00007e  6820              LDR      r0,[r4,#0]            ;795
000080  6c41              LDR      r1,[r0,#0x44]         ;795
000082  f4414100          ORR      r1,r1,#0x8000         ;795
000086  6441              STR      r1,[r0,#0x44]         ;795
000088  6820              LDR      r0,[r4,#0]            ;798
00008a  6801              LDR      r1,[r0,#0]            ;798
00008c  f0410101          ORR      r1,r1,#1              ;798
000090  6001              STR      r1,[r0,#0]            ;798
000092  2000              MOVS     r0,#0                 ;801
000094  bd70              POP      {r4-r6,pc}
                  |L20.150|
000096  6aa2              LDR      r2,[r4,#0x28]         ;758
000098  6290              STR      r0,[r2,#0x28]         ;761
00009a  6aa0              LDR      r0,[r4,#0x28]         ;761
00009c  6301              STR      r1,[r0,#0x30]         ;764
00009e  6822              LDR      r2,[r4,#0]            ;764
0000a0  4631              MOV      r1,r6                 ;764
0000a2  323c              ADDS     r2,r2,#0x3c           ;764
0000a4  6aa0              LDR      r0,[r4,#0x28]         ;764
0000a6  f7fffffe          BL       HAL_DMA_Start_IT
0000aa  6820              LDR      r0,[r4,#0]            ;767
0000ac  68c1              LDR      r1,[r0,#0xc]          ;767
0000ae  f4416100          ORR      r1,r1,#0x800          ;767
0000b2  e7de              B        |L20.114|
                  |L20.180|
0000b4  6ae2              LDR      r2,[r4,#0x2c]         ;774
0000b6  6290              STR      r0,[r2,#0x28]         ;777
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;777
0000ba  6301              STR      r1,[r0,#0x30]         ;780
0000bc  6822              LDR      r2,[r4,#0]            ;780
0000be  4631              MOV      r1,r6                 ;780
0000c0  3240              ADDS     r2,r2,#0x40           ;780
0000c2  6ae0              LDR      r0,[r4,#0x2c]         ;780
0000c4  f7fffffe          BL       HAL_DMA_Start_IT
0000c8  6820              LDR      r0,[r4,#0]            ;783
0000ca  68c1              LDR      r1,[r0,#0xc]          ;783
0000cc  f4415180          ORR      r1,r1,#0x1000         ;783
0000d0  e7cf              B        |L20.114|
;;;803    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L20.212|
                          DCD      TIM_DMADelayPulseCplt
                  |L20.216|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;558      */
;;;559    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;560    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L21.22|
;;;561      /* Check the parameters */
;;;562      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;563    
;;;564      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L21.30|
00000c  2908              CMP      r1,#8
00000e  d01f              BEQ      |L21.80|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L21.38|
000014  e020              B        |L21.88|
                  |L21.22|
;;;565      {
;;;566        case TIM_CHANNEL_1:
;;;567        {
;;;568          /* Enable the TIM Output Compare interrupt */
;;;569          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;570        }
;;;571        break;
00001c  e002              B        |L21.36|
                  |L21.30|
;;;572    
;;;573        case TIM_CHANNEL_2:
;;;574        {
;;;575          /* Enable the TIM Output Compare interrupt */
;;;576          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L21.36|
000024  60d0              STR      r0,[r2,#0xc]          ;569
                  |L21.38|
;;;577        }
;;;578        break;
;;;579    
;;;580        case TIM_CHANNEL_3:
;;;581        {
;;;582          /* Enable the TIM Output Compare interrupt */
;;;583          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;584        }
;;;585        break;
;;;586    
;;;587        case TIM_CHANNEL_4:
;;;588        {
;;;589          /* Enable the TIM Output Compare interrupt */
;;;590          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;591        }
;;;592        break;
;;;593    
;;;594        default:
;;;595        break;
;;;596      }
;;;597    
;;;598      /* Enable the TIM Break interrupt */
;;;599      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000026  6820              LDR      r0,[r4,#0]
000028  68c2              LDR      r2,[r0,#0xc]
00002a  f0420280          ORR      r2,r2,#0x80
00002e  60c2              STR      r2,[r0,#0xc]
;;;600    
;;;601      /* Enable the Capture compare channel N */
;;;602      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000030  2204              MOVS     r2,#4
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       TIM_CCxNChannelCmd
;;;603    
;;;604      /* Enable the Main Ouput */
;;;605      __HAL_TIM_MOE_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
;;;606    
;;;607      /* Enable the Peripheral */
;;;608      __HAL_TIM_ENABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f0410101          ORR      r1,r1,#1
00004a  6001              STR      r1,[r0,#0]
;;;609    
;;;610      /* Return function status */
;;;611      return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;612    }
00004e  bd10              POP      {r4,pc}
                  |L21.80|
000050  68d0              LDR      r0,[r2,#0xc]          ;583
000052  f0400008          ORR      r0,r0,#8              ;583
000056  e7e5              B        |L21.36|
                  |L21.88|
000058  68d0              LDR      r0,[r2,#0xc]          ;590
00005a  f0400010          ORR      r0,r0,#0x10           ;590
00005e  e7e1              B        |L21.36|
;;;613    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;528      */
;;;529    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;530    {
000002  4604              MOV      r4,r0
;;;531      /* Check the parameters */
;;;532      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;533    
;;;534      /* Disable the Capture compare channel N */
;;;535      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;536    
;;;537      /* Disable the Main Ouput */
;;;538      __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L22.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L22.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L22.42|
;;;539    
;;;540      /* Disable the Peripheral */
;;;541      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L22.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L22.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L22.64|
;;;542    
;;;543      /* Return function status */
;;;544      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;545    }
000042  bd10              POP      {r4,pc}
;;;546    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;815      */
;;;816    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;817    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L23.22|
;;;818      /* Check the parameters */
;;;819      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;820    
;;;821      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L23.30|
00000c  2908              CMP      r1,#8
00000e  d02d              BEQ      |L23.108|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L23.38|
000014  e02e              B        |L23.116|
                  |L23.22|
;;;822      {
;;;823        case TIM_CHANNEL_1:
;;;824        {
;;;825          /* Disable the TIM Output Compare DMA request */
;;;826          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;827        }
;;;828        break;
00001c  e002              B        |L23.36|
                  |L23.30|
;;;829    
;;;830        case TIM_CHANNEL_2:
;;;831        {
;;;832          /* Disable the TIM Output Compare DMA request */
;;;833          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L23.36|
000024  60d0              STR      r0,[r2,#0xc]          ;826
                  |L23.38|
;;;834        }
;;;835        break;
;;;836    
;;;837        case TIM_CHANNEL_3:
;;;838        {
;;;839          /* Disable the TIM Output Compare DMA request */
;;;840          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;841        }
;;;842        break;
;;;843    
;;;844        case TIM_CHANNEL_4:
;;;845        {
;;;846          /* Disable the TIM Output Compare interrupt */
;;;847          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;848        }
;;;849        break;
;;;850    
;;;851        default:
;;;852        break;
;;;853      }
;;;854    
;;;855      /* Disable the Capture compare channel N */
;;;856      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;857    
;;;858      /* Disable the Main Ouput */
;;;859      __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4213              TST      r3,r2
000038  f2404144          MOV      r1,#0x444
00003c  d106              BNE      |L23.76|
00003e  6a03              LDR      r3,[r0,#0x20]
000040  420b              TST      r3,r1
000042  d103              BNE      |L23.76|
000044  6c43              LDR      r3,[r0,#0x44]
000046  f4234300          BIC      r3,r3,#0x8000
00004a  6443              STR      r3,[r0,#0x44]
                  |L23.76|
;;;860    
;;;861      /* Disable the Peripheral */
;;;862      __HAL_TIM_DISABLE(htim);
00004c  6820              LDR      r0,[r4,#0]
00004e  6a03              LDR      r3,[r0,#0x20]
000050  4213              TST      r3,r2
000052  d106              BNE      |L23.98|
000054  6a02              LDR      r2,[r0,#0x20]
000056  420a              TST      r2,r1
000058  d103              BNE      |L23.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L23.98|
;;;863    
;;;864      /* Change the htim state */
;;;865      htim->State = HAL_TIM_STATE_READY;
000062  2001              MOVS     r0,#1
000064  f8840039          STRB     r0,[r4,#0x39]
;;;866    
;;;867      /* Return function status */
;;;868      return HAL_OK;
000068  2000              MOVS     r0,#0
;;;869    }
00006a  bd10              POP      {r4,pc}
                  |L23.108|
00006c  68d0              LDR      r0,[r2,#0xc]          ;840
00006e  f4206000          BIC      r0,r0,#0x800          ;840
000072  e7d7              B        |L23.36|
                  |L23.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;847
000076  f4205080          BIC      r0,r0,#0x1000         ;847
00007a  e7d3              B        |L23.36|
;;;870    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;625      */
;;;626    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;627    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L24.22|
;;;628      uint32_t tmpccer = 0;
;;;629    
;;;630      /* Check the parameters */
;;;631      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;632    
;;;633      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L24.30|
00000c  2908              CMP      r1,#8
00000e  d032              BEQ      |L24.118|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L24.38|
000014  e033              B        |L24.126|
                  |L24.22|
;;;634      {
;;;635        case TIM_CHANNEL_1:
;;;636        {
;;;637          /* Disable the TIM Output Compare interrupt */
;;;638          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;639        }
;;;640        break;
00001c  e002              B        |L24.36|
                  |L24.30|
;;;641    
;;;642        case TIM_CHANNEL_2:
;;;643        {
;;;644          /* Disable the TIM Output Compare interrupt */
;;;645          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L24.36|
000024  60d0              STR      r0,[r2,#0xc]          ;638
                  |L24.38|
;;;646        }
;;;647        break;
;;;648    
;;;649        case TIM_CHANNEL_3:
;;;650        {
;;;651          /* Disable the TIM Output Compare interrupt */
;;;652          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;653        }
;;;654        break;
;;;655    
;;;656        case TIM_CHANNEL_4:
;;;657        {
;;;658          /* Disable the TIM Output Compare interrupt */
;;;659          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;660        }
;;;661        break;
;;;662    
;;;663        default:
;;;664        break;
;;;665      }
;;;666    
;;;667      /* Disable the Capture compare channel N */
;;;668      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;669    
;;;670      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;671      tmpccer = htim->Instance->CCER;
00002e  6820              LDR      r0,[r4,#0]
000030  6a02              LDR      r2,[r0,#0x20]
;;;672      if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
000032  f2404144          MOV      r1,#0x444
000036  420a              TST      r2,r1
000038  d103              BNE      |L24.66|
;;;673      {
;;;674        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
00003a  68c2              LDR      r2,[r0,#0xc]
00003c  f0220280          BIC      r2,r2,#0x80
000040  60c2              STR      r2,[r0,#0xc]
                  |L24.66|
;;;675      }
;;;676    
;;;677      /* Disable the Main Ouput */
;;;678      __HAL_TIM_MOE_DISABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6a03              LDR      r3,[r0,#0x20]
000046  f2411211          MOV      r2,#0x1111
00004a  4213              TST      r3,r2
00004c  d106              BNE      |L24.92|
00004e  6a03              LDR      r3,[r0,#0x20]
000050  420b              TST      r3,r1
000052  d103              BNE      |L24.92|
000054  6c43              LDR      r3,[r0,#0x44]
000056  f4234300          BIC      r3,r3,#0x8000
00005a  6443              STR      r3,[r0,#0x44]
                  |L24.92|
;;;679    
;;;680      /* Disable the Peripheral */
;;;681      __HAL_TIM_DISABLE(htim);
00005c  6820              LDR      r0,[r4,#0]
00005e  6a03              LDR      r3,[r0,#0x20]
000060  4213              TST      r3,r2
000062  d106              BNE      |L24.114|
000064  6a02              LDR      r2,[r0,#0x20]
000066  420a              TST      r2,r1
000068  d103              BNE      |L24.114|
00006a  6801              LDR      r1,[r0,#0]
00006c  f0210101          BIC      r1,r1,#1
000070  6001              STR      r1,[r0,#0]
                  |L24.114|
;;;682    
;;;683      /* Return function status */
;;;684      return HAL_OK;
000072  2000              MOVS     r0,#0
;;;685    }
000074  bd10              POP      {r4,pc}
                  |L24.118|
000076  68d0              LDR      r0,[r2,#0xc]          ;652
000078  f0200008          BIC      r0,r0,#8              ;652
00007c  e7d2              B        |L24.36|
                  |L24.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;659
000080  f0200010          BIC      r0,r0,#0x10           ;659
000084  e7ce              B        |L24.36|
;;;686    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1318     */
;;;1319   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1320     {
000002  4604              MOV      r4,r0
;;;1321     /* Check the parameters */
;;;1322     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1323   
;;;1324     /* Enable the complementary One Pulse output */
;;;1325     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1326   
;;;1327     /* Enable the Main Ouput */
;;;1328     __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;1329   
;;;1330     /* Return function status */
;;;1331     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1332   }
000018  bd10              POP      {r4,pc}
;;;1333   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1372     */
;;;1373   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1374   {
000002  4604              MOV      r4,r0
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1377   
;;;1378     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1379     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0420202          ORR      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1380   
;;;1381     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1382     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0420204          ORR      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1383   
;;;1384     /* Enable the complementary One Pulse output */
;;;1385     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000018  2204              MOVS     r2,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1386   
;;;1387     /* Enable the Main Ouput */
;;;1388     __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c41              LDR      r1,[r0,#0x44]
000024  f4414100          ORR      r1,r1,#0x8000
000028  6441              STR      r1,[r0,#0x44]
;;;1389   
;;;1390     /* Return function status */
;;;1391     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;1392     }
00002c  bd10              POP      {r4,pc}
;;;1393   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1343     */
;;;1344   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1345   {
000002  4604              MOV      r4,r0
;;;1346   
;;;1347     /* Check the parameters */
;;;1348     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1349   
;;;1350     /* Disable the complementary One Pulse output */
;;;1351     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1352   
;;;1353     /* Disable the Main Ouput */
;;;1354     __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L27.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L27.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L27.42|
;;;1355   
;;;1356     /* Disable the Peripheral */
;;;1357     __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L27.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L27.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L27.64|
;;;1358   
;;;1359     /* Return function status */
;;;1360     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1361   }
000042  bd10              POP      {r4,pc}
;;;1362   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1403     */
;;;1404   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1405   {
000002  4604              MOV      r4,r0
;;;1406     /* Check the parameters */
;;;1407     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1408   
;;;1409     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1410     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0220202          BIC      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1411   
;;;1412     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1413     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0220204          BIC      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1414   
;;;1415     /* Disable the complementary One Pulse output */
;;;1416     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000018  2200              MOVS     r2,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1417   
;;;1418     /* Disable the Main Ouput */
;;;1419     __HAL_TIM_MOE_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a03              LDR      r3,[r0,#0x20]
000024  f2411111          MOV      r1,#0x1111
000028  420b              TST      r3,r1
00002a  f2404244          MOV      r2,#0x444
00002e  d106              BNE      |L28.62|
000030  6a03              LDR      r3,[r0,#0x20]
000032  4213              TST      r3,r2
000034  d103              BNE      |L28.62|
000036  6c43              LDR      r3,[r0,#0x44]
000038  f4234300          BIC      r3,r3,#0x8000
00003c  6443              STR      r3,[r0,#0x44]
                  |L28.62|
;;;1420   
;;;1421     /* Disable the Peripheral */
;;;1422      __HAL_TIM_DISABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6a03              LDR      r3,[r0,#0x20]
000042  420b              TST      r3,r1
000044  d106              BNE      |L28.84|
000046  6a01              LDR      r1,[r0,#0x20]
000048  4211              TST      r1,r2
00004a  d103              BNE      |L28.84|
00004c  6801              LDR      r1,[r0,#0]
00004e  f0210101          BIC      r1,r1,#1
000052  6001              STR      r1,[r0,#0]
                  |L28.84|
;;;1423   
;;;1424     /* Return function status */
;;;1425     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1426   }
000056  bd10              POP      {r4,pc}
;;;1427   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;915      */
;;;916    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;917    {
000002  4604              MOV      r4,r0
;;;918      /* Check the parameters */
;;;919      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;920    
;;;921      /* Enable the complementary PWM output  */
;;;922      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;923    
;;;924      /* Enable the Main Ouput */
;;;925      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;926    
;;;927      /* Enable the Peripheral */
;;;928      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;929    
;;;930      /* Return function status */
;;;931      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;932    }
000022  bd10              POP      {r4,pc}
;;;933    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1116     */
;;;1117   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1118   {
000002  4604              MOV      r4,r0
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1121   
;;;1122     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;1118
00000a  460d              MOV      r5,r1                 ;1118
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L30.28|
;;;1123     {
;;;1124        return HAL_BUSY;
;;;1125     }
;;;1126     else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L30.36|
;;;1127     {
;;;1128       if(((uint32_t)pData == 0 ) && (Length > 0))
000018  b90e              CBNZ     r6,|L30.30|
00001a  b103              CBZ      r3,|L30.30|
                  |L30.28|
;;;1129       {
;;;1130         return HAL_ERROR;
;;;1131       }
;;;1132       else
;;;1133       {
;;;1134         htim->State = HAL_TIM_STATE_BUSY;
;;;1135       }
;;;1136     }
;;;1137     switch (Channel)
;;;1138     {
;;;1139       case TIM_CHANNEL_1:
;;;1140       {
;;;1141         /* Set the DMA Period elapsed callback */
;;;1142         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1143   
;;;1144         /* Set the DMA error callback */
;;;1145         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1146   
;;;1147         /* Enable the DMA channel */
;;;1148         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1149   
;;;1150         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1151         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1152       }
;;;1153       break;
;;;1154   
;;;1155       case TIM_CHANNEL_2:
;;;1156       {
;;;1157         /* Set the DMA Period elapsed callback */
;;;1158         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1159   
;;;1160         /* Set the DMA error callback */
;;;1161         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1162   
;;;1163         /* Enable the DMA channel */
;;;1164         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1165   
;;;1166         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1167         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1168       }
;;;1169       break;
;;;1170   
;;;1171       case TIM_CHANNEL_3:
;;;1172       {
;;;1173         /* Set the DMA Period elapsed callback */
;;;1174         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1175   
;;;1176         /* Set the DMA error callback */
;;;1177         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1178   
;;;1179         /* Enable the DMA channel */
;;;1180         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1181   
;;;1182         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1183         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1184       }
;;;1185       break;
;;;1186   
;;;1187       case TIM_CHANNEL_4:
;;;1188       {
;;;1189        /* Set the DMA Period elapsed callback */
;;;1190         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1191   
;;;1192         /* Set the DMA error callback */
;;;1193         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1194   
;;;1195         /* Enable the DMA channel */
;;;1196         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1197   
;;;1198         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1199         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1200       }
;;;1201       break;
;;;1202   
;;;1203       default:
;;;1204       break;
;;;1205     }
;;;1206   
;;;1207     /* Enable the complementary PWM output  */
;;;1208        TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1209   
;;;1210     /* Enable the Main Ouput */
;;;1211       __HAL_TIM_MOE_ENABLE(htim);
;;;1212   
;;;1213     /* Enable the Peripheral */
;;;1214     __HAL_TIM_ENABLE(htim);
;;;1215   
;;;1216     /* Return function status */
;;;1217     return HAL_OK;
;;;1218   }
00001c  bd70              POP      {r4-r6,pc}
                  |L30.30|
00001e  2002              MOVS     r0,#2                 ;1134
000020  f8840039          STRB     r0,[r4,#0x39]         ;1134
                  |L30.36|
000024  482b              LDR      r0,|L30.212|
000026  492c              LDR      r1,|L30.216|
000028  b135              CBZ      r5,|L30.56|
00002a  2d04              CMP      r5,#4                 ;1137
00002c  d013              BEQ      |L30.86|
00002e  2d08              CMP      r5,#8                 ;1137
000030  d031              BEQ      |L30.150|
000032  2d0c              CMP      r5,#0xc               ;1137
000034  d11e              BNE      |L30.116|
000036  e03d              B        |L30.180|
                  |L30.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;1142
00003a  6290              STR      r0,[r2,#0x28]         ;1145
00003c  6a20              LDR      r0,[r4,#0x20]         ;1145
00003e  6301              STR      r1,[r0,#0x30]         ;1148
000040  6822              LDR      r2,[r4,#0]            ;1148
000042  4631              MOV      r1,r6                 ;1148
000044  3234              ADDS     r2,r2,#0x34           ;1148
000046  6a20              LDR      r0,[r4,#0x20]         ;1148
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1151
00004e  68c1              LDR      r1,[r0,#0xc]          ;1151
000050  f4417100          ORR      r1,r1,#0x200          ;1151
000054  e00d              B        |L30.114|
                  |L30.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;1158
000058  6290              STR      r0,[r2,#0x28]         ;1161
00005a  6a60              LDR      r0,[r4,#0x24]         ;1161
00005c  6301              STR      r1,[r0,#0x30]         ;1164
00005e  6822              LDR      r2,[r4,#0]            ;1164
000060  4631              MOV      r1,r6                 ;1164
000062  3238              ADDS     r2,r2,#0x38           ;1164
000064  6a60              LDR      r0,[r4,#0x24]         ;1164
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;1167
00006c  68c1              LDR      r1,[r0,#0xc]          ;1167
00006e  f4416180          ORR      r1,r1,#0x400          ;1167
                  |L30.114|
000072  60c1              STR      r1,[r0,#0xc]          ;1151
                  |L30.116|
000074  2204              MOVS     r2,#4                 ;1208
000076  4629              MOV      r1,r5                 ;1208
000078  6820              LDR      r0,[r4,#0]            ;1208
00007a  f7fffffe          BL       TIM_CCxNChannelCmd
00007e  6820              LDR      r0,[r4,#0]            ;1211
000080  6c41              LDR      r1,[r0,#0x44]         ;1211
000082  f4414100          ORR      r1,r1,#0x8000         ;1211
000086  6441              STR      r1,[r0,#0x44]         ;1211
000088  6820              LDR      r0,[r4,#0]            ;1214
00008a  6801              LDR      r1,[r0,#0]            ;1214
00008c  f0410101          ORR      r1,r1,#1              ;1214
000090  6001              STR      r1,[r0,#0]            ;1214
000092  2000              MOVS     r0,#0                 ;1217
000094  bd70              POP      {r4-r6,pc}
                  |L30.150|
000096  6aa2              LDR      r2,[r4,#0x28]         ;1174
000098  6290              STR      r0,[r2,#0x28]         ;1177
00009a  6aa0              LDR      r0,[r4,#0x28]         ;1177
00009c  6301              STR      r1,[r0,#0x30]         ;1180
00009e  6822              LDR      r2,[r4,#0]            ;1180
0000a0  4631              MOV      r1,r6                 ;1180
0000a2  323c              ADDS     r2,r2,#0x3c           ;1180
0000a4  6aa0              LDR      r0,[r4,#0x28]         ;1180
0000a6  f7fffffe          BL       HAL_DMA_Start_IT
0000aa  6820              LDR      r0,[r4,#0]            ;1183
0000ac  68c1              LDR      r1,[r0,#0xc]          ;1183
0000ae  f4416100          ORR      r1,r1,#0x800          ;1183
0000b2  e7de              B        |L30.114|
                  |L30.180|
0000b4  6ae2              LDR      r2,[r4,#0x2c]         ;1190
0000b6  6290              STR      r0,[r2,#0x28]         ;1193
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;1193
0000ba  6301              STR      r1,[r0,#0x30]         ;1196
0000bc  6822              LDR      r2,[r4,#0]            ;1196
0000be  4631              MOV      r1,r6                 ;1196
0000c0  3240              ADDS     r2,r2,#0x40           ;1196
0000c2  6ae0              LDR      r0,[r4,#0x2c]         ;1196
0000c4  f7fffffe          BL       HAL_DMA_Start_IT
0000c8  6820              LDR      r0,[r4,#0]            ;1199
0000ca  68c1              LDR      r1,[r0,#0xc]          ;1199
0000cc  f4415180          ORR      r1,r1,#0x1000         ;1199
0000d0  e7cf              B        |L30.114|
;;;1219   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L30.212|
                          DCD      TIM_DMADelayPulseCplt
                  |L30.216|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;974      */
;;;975    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;976    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L31.22|
;;;977      /* Check the parameters */
;;;978      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;979    
;;;980      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L31.30|
00000c  2908              CMP      r1,#8
00000e  d01f              BEQ      |L31.80|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L31.38|
000014  e020              B        |L31.88|
                  |L31.22|
;;;981      {
;;;982        case TIM_CHANNEL_1:
;;;983        {
;;;984          /* Enable the TIM Capture/Compare 1 interrupt */
;;;985          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;986        }
;;;987        break;
00001c  e002              B        |L31.36|
                  |L31.30|
;;;988    
;;;989        case TIM_CHANNEL_2:
;;;990        {
;;;991          /* Enable the TIM Capture/Compare 2 interrupt */
;;;992          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L31.36|
000024  60d0              STR      r0,[r2,#0xc]          ;985
                  |L31.38|
;;;993        }
;;;994        break;
;;;995    
;;;996        case TIM_CHANNEL_3:
;;;997        {
;;;998          /* Enable the TIM Capture/Compare 3 interrupt */
;;;999          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1000       }
;;;1001       break;
;;;1002   
;;;1003       case TIM_CHANNEL_4:
;;;1004       {
;;;1005         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1006         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1007       }
;;;1008       break;
;;;1009   
;;;1010       default:
;;;1011       break;
;;;1012     }
;;;1013   
;;;1014     /* Enable the TIM Break interrupt */
;;;1015     __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000026  6820              LDR      r0,[r4,#0]
000028  68c2              LDR      r2,[r0,#0xc]
00002a  f0420280          ORR      r2,r2,#0x80
00002e  60c2              STR      r2,[r0,#0xc]
;;;1016   
;;;1017     /* Enable the complementary PWM output  */
;;;1018     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000030  2204              MOVS     r2,#4
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1019   
;;;1020     /* Enable the Main Ouput */
;;;1021     __HAL_TIM_MOE_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
;;;1022   
;;;1023     /* Enable the Peripheral */
;;;1024     __HAL_TIM_ENABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f0410101          ORR      r1,r1,#1
00004a  6001              STR      r1,[r0,#0]
;;;1025   
;;;1026     /* Return function status */
;;;1027     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;1028   }
00004e  bd10              POP      {r4,pc}
                  |L31.80|
000050  68d0              LDR      r0,[r2,#0xc]          ;999
000052  f0400008          ORR      r0,r0,#8              ;999
000056  e7e5              B        |L31.36|
                  |L31.88|
000058  68d0              LDR      r0,[r2,#0xc]          ;1006
00005a  f0400010          ORR      r0,r0,#0x10           ;1006
00005e  e7e1              B        |L31.36|
;;;1029   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;944      */
;;;945    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;946    {
000002  4604              MOV      r4,r0
;;;947      /* Check the parameters */
;;;948      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;949    
;;;950      /* Disable the complementary PWM output  */
;;;951      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;952    
;;;953      /* Disable the Main Ouput */
;;;954      __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L32.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L32.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L32.42|
;;;955    
;;;956      /* Disable the Peripheral */
;;;957      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L32.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L32.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L32.64|
;;;958    
;;;959      /* Return function status */
;;;960      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;961    }
000042  bd10              POP      {r4,pc}
;;;962    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1231     */
;;;1232   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1233   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L33.22|
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1236   
;;;1237     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L33.30|
00000c  2908              CMP      r1,#8
00000e  d02d              BEQ      |L33.108|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L33.38|
000014  e02e              B        |L33.116|
                  |L33.22|
;;;1238     {
;;;1239       case TIM_CHANNEL_1:
;;;1240       {
;;;1241         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1242         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1243       }
;;;1244       break;
00001c  e002              B        |L33.36|
                  |L33.30|
;;;1245   
;;;1246       case TIM_CHANNEL_2:
;;;1247       {
;;;1248         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1249         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L33.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1242
                  |L33.38|
;;;1250       }
;;;1251       break;
;;;1252   
;;;1253       case TIM_CHANNEL_3:
;;;1254       {
;;;1255         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1256         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1257       }
;;;1258       break;
;;;1259   
;;;1260       case TIM_CHANNEL_4:
;;;1261       {
;;;1262         /* Disable the TIM Capture/Compare 4 DMA request */
;;;1263         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1264       }
;;;1265       break;
;;;1266   
;;;1267       default:
;;;1268       break;
;;;1269     }
;;;1270   
;;;1271     /* Disable the complementary PWM output */
;;;1272       TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1273   
;;;1274     /* Disable the Main Ouput */
;;;1275       __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4213              TST      r3,r2
000038  f2404144          MOV      r1,#0x444
00003c  d106              BNE      |L33.76|
00003e  6a03              LDR      r3,[r0,#0x20]
000040  420b              TST      r3,r1
000042  d103              BNE      |L33.76|
000044  6c43              LDR      r3,[r0,#0x44]
000046  f4234300          BIC      r3,r3,#0x8000
00004a  6443              STR      r3,[r0,#0x44]
                  |L33.76|
;;;1276   
;;;1277     /* Disable the Peripheral */
;;;1278     __HAL_TIM_DISABLE(htim);
00004c  6820              LDR      r0,[r4,#0]
00004e  6a03              LDR      r3,[r0,#0x20]
000050  4213              TST      r3,r2
000052  d106              BNE      |L33.98|
000054  6a02              LDR      r2,[r0,#0x20]
000056  420a              TST      r2,r1
000058  d103              BNE      |L33.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L33.98|
;;;1279   
;;;1280     /* Change the htim state */
;;;1281     htim->State = HAL_TIM_STATE_READY;
000062  2001              MOVS     r0,#1
000064  f8840039          STRB     r0,[r4,#0x39]
;;;1282   
;;;1283     /* Return function status */
;;;1284     return HAL_OK;
000068  2000              MOVS     r0,#0
;;;1285   }
00006a  bd10              POP      {r4,pc}
                  |L33.108|
00006c  68d0              LDR      r0,[r2,#0xc]          ;1256
00006e  f4206000          BIC      r0,r0,#0x800          ;1256
000072  e7d7              B        |L33.36|
                  |L33.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;1263
000076  f4205080          BIC      r0,r0,#0x1000         ;1263
00007a  e7d3              B        |L33.36|
;;;1286   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1041     */
;;;1042   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1043   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L34.22|
;;;1044     uint32_t tmpccer = 0;
;;;1045   
;;;1046     /* Check the parameters */
;;;1047     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1048   
;;;1049     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L34.30|
00000c  2908              CMP      r1,#8
00000e  d032              BEQ      |L34.118|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L34.38|
000014  e033              B        |L34.126|
                  |L34.22|
;;;1050     {
;;;1051       case TIM_CHANNEL_1:
;;;1052       {
;;;1053         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1054         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1055       }
;;;1056       break;
00001c  e002              B        |L34.36|
                  |L34.30|
;;;1057   
;;;1058       case TIM_CHANNEL_2:
;;;1059       {
;;;1060         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1061         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L34.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1054
                  |L34.38|
;;;1062       }
;;;1063       break;
;;;1064   
;;;1065       case TIM_CHANNEL_3:
;;;1066       {
;;;1067         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1068         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1069       }
;;;1070       break;
;;;1071   
;;;1072       case TIM_CHANNEL_4:
;;;1073       {
;;;1074         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1075         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1076       }
;;;1077       break;
;;;1078   
;;;1079       default:
;;;1080       break;
;;;1081     }
;;;1082   
;;;1083     /* Disable the complementary PWM output  */
;;;1084     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1085   
;;;1086     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1087     tmpccer = htim->Instance->CCER;
00002e  6820              LDR      r0,[r4,#0]
000030  6a02              LDR      r2,[r0,#0x20]
;;;1088     if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
000032  f2404144          MOV      r1,#0x444
000036  420a              TST      r2,r1
000038  d103              BNE      |L34.66|
;;;1089     {
;;;1090       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
00003a  68c2              LDR      r2,[r0,#0xc]
00003c  f0220280          BIC      r2,r2,#0x80
000040  60c2              STR      r2,[r0,#0xc]
                  |L34.66|
;;;1091     }
;;;1092   
;;;1093     /* Disable the Main Ouput */
;;;1094     __HAL_TIM_MOE_DISABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6a03              LDR      r3,[r0,#0x20]
000046  f2411211          MOV      r2,#0x1111
00004a  4213              TST      r3,r2
00004c  d106              BNE      |L34.92|
00004e  6a03              LDR      r3,[r0,#0x20]
000050  420b              TST      r3,r1
000052  d103              BNE      |L34.92|
000054  6c43              LDR      r3,[r0,#0x44]
000056  f4234300          BIC      r3,r3,#0x8000
00005a  6443              STR      r3,[r0,#0x44]
                  |L34.92|
;;;1095   
;;;1096     /* Disable the Peripheral */
;;;1097     __HAL_TIM_DISABLE(htim);
00005c  6820              LDR      r0,[r4,#0]
00005e  6a03              LDR      r3,[r0,#0x20]
000060  4213              TST      r3,r2
000062  d106              BNE      |L34.114|
000064  6a02              LDR      r2,[r0,#0x20]
000066  420a              TST      r2,r1
000068  d103              BNE      |L34.114|
00006a  6801              LDR      r1,[r0,#0]
00006c  f0210101          BIC      r1,r1,#1
000070  6001              STR      r1,[r0,#0]
                  |L34.114|
;;;1098   
;;;1099     /* Return function status */
;;;1100     return HAL_OK;
000072  2000              MOVS     r0,#0
;;;1101   }
000074  bd10              POP      {r4,pc}
                  |L34.118|
000076  68d0              LDR      r0,[r2,#0xc]          ;1068
000078  f0200008          BIC      r0,r0,#8              ;1068
00007c  e7d2              B        |L34.36|
                  |L34.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;1075
000080  f0200010          BIC      r0,r0,#0x10           ;1075
000084  e7ce              B        |L34.36|
;;;1102   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;1753     */
;;;1754   void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1755   {
;;;1756     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1757   
;;;1758     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;1759   
;;;1760     HAL_TIMEx_CommutationCallback(htim);
00000a  f7fffffe          BL       HAL_TIMEx_CommutationCallback
;;;1761   }
00000e  bd10              POP      {r4,pc}
;;;1762   
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;1826     */
;;;1827   static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b510              PUSH     {r4,lr}
;;;1828   {
;;;1829     uint32_t tmp = 0;
;;;1830   
;;;1831     tmp = TIM_CCER_CC1NE << Channel;
000002  2304              MOVS     r3,#4
;;;1832   
;;;1833     /* Reset the CCxNE Bit */
;;;1834     TIMx->CCER &=  ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1831
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;1835   
;;;1836     /* Set or reset the CCxNE Bit */
;;;1837     TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;1838   }
000014  bd10              POP      {r4,pc}
;;;1839   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____RRX|
#line 587
|__asm___22_stm32f1xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
