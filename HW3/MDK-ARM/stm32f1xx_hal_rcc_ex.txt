; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ohw3_freertos\stm32f1xx_hal_rcc_ex.o --asm_dir=./ --list_dir=--list --depend=hw3_freertos\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I../Drivers/CMSIS/Include -I..\FreeRTOS\include -I..\Middlewares\Third_Party\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\Middlewares\Third_Party\FreeRTOS\Source\include -I..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS -I.\RTE\_HW3_FreeRTOS -IC:\Users\ChangEn\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\ChangEn\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_HD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103x6 --omf_browse=hw3_freertos\stm32f1xx_hal_rcc_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;294      */
;;;295    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2101              MOVS     r1,#1
;;;296    {
;;;297      uint32_t srcclk = 0;
;;;298      
;;;299      /* Set all possible values for the extended clock type parameter------------*/
;;;300      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
;;;301    
;;;302      /* Get the RTC configuration -----------------------------------------------*/
;;;303      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000002  6001              STR      r1,[r0,#0]
000004  4908              LDR      r1,|L1.40|
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f4027240          AND      r2,r2,#0x300
;;;304      /* Source clock is LSE or LSI*/
;;;305      PeriphClkInit->RTCClockSelection = srcclk;
;;;306    
;;;307      /* Get the ADC clock configuration -----------------------------------------*/
;;;308      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
00000c  6042              STR      r2,[r0,#4]
00000e  2203              MOVS     r2,#3
;;;309      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000010  6002              STR      r2,[r0,#0]
000012  684a              LDR      r2,[r1,#4]
000014  f4024240          AND      r2,r2,#0xc000
;;;310    
;;;311    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;312      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;313      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;314      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;315    
;;;316      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;317      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;318      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;319    
;;;320    #endif /* STM32F105xC || STM32F107xC */
;;;321    
;;;322    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;323      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;324      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;325      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;326    
;;;327      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;328      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;329      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;330    
;;;331    #endif /* STM32F103xE || STM32F103xG */
;;;332    
;;;333    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;334     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;335     || defined(STM32F105xC) || defined(STM32F107xC)
;;;336      /* Get the USB clock configuration -----------------------------------------*/
;;;337      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
000018  6082              STR      r2,[r0,#8]
00001a  2213              MOVS     r2,#0x13
;;;338      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00001c  6002              STR      r2,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4010180          AND      r1,r1,#0x400000
000024  60c1              STR      r1,[r0,#0xc]
;;;339    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;340    }
000026  4770              BX       lr
;;;341    
                          ENDP

                  |L1.40|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;387      */
;;;388    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b510              PUSH     {r4,lr}
;;;389    {
;;;390    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;391     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;392     || defined(STM32F105xC) || defined(STM32F107xC)
;;;393    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;394      const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
;;;395      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;396    #else
;;;397      const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
000002  a433              ADR      r4,|L2.208|
000004  4601              MOV      r1,r0                 ;389
000006  cc1d              LDM      r4,{r0,r2-r4}
000008  b086              SUB      sp,sp,#0x18           ;389
00000a  e88d001d          STM      sp,{r0,r2-r4}
;;;398      const uint8_t aPredivFactorTable[2] = { 1, 2};
00000e  a034              ADR      r0,|L2.224|
;;;399    #endif
;;;400    #endif
;;;401      uint32_t temp_reg = 0, frequency = 0;
;;;402    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;403     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;404     || defined(STM32F105xC) || defined(STM32F107xC)
;;;405      uint32_t prediv1 = 0, pllclk = 0, pllmul = 0;
;;;406    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;407    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;408      uint32_t pll2mul = 0, pll3mul = 0, prediv2 = 0;
;;;409    #endif /* STM32F105xC || STM32F107xC */
;;;410    
;;;411      /* Check the parameters */
;;;412      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;413      
;;;414      switch (PeriphClk)
;;;415      {
;;;416    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;417     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;418     || defined(STM32F105xC) || defined(STM32F107xC)
;;;419      case RCC_PERIPHCLK_USB:  
;;;420        {
;;;421          /* Get RCC configuration ------------------------------------------------------*/
;;;422          temp_reg = RCC->CFGR;
000010  4c34              LDR      r4,|L2.228|
000012  6800              LDR      r0,[r0,#0]            ;398
000014  9004              STR      r0,[sp,#0x10]         ;401
000016  2000              MOVS     r0,#0                 ;401
000018  2901              CMP      r1,#1                 ;414
00001a  d031              BEQ      |L2.128|
00001c  2902              CMP      r1,#2                 ;414
00001e  d048              BEQ      |L2.178|
000020  2910              CMP      r1,#0x10              ;414
000022  d12b              BNE      |L2.124|
000024  6861              LDR      r1,[r4,#4]
;;;423      
;;;424          /* Check if PLL is enabled */
;;;425          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
000026  6822              LDR      r2,[r4,#0]
000028  01d2              LSLS     r2,r2,#7
00002a  d527              BPL      |L2.124|
;;;426          {
;;;427            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
00002c  f44f1270          MOV      r2,#0x3c0000
000030  fa92f2a2          RBIT     r2,r2
000034  f4011070          AND      r0,r1,#0x3c0000
000038  fab2f282          CLZ      r2,r2
00003c  40d0              LSRS     r0,r0,r2
;;;428            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
00003e  03c9              LSLS     r1,r1,#15
000040  f81d0000          LDRB     r0,[sp,r0]            ;427
000044  d510              BPL      |L2.104|
;;;429            {
;;;430    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;431     || defined(STM32F100xE)
;;;432              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
;;;433    #else
;;;434              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
000046  6861              LDR      r1,[r4,#4]
000048  f44f3200          MOV      r2,#0x20000
00004c  fa92f2a2          RBIT     r2,r2
000050  f4013100          AND      r1,r1,#0x20000
000054  fab2f282          CLZ      r2,r2
000058  40d1              LSRS     r1,r1,r2
00005a  aa04              ADD      r2,sp,#0x10
00005c  5c51              LDRB     r1,[r2,r1]
;;;435    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;436    
;;;437    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;438              if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;439              {
;;;440                /* PLL2 selected as Prediv1 source */
;;;441                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;442                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;443                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
;;;444                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;445              }
;;;446              else
;;;447              {
;;;448                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;449                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;450              }
;;;451              
;;;452              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;453              /* In this case need to divide pllclk by 2 */
;;;454              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
;;;455              {
;;;456                  pllclk = pllclk / 2;
;;;457              }
;;;458    #else
;;;459              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;460              {
;;;461                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;462                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
00005e  4a22              LDR      r2,|L2.232|
000060  fbb2f1f1          UDIV     r1,r2,r1
000064  4348              MULS     r0,r1,r0
000066  e001              B        |L2.108|
                  |L2.104|
;;;463              }
;;;464    #endif /* STM32F105xC || STM32F107xC */
;;;465            }
;;;466            else
;;;467            {
;;;468              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;469              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
000068  4920              LDR      r1,|L2.236|
00006a  4348              MULS     r0,r1,r0
                  |L2.108|
;;;470            }
;;;471    
;;;472            /* Calcul of the USB frequency*/
;;;473    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;474            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;475            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;476            {
;;;477              /* Prescaler of 2 selected for USB */ 
;;;478              frequency = pllclk;
;;;479            }
;;;480            else
;;;481            {
;;;482              /* Prescaler of 3 selected for USB */ 
;;;483              frequency = (2 * pllclk) / 3;
;;;484            }
;;;485    #else
;;;486            /* USBCLK = PLLCLK / USB prescaler */
;;;487            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
00006c  6861              LDR      r1,[r4,#4]
00006e  0249              LSLS     r1,r1,#9
000070  d404              BMI      |L2.124|
;;;488            {
;;;489              /* No prescaler selected for USB */
;;;490              frequency = pllclk;
;;;491            }
;;;492            else
;;;493            {
;;;494              /* Prescaler of 1.5 selected for USB */ 
;;;495              frequency = (pllclk * 2) / 3;
000072  0040              LSLS     r0,r0,#1
000074  f05f0103          MOVS.W   r1,#3
                  |L2.120|
;;;496            }
;;;497    #endif
;;;498          }
;;;499          break;
;;;500        }
;;;501    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;502    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC)\
;;;503     || defined(STM32F107xC)
;;;504      case RCC_PERIPHCLK_I2S2:  
;;;505        {
;;;506    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;507          /* SYSCLK used as source clock for I2S2 */
;;;508          frequency = HAL_RCC_GetSysClockFreq();
;;;509    #else
;;;510          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;511          {
;;;512            /* SYSCLK used as source clock for I2S2 */
;;;513            frequency = HAL_RCC_GetSysClockFreq();
;;;514          }
;;;515          else
;;;516          {
;;;517             /* Check if PLLI2S is enabled */
;;;518            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;519            {
;;;520              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;521              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;522              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> POSITION_VAL(RCC_CFGR2_PLL3MUL)) + 2;
;;;523              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;524            }
;;;525          }
;;;526    #endif /* STM32F103xE || STM32F103xG */
;;;527          break;
;;;528        }
;;;529      case RCC_PERIPHCLK_I2S3:
;;;530        {
;;;531    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;532          /* SYSCLK used as source clock for I2S3 */
;;;533          frequency = HAL_RCC_GetSysClockFreq();
;;;534    #else
;;;535          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;536          {
;;;537            /* SYSCLK used as source clock for I2S3 */
;;;538            frequency = HAL_RCC_GetSysClockFreq();
;;;539          }
;;;540          else
;;;541          {
;;;542             /* Check if PLLI2S is enabled */
;;;543            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;544            {
;;;545              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;546              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;547              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> POSITION_VAL(RCC_CFGR2_PLL3MUL)) + 2;
;;;548              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;549            }
;;;550          }
;;;551    #endif /* STM32F103xE || STM32F103xG */
;;;552          break;
;;;553        }
;;;554    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;555      case RCC_PERIPHCLK_RTC:  
;;;556        {
;;;557          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;558          temp_reg = RCC->BDCR;
;;;559    
;;;560          /* Check if LSE is ready if RTC clock selection is LSE */
;;;561          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
;;;562          {
;;;563            frequency = LSE_VALUE;
;;;564          }
;;;565          /* Check if LSI is ready if RTC clock selection is LSI */
;;;566          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
;;;567          {
;;;568            frequency = LSI_VALUE;
;;;569          }
;;;570          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;571          {
;;;572            frequency = HSE_VALUE / 128;
;;;573          }
;;;574          /* Clock not enabled for RTC*/
;;;575          else
;;;576          {
;;;577            frequency = 0;
;;;578          }
;;;579          break;
;;;580        }
;;;581      case RCC_PERIPHCLK_ADC:  
;;;582        {
;;;583          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> POSITION_VAL(RCC_CFGR_ADCPRE_DIV4)) + 1) * 2);
000078  fbb0f0f1          UDIV     r0,r0,r1
                  |L2.124|
;;;584          break;
;;;585        }
;;;586      default: 
;;;587        {
;;;588          break;
;;;589        }
;;;590      }
;;;591      return(frequency);
;;;592    }
00007c  b006              ADD      sp,sp,#0x18
00007e  bd10              POP      {r4,pc}
                  |L2.128|
000080  6a22              LDR      r2,[r4,#0x20]         ;558
000082  f3c22101          UBFX     r1,r2,#8,#2           ;561
000086  2901              CMP      r1,#1                 ;561
000088  d103              BNE      |L2.146|
00008a  0792              LSLS     r2,r2,#30             ;561
00008c  d501              BPL      |L2.146|
00008e  03c8              LSLS     r0,r1,#15             ;563
000090  e7f4              B        |L2.124|
                  |L2.146|
000092  2902              CMP      r1,#2                 ;566
000094  d105              BNE      |L2.162|
000096  6a62              LDR      r2,[r4,#0x24]         ;566
000098  0792              LSLS     r2,r2,#30             ;566
00009a  d502              BPL      |L2.162|
00009c  f6494040          MOV      r0,#0x9c40            ;568
0000a0  e7ec              B        |L2.124|
                  |L2.162|
0000a2  2903              CMP      r1,#3                 ;570
0000a4  d1ea              BNE      |L2.124|
0000a6  6821              LDR      r1,[r4,#0]            ;570
0000a8  0389              LSLS     r1,r1,#14             ;570
0000aa  d5e7              BPL      |L2.124|
0000ac  f24f4024          MOV      r0,#0xf424            ;572
0000b0  e7e4              B        |L2.124|
                  |L2.178|
0000b2  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000b6  6861              LDR      r1,[r4,#4]            ;583
0000b8  f44f4280          MOV      r2,#0x4000            ;583
0000bc  fa92f2a2          RBIT     r2,r2                 ;583
0000c0  f4014140          AND      r1,r1,#0xc000         ;583
0000c4  fab2f282          CLZ      r2,r2                 ;583
0000c8  40d1              LSRS     r1,r1,r2              ;583
0000ca  1c49              ADDS     r1,r1,#1              ;583
0000cc  0049              LSLS     r1,r1,#1              ;583
0000ce  e7d3              B        |L2.120|
;;;593    
                          ENDP

                  |L2.208|
0000d0  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
0000d4  06070809
0000d8  0a0b0c0d
0000dc  0e0f1010
                  |L2.224|
0000e0  010200            DCB      1,2,0
0000e3  00                DCB      0
                  |L2.228|
                          DCD      0x40021000
                  |L2.232|
                          DCD      0x007a1200
                  |L2.236|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;117      */
;;;118    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;119    {
000004  4605              MOV      r5,r0
;;;120      uint32_t tickstart = 0, temp_reg = 0;
;;;121    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;122      uint32_t  pllactive = 0;
;;;123    #endif /* STM32F105xC || STM32F107xC */
;;;124    
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;129      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
000006  7800              LDRB     r0,[r0,#0]
;;;130      {
;;;131        /* check for RTC Parameters used to output RTCCLK */
;;;132        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;133    
;;;134        /* Enable Power Clock*/
;;;135        __HAL_RCC_PWR_CLK_ENABLE();
000008  4c45              LDR      r4,|L3.288|
00000a  07c0              LSLS     r0,r0,#31             ;129
00000c  d074              BEQ      |L3.248|
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  f0405080          ORR      r0,r0,#0x10000000
000014  61e0              STR      r0,[r4,#0x1c]
000016  69e0              LDR      r0,[r4,#0x1c]
;;;136        
;;;137        /* Enable write access to Backup domain */
;;;138        SET_BIT(PWR->CR, PWR_CR_DBP);
000018  4e42              LDR      r6,|L3.292|
00001a  f0005080          AND      r0,r0,#0x10000000     ;135
00001e  9000              STR      r0,[sp,#0]
000020  6830              LDR      r0,[r6,#0]
000022  f4407080          ORR      r0,r0,#0x100
000026  6030              STR      r0,[r6,#0]
;;;139        
;;;140        /* Wait for Backup domain Write protection disable */
;;;141        tickstart = HAL_GetTick();
000028  f7fffffe          BL       HAL_GetTick
00002c  4607              MOV      r7,r0
;;;142        
;;;143        while((PWR->CR & PWR_CR_DBP) == RESET)
00002e  e004              B        |L3.58|
                  |L3.48|
;;;144        {
;;;145          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000030  f7fffffe          BL       HAL_GetTick
000034  1bc0              SUBS     r0,r0,r7
000036  2864              CMP      r0,#0x64
000038  d833              BHI      |L3.162|
                  |L3.58|
00003a  6830              LDR      r0,[r6,#0]            ;143
00003c  05c0              LSLS     r0,r0,#23             ;143
00003e  d5f7              BPL      |L3.48|
;;;146          {
;;;147            return HAL_TIMEOUT;
;;;148          }      
;;;149        }
;;;150          
;;;151        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;152        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
000040  6a20              LDR      r0,[r4,#0x20]
000042  f4107040          ANDS     r0,r0,#0x300
;;;153        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
000046  d051              BEQ      |L3.236|
000048  88a9              LDRH     r1,[r5,#4]
00004a  f4017140          AND      r1,r1,#0x300
00004e  4281              CMP      r1,r0
000050  d04c              BEQ      |L3.236|
;;;154        {
;;;155          /* Store the content of BDCR register before the reset of Backup Domain */
;;;156          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
000052  6a20              LDR      r0,[r4,#0x20]
;;;157          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;158          __HAL_RCC_BACKUPRESET_FORCE();
000054  2601              MOVS     r6,#1
000056  0431              LSLS     r1,r6,#16
000058  fa91f2a1          RBIT     r2,r1
00005c  fab2f282          CLZ      r2,r2
000060  0093              LSLS     r3,r2,#2
000062  4a31              LDR      r2,|L3.296|
000064  f4207040          BIC      r0,r0,#0x300          ;156
000068  4413              ADD      r3,r3,r2
00006a  f8c36400          STR      r6,[r3,#0x400]
;;;159          __HAL_RCC_BACKUPRESET_RELEASE();
00006e  fa91f1a1          RBIT     r1,r1
000072  fab1f181          CLZ      r1,r1
000076  eb020181          ADD      r1,r2,r1,LSL #2
00007a  2300              MOVS     r3,#0
00007c  f8c13400          STR      r3,[r1,#0x400]
;;;160          /* Restore the Content of BDCR register */
;;;161          RCC->BDCR = temp_reg;
000080  6220              STR      r0,[r4,#0x20]
;;;162    
;;;163          /* Wait for LSERDY if LSE was enabled */
;;;164          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
000082  07c0              LSLS     r0,r0,#31
000084  d032              BEQ      |L3.236|
;;;165          {
;;;166            /* Get timeout */
;;;167            tickstart = HAL_GetTick();
000086  f7fffffe          BL       HAL_GetTick
00008a  4607              MOV      r7,r0
;;;168          
;;;169            /* Wait till LSE is ready */  
;;;170            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;171            {
;;;172              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
00008c  f2413988          MOV      r9,#0x1388
000090  f04f0802          MOV      r8,#2                 ;170
000094  e008              B        |L3.168|
000096  bf00              NOP      
                  |L3.152|
000098  f7fffffe          BL       HAL_GetTick
00009c  1bc1              SUBS     r1,r0,r7
00009e  4549              CMP      r1,r9
0000a0  d902              BLS      |L3.168|
                  |L3.162|
;;;173              {
;;;174                return HAL_TIMEOUT;
0000a2  2003              MOVS     r0,#3
                  |L3.164|
;;;175              }      
;;;176            }  
;;;177          }
;;;178        }
;;;179        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
;;;180      }
;;;181    
;;;182      /*------------------------------ ADC clock Configuration ------------------*/ 
;;;183      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;184      {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;187        
;;;188        /* Configure the ADC clock source */
;;;189        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;190      }
;;;191    
;;;192    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;193      /*------------------------------ I2S2 Configuration ------------------------*/ 
;;;194      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;195      {
;;;196        /* Check the parameters */
;;;197        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;198    
;;;199        /* Configure the I2S2 clock source */
;;;200        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;201      }
;;;202    
;;;203      /*------------------------------ I2S3 Configuration ------------------------*/ 
;;;204      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;205      {
;;;206        /* Check the parameters */
;;;207        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;208        
;;;209        /* Configure the I2S3 clock source */
;;;210        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;211      }
;;;212    
;;;213      /*------------------------------ PLL I2S Configuration ----------------------*/ 
;;;214      /* Check that PLLI2S need to be enabled */
;;;215      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;216      {
;;;217        /* Update flag to indicate that PLL I2S should be active */
;;;218        pllactive = 1;
;;;219      }
;;;220    
;;;221      /* Check if PLL I2S need to be enabled */
;;;222      if (pllactive == 1)
;;;223      {
;;;224        /* Enable PLL I2S only if not active */
;;;225        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;226        {
;;;227          /* Check the parameters */
;;;228          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;229          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;230    
;;;231          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;232          /* Return an error only if new value is different from the programmed value */
;;;233          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL2ON) && \
;;;234            (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;235          {
;;;236            return HAL_ERROR;
;;;237          }
;;;238    
;;;239          /* Configure the HSE prediv2 factor --------------------------------*/
;;;240          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;241    
;;;242          /* Configure the main PLLI2S multiplication factors. */
;;;243          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;244          
;;;245          /* Enable the main PLLI2S. */
;;;246          __HAL_RCC_PLLI2S_ENABLE();
;;;247          
;;;248          /* Get Start Tick*/
;;;249          tickstart = HAL_GetTick();
;;;250          
;;;251          /* Wait till PLLI2S is ready */
;;;252          while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;253          {
;;;254            if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;255            {
;;;256              return HAL_TIMEOUT;
;;;257            }
;;;258          }
;;;259        }
;;;260        else
;;;261        {
;;;262          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;263          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;264          {
;;;265              return HAL_ERROR;
;;;266          }
;;;267        }
;;;268      }
;;;269    #endif /* STM32F105xC || STM32F107xC */
;;;270    
;;;271    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;272     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;273     || defined(STM32F105xC) || defined(STM32F107xC)
;;;274      /*------------------------------ USB clock Configuration ------------------*/ 
;;;275      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;276      {
;;;277        /* Check the parameters */
;;;278        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;279        
;;;280        /* Configure the USB clock source */
;;;281        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;282      }
;;;283    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;284    
;;;285      return HAL_OK;
;;;286    }
0000a4  e8bd83f8          POP      {r3-r9,pc}
                  |L3.168|
0000a8  fa98f1a8          RBIT     r1,r8                 ;170
0000ac  fab1f181          CLZ      r1,r1                 ;170
0000b0  f0410140          ORR      r1,r1,#0x40           ;170
0000b4  4640              MOV      r0,r8                 ;170
0000b6  ebb61f51          CMP      r6,r1,LSR #5          ;170
0000ba  d101              BNE      |L3.192|
0000bc  6821              LDR      r1,[r4,#0]            ;170
0000be  e00b              B        |L3.216|
                  |L3.192|
0000c0  fa90f1a0          RBIT     r1,r0                 ;170
0000c4  fab1f181          CLZ      r1,r1                 ;170
0000c8  f0410140          ORR      r1,r1,#0x40           ;170
0000cc  ebb01f51          CMP      r0,r1,LSR #5          ;170
0000d0  d101              BNE      |L3.214|
0000d2  6a21              LDR      r1,[r4,#0x20]         ;170
0000d4  e000              B        |L3.216|
                  |L3.214|
0000d6  6a61              LDR      r1,[r4,#0x24]         ;170
                  |L3.216|
0000d8  fa98f0a8          RBIT     r0,r8                 ;170
0000dc  fab0f080          CLZ      r0,r0                 ;170
0000e0  f000021f          AND      r2,r0,#0x1f           ;170
0000e4  fa06f002          LSL      r0,r6,r2              ;170
0000e8  4201              TST      r1,r0                 ;170
0000ea  d0d5              BEQ      |L3.152|
                  |L3.236|
0000ec  6a20              LDR      r0,[r4,#0x20]         ;179
0000ee  6869              LDR      r1,[r5,#4]            ;179
0000f0  f4207040          BIC      r0,r0,#0x300          ;179
0000f4  4308              ORRS     r0,r0,r1              ;179
0000f6  6220              STR      r0,[r4,#0x20]         ;179
                  |L3.248|
0000f8  7828              LDRB     r0,[r5,#0]            ;183
0000fa  0780              LSLS     r0,r0,#30             ;183
0000fc  d505              BPL      |L3.266|
0000fe  6860              LDR      r0,[r4,#4]            ;189
000100  68a9              LDR      r1,[r5,#8]            ;189
000102  f4204040          BIC      r0,r0,#0xc000         ;189
000106  4308              ORRS     r0,r0,r1              ;189
000108  6060              STR      r0,[r4,#4]            ;189
                  |L3.266|
00010a  7828              LDRB     r0,[r5,#0]            ;275
00010c  06c0              LSLS     r0,r0,#27             ;275
00010e  d505              BPL      |L3.284|
000110  6860              LDR      r0,[r4,#4]            ;281
000112  68e9              LDR      r1,[r5,#0xc]          ;281
000114  f4200080          BIC      r0,r0,#0x400000       ;281
000118  4308              ORRS     r0,r0,r1              ;281
00011a  6060              STR      r0,[r4,#4]            ;281
                  |L3.284|
00011c  2000              MOVS     r0,#0                 ;285
00011e  e7c1              B        |L3.164|
;;;287    
                          ENDP

                  |L3.288|
                          DCD      0x40021000
                  |L3.292|
                          DCD      0x40007000
                  |L3.296|
                          DCD      0x42420000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
